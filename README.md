<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","client-sdk","build.rs"],"content":"use std::process::Command;\n\nfn main() {\n\t#[cfg(feature = \"generate-bindings\")]\n\t{\n\t\tuse {cbindgen::Config, std::env};\n\n\t\tlet crate_dir = env::var(\"CARGO_MANIFEST_DIR\").unwrap();\n\t\tcbindgen::Builder::new()\n\t\t\t.with_crate(\u0026crate_dir)\n\t\t\t.with_config(Config::from_root_or_default(\u0026crate_dir))\n\t\t\t.with_parse_deps(false)\n\t\t\t.generate()\n\t\t\t.expect(\"Unable to generate bindings\")\n\t\t\t.write_to_file(\"include/quark.h\");\n\t}\n\n\tif cfg!(target_os = \"windows\") {\n\t\tlet git_hash = Command::new(\"git\")\n\t\t\t.args([\"rev-parse\", \"HEAD\"])\n\t\t\t.output()\n\t\t\t.expect(\"Failed to retrieve git hash\")\n\t\t\t.stdout;\n\n\t\tlet git_hash = String::from_utf8(git_hash)\n\t\t\t.expect(\"Failed to convert git hash to string\");\n\n\t\tlet mut res = winresource::WindowsResource::new();\n\n\t\tres.set(\n\t\t\t\"ProductVersion\",\n\t\t\t\u0026format!(\"{}.{git_hash}\", env!(\"CARGO_PKG_VERSION\")),\n\t\t);\n\t\tres.set(\"ProductName\", \"HyperScale Engine\");\n\t\tres.set(\"FileDescription\", \"HyperScale Client SDK\");\n\t\tres.set(\"LegalCopyright\", \"Metagravity Ltd.\");\n\t\tlet _ = res.compile();\n\t}\n\n\tcapnpc::CompilerCommand::new()\n\t\t.src_prefix(\"../protocol\")\n\t\t.file(\"../protocol/common.capnp\")\n\t\t.file(\"../protocol/attributes.capnp\")\n\t\t.file(\"../protocol/handshake.capnp\")\n\t\t.file(\"../protocol/inbound.capnp\")\n\t\t.file(\"../protocol/outbound.capnp\")\n\t\t.file(\"../protocol/events.capnp\")\n\t\t.default_parent_module(vec![\"protocol\".into()])\n\t\t.run()\n\t\t.expect(\"schema compiler command\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","client-sdk","src","attribute.rs"],"content":"use {\n\tcrate::protocol,\n\tarrayvec::{ArrayString, ArrayVec},\n\tprotocol::attributes::attribute,\n\tschemars::JsonSchema,\n\tserde::{Deserialize, Serialize},\n\tstd::fmt,\n};\n\npub const MAX_SEQUENCE_LENGTH: usize = 32;\n\npub type AttributeId = u16;\n\n/// Attribute type (list of Attribute types supported can be found in docs)\n#[repr(u8)]\n#[derive(Debug, Clone, Copy, Serialize, PartialEq, JsonSchema, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum AttributeType {\n\tNone = 0,\n\tBool = 1,\n\tVec2 = 2,\n\tVec3 = 3,\n\tUint8 = 4,\n\tUint16 = 5,\n\tUint32 = 6,\n\tUint64 = 7,\n\tInt8 = 8,\n\tInt16 = 9,\n\tInt32 = 10,\n\tInt64 = 11,\n\tFloat32 = 12,\n\tFloat64 = 13,\n\tString = 14,\n\tBytes = 15,\n\tVec2d = 16,\n\tVec3d = 17,\n\tVec4 = 18,\n\tVec4d = 19,\n}\n\nimpl AttributeType {\n\tpub const fn is_none(\u0026self) -\u003e bool {\n\t\tmatches!(self, AttributeType::None)\n\t}\n\n\tpub const fn is_integer(\u0026self) -\u003e bool {\n\t\tmatches!(\n\t\t\tself,\n\t\t\tAttributeType::Uint8\n\t\t\t\t| AttributeType::Uint16\n\t\t\t\t| AttributeType::Uint32\n\t\t\t\t| AttributeType::Uint64\n\t\t\t\t| AttributeType::Int8\n\t\t\t\t| AttributeType::Int16\n\t\t\t\t| AttributeType::Int32\n\t\t\t\t| AttributeType::Int64\n\t\t)\n\t}\n\n\tpub const fn is_interpolable(\u0026self) -\u003e bool {\n\t\tmatches!(\n\t\t\tself,\n\t\t\tAttributeType::Uint8\n\t\t\t\t| AttributeType::Uint16\n\t\t\t\t| AttributeType::Uint32\n\t\t\t\t| AttributeType::Uint64\n\t\t\t\t| AttributeType::Int8\n\t\t\t\t| AttributeType::Int16\n\t\t\t\t| AttributeType::Int32\n\t\t\t\t| AttributeType::Int64\n\t\t\t\t| AttributeType::Float32\n\t\t\t\t| AttributeType::Float64\n\t\t\t\t| AttributeType::Vec2\n\t\t\t\t| AttributeType::Vec3\n\t\t\t\t| AttributeType::Vec4\n\t\t\t\t| AttributeType::Vec2d\n\t\t\t\t| AttributeType::Vec3d\n\t\t\t\t| AttributeType::Vec4d\n\t\t)\n\t}\n}\n\n#[derive(Debug, PartialEq, Eq)]\npub struct AttributeIndexError;\nimpl fmt::Display for AttributeIndexError {\n\tfn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n\t\twrite!(f, \"attribute index is out of limit\")\n\t}\n}\nimpl std::error::Error for AttributeIndexError {}\n\nimpl TryFrom\u003cu8\u003e for AttributeType {\n\ttype Error = AttributeIndexError;\n\n\tfn try_from(value: u8) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tOk(match value {\n\t\t\t0 =\u003e AttributeType::None,\n\t\t\t1 =\u003e AttributeType::Bool,\n\t\t\t2 =\u003e AttributeType::Vec2,\n\t\t\t3 =\u003e AttributeType::Vec3,\n\t\t\t4 =\u003e AttributeType::Uint8,\n\t\t\t5 =\u003e AttributeType::Uint16,\n\t\t\t6 =\u003e AttributeType::Uint32,\n\t\t\t7 =\u003e AttributeType::Uint64,\n\t\t\t8 =\u003e AttributeType::Int8,\n\t\t\t9 =\u003e AttributeType::Int16,\n\t\t\t10 =\u003e AttributeType::Int32,\n\t\t\t11 =\u003e AttributeType::Int64,\n\t\t\t12 =\u003e AttributeType::Float32,\n\t\t\t13 =\u003e AttributeType::Float64,\n\t\t\t14 =\u003e AttributeType::String,\n\t\t\t15 =\u003e AttributeType::Bytes,\n\t\t\t16 =\u003e AttributeType::Vec2d,\n\t\t\t17 =\u003e AttributeType::Vec3d,\n\t\t\t18 =\u003e AttributeType::Vec4,\n\t\t\t19 =\u003e AttributeType::Vec4d,\n\t\t\t_ =\u003e return Err(AttributeIndexError),\n\t\t})\n\t}\n}\n\n#[derive(Debug, Default, Clone, Serialize, PartialEq)]\npub enum Value {\n\t#[default]\n\tNone,\n\tBool(bool),\n\tVec2((f32, f32)),\n\tVec3((f32, f32, f32)),\n\tUint8(u8),\n\tUint16(u16),\n\tUint32(u32),\n\tUint64(u64),\n\tInt8(i8),\n\tInt16(i16),\n\tInt32(i32),\n\tInt64(i64),\n\tFloat32(f32),\n\tFloat64(f64),\n\tString(ArrayString\u003cMAX_SEQUENCE_LENGTH\u003e),\n\tBytes(ArrayVec\u003cu8, MAX_SEQUENCE_LENGTH\u003e),\n\tVec2d((f64, f64)),\n\tVec3d((f64, f64, f64)),\n\tVec4((f32, f32, f32, f32)),\n\tVec4d((f64, f64, f64, f64)),\n}\n\nimpl Value {\n\tpub fn from_capnp_reader(\n\t\treader: \u0026attribute::value::Reader,\n\t) -\u003e Result\u003cSelf, capnp::Error\u003e {\n\t\tuse attribute::value::Which;\n\t\tOk(match reader.which()? {\n\t\t\tWhich::None(()) =\u003e Value::None,\n\t\t\tWhich::Bool(v) =\u003e Value::Bool(v),\n\t\t\tWhich::Vec2(v) =\u003e {\n\t\t\t\tlet v = v?;\n\t\t\t\tlet x = v.get_x();\n\t\t\t\tlet y = v.get_y();\n\t\t\t\tValue::Vec2((x, y))\n\t\t\t}\n\t\t\tWhich::Vec3(v) =\u003e {\n\t\t\t\tlet v = v?;\n\t\t\t\tlet x = v.get_x();\n\t\t\t\tlet y = v.get_y();\n\t\t\t\tlet z = v.get_z();\n\n\t\t\t\tValue::Vec3((x, y, z))\n\t\t\t}\n\t\t\tWhich::Vec2d(v) =\u003e {\n\t\t\t\tlet v = v?;\n\t\t\t\tlet x = v.get_x();\n\t\t\t\tlet y = v.get_y();\n\t\t\t\tValue::Vec2d((x, y))\n\t\t\t}\n\t\t\tWhich::Vec3d(v) =\u003e {\n\t\t\t\tlet v = v?;\n\t\t\t\tlet x = v.get_x();\n\t\t\t\tlet y = v.get_y();\n\t\t\t\tlet z = v.get_z();\n\n\t\t\t\tValue::Vec3d((x, y, z))\n\t\t\t}\n\t\t\tWhich::Vec4(v) =\u003e {\n\t\t\t\tlet v = v?;\n\t\t\t\tlet x = v.get_x();\n\t\t\t\tlet y = v.get_y();\n\t\t\t\tlet z = v.get_z();\n\t\t\t\tlet w = v.get_w();\n\n\t\t\t\tValue::Vec4((x, y, z, w))\n\t\t\t}\n\t\t\tWhich::Vec4d(v) =\u003e {\n\t\t\t\tlet v = v?;\n\t\t\t\tlet x = v.get_x();\n\t\t\t\tlet y = v.get_y();\n\t\t\t\tlet z = v.get_z();\n\t\t\t\tlet w = v.get_w();\n\n\t\t\t\tValue::Vec4d((x, y, z, w))\n\t\t\t}\n\t\t\tWhich::Uint8(v) =\u003e Value::Uint8(v),\n\t\t\tWhich::Uint16(v) =\u003e Value::Uint16(v),\n\t\t\tWhich::Uint32(v) =\u003e Value::Uint32(v),\n\t\t\tWhich::Uint64(v) =\u003e Value::Uint64(v),\n\t\t\tWhich::Int8(v) =\u003e Value::Int8(v),\n\t\t\tWhich::Int16(v) =\u003e Value::Int16(v),\n\t\t\tWhich::Int32(v) =\u003e Value::Int32(v),\n\t\t\tWhich::Int64(v) =\u003e Value::Int64(v),\n\t\t\tWhich::Float32(v) =\u003e Value::Float32(v),\n\t\t\tWhich::Float64(v) =\u003e Value::Float64(v),\n\t\t\tWhich::String(v) =\u003e Value::String(\n\t\t\t\tArrayString::try_from(v?.to_string()?.as_str()).map_err(|_| {\n\t\t\t\t\tcapnp::Error::unimplemented(\"maximum sequence length is 64\".into())\n\t\t\t\t})?,\n\t\t\t),\n\t\t\tWhich::Bytes(v) =\u003e {\n\t\t\t\tValue::Bytes(ArrayVec::try_from(v?).map_err(|_| {\n\t\t\t\t\tcapnp::Error::unimplemented(\"maximum sequence length is 64\".into())\n\t\t\t\t})?)\n\t\t\t}\n\t\t})\n\t}\n\n\tpub fn write_to_capnp(\u0026self, builder: \u0026mut attribute::value::Builder) {\n\t\tmatch self {\n\t\t\tValue::None =\u003e builder.set_none(()),\n\t\t\tValue::Bool(v) =\u003e builder.set_bool(*v),\n\t\t\tValue::Vec2((x, y)) =\u003e {\n\t\t\t\tlet mut vec2 = builder.reborrow().init_vec2();\n\t\t\t\tvec2.set_x(*x);\n\t\t\t\tvec2.set_y(*y);\n\t\t\t}\n\t\t\tValue::Vec3((x, y, z)) =\u003e {\n\t\t\t\tlet mut vec3 = builder.reborrow().init_vec3();\n\t\t\t\tvec3.set_x(*x);\n\t\t\t\tvec3.set_y(*y);\n\t\t\t\tvec3.set_z(*z);\n\t\t\t}\n\t\t\tValue::Vec2d((x, y)) =\u003e {\n\t\t\t\tlet mut vec2d = builder.reborrow().init_vec2d();\n\t\t\t\tvec2d.set_x(*x);\n\t\t\t\tvec2d.set_y(*y);\n\t\t\t}\n\t\t\tValue::Vec3d((x, y, z)) =\u003e {\n\t\t\t\tlet mut vec3d = builder.reborrow().init_vec3d();\n\t\t\t\tvec3d.set_x(*x);\n\t\t\t\tvec3d.set_y(*y);\n\t\t\t\tvec3d.set_z(*z);\n\t\t\t}\n\t\t\tValue::Vec4((x, y, z, w)) =\u003e {\n\t\t\t\tlet mut vec4 = builder.reborrow().init_vec4();\n\t\t\t\tvec4.set_x(*x);\n\t\t\t\tvec4.set_y(*y);\n\t\t\t\tvec4.set_z(*z);\n\t\t\t\tvec4.set_w(*w);\n\t\t\t}\n\t\t\tValue::Vec4d((x, y, z, w)) =\u003e {\n\t\t\t\tlet mut vec4d = builder.reborrow().init_vec4d();\n\t\t\t\tvec4d.set_x(*x);\n\t\t\t\tvec4d.set_y(*y);\n\t\t\t\tvec4d.set_z(*z);\n\t\t\t\tvec4d.set_w(*w);\n\t\t\t}\n\t\t\tValue::Uint8(v) =\u003e builder.set_uint8(*v),\n\t\t\tValue::Uint16(v) =\u003e builder.set_uint16(*v),\n\t\t\tValue::Uint32(v) =\u003e builder.set_uint32(*v),\n\t\t\tValue::Uint64(v) =\u003e builder.set_uint64(*v),\n\t\t\tValue::Int8(v) =\u003e builder.set_int8(*v),\n\t\t\tValue::Int16(v) =\u003e builder.set_int16(*v),\n\t\t\tValue::Int32(v) =\u003e builder.set_int32(*v),\n\t\t\tValue::Int64(v) =\u003e builder.set_int64(*v),\n\t\t\tValue::Float32(v) =\u003e builder.set_float32(*v),\n\t\t\tValue::Float64(v) =\u003e builder.set_float64(*v),\n\t\t\tValue::String(v) =\u003e {\n\t\t\t\tbuilder.reborrow().init_string(v.len() as u32).push_str(v)\n\t\t\t}\n\t\t\tValue::Bytes(v) =\u003e builder.set_bytes(v),\n\t\t}\n\t}\n\n\tpub const fn typeid(\u0026self) -\u003e AttributeType {\n\t\tmatch self {\n\t\t\tValue::None =\u003e AttributeType::None,\n\t\t\tValue::Bool(_) =\u003e AttributeType::Bool,\n\t\t\tValue::Vec2(_) =\u003e AttributeType::Vec2,\n\t\t\tValue::Vec3(_) =\u003e AttributeType::Vec3,\n\t\t\tValue::Vec2d(_) =\u003e AttributeType::Vec2d,\n\t\t\tValue::Vec3d(_) =\u003e AttributeType::Vec3d,\n\t\t\tValue::Vec4(_) =\u003e AttributeType::Vec4,\n\t\t\tValue::Vec4d(_) =\u003e AttributeType::Vec4d,\n\t\t\tValue::Uint8(_) =\u003e AttributeType::Uint8,\n\t\t\tValue::Uint16(_) =\u003e AttributeType::Uint16,\n\t\t\tValue::Uint32(_) =\u003e AttributeType::Uint32,\n\t\t\tValue::Uint64(_) =\u003e AttributeType::Uint64,\n\t\t\tValue::Int8(_) =\u003e AttributeType::Int8,\n\t\t\tValue::Int16(_) =\u003e AttributeType::Int16,\n\t\t\tValue::Int32(_) =\u003e AttributeType::Int32,\n\t\t\tValue::Int64(_) =\u003e AttributeType::Int64,\n\t\t\tValue::Float32(_) =\u003e AttributeType::Float32,\n\t\t\tValue::Float64(_) =\u003e AttributeType::Float64,\n\t\t\tValue::String(_) =\u003e AttributeType::String,\n\t\t\tValue::Bytes(_) =\u003e AttributeType::Bytes,\n\t\t}\n\t}\n}\nimpl TryFrom\u003cbool\u003e for Value {\n\ttype Error = ();\n\n\tfn try_from(value: bool) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tOk(Value::Bool(value))\n\t}\n}\n\nimpl TryFrom\u003c(f32, f32)\u003e for Value {\n\ttype Error = ();\n\n\tfn try_from(value: (f32, f32)) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tOk(Value::Vec2(value))\n\t}\n}\n\nimpl TryFrom\u003c(f32, f32, f32)\u003e for Value {\n\ttype Error = ();\n\n\tfn try_from(value: (f32, f32, f32)) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tOk(Value::Vec3(value))\n\t}\n}\n\nimpl TryFrom\u003c(f64, f64)\u003e for Value {\n\ttype Error = ();\n\n\tfn try_from(value: (f64, f64)) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tOk(Value::Vec2d(value))\n\t}\n}\n\nimpl TryFrom\u003c(f64, f64, f64)\u003e for Value {\n\ttype Error = ();\n\n\tfn try_from(value: (f64, f64, f64)) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tOk(Value::Vec3d(value))\n\t}\n}\n\nimpl TryFrom\u003c(f32, f32, f32, f32)\u003e for Value {\n\ttype Error = ();\n\n\tfn try_from(value: (f32, f32, f32, f32)) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tOk(Value::Vec4(value))\n\t}\n}\nimpl TryFrom\u003c(f64, f64, f64, f64)\u003e for Value {\n\ttype Error = ();\n\n\tfn try_from(value: (f64, f64, f64, f64)) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tOk(Value::Vec4d(value))\n\t}\n}\n\nimpl TryFrom\u003cu8\u003e for Value {\n\ttype Error = ();\n\n\tfn try_from(value: u8) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tOk(Value::Uint8(value))\n\t}\n}\n\nimpl TryFrom\u003cu16\u003e for Value {\n\ttype Error = ();\n\n\tfn try_from(value: u16) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tOk(Value::Uint16(value))\n\t}\n}\n\nimpl TryFrom\u003cu32\u003e for Value {\n\ttype Error = ();\n\n\tfn try_from(value: u32) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tOk(Value::Uint32(value))\n\t}\n}\n\nimpl TryFrom\u003cu64\u003e for Value {\n\ttype Error = ();\n\n\tfn try_from(value: u64) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tOk(Value::Uint64(value))\n\t}\n}\n\nimpl TryFrom\u003ci8\u003e for Value {\n\ttype Error = ();\n\n\tfn try_from(value: i8) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tOk(Value::Int8(value))\n\t}\n}\n\nimpl TryFrom\u003ci16\u003e for Value {\n\ttype Error = ();\n\n\tfn try_from(value: i16) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tOk(Value::Int16(value))\n\t}\n}\n\nimpl TryFrom\u003ci32\u003e for Value {\n\ttype Error = ();\n\n\tfn try_from(value: i32) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tOk(Value::Int32(value))\n\t}\n}\n\nimpl TryFrom\u003ci64\u003e for Value {\n\ttype Error = ();\n\n\tfn try_from(value: i64) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tOk(Value::Int64(value))\n\t}\n}\n\nimpl TryFrom\u003cf32\u003e for Value {\n\ttype Error = ();\n\n\tfn try_from(value: f32) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tOk(Value::Float32(value))\n\t}\n}\n\nimpl TryFrom\u003cf64\u003e for Value {\n\ttype Error = ();\n\n\tfn try_from(value: f64) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tOk(Value::Float64(value))\n\t}\n}\n\nimpl TryFrom\u003c\u0026str\u003e for Value {\n\ttype Error = ();\n\n\tfn try_from(value: \u0026str) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tOk(Value::String(ArrayString::try_from(value).map_err(|_| ())?))\n\t}\n}\n\nimpl TryFrom\u003c\u0026[u8]\u003e for Value {\n\ttype Error = ();\n\n\tfn try_from(value: \u0026[u8]) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tOk(Value::Bytes(ArrayVec::try_from(value).map_err(|_| ())?))\n\t}\n}\n\nimpl TryFrom\u003cArrayString\u003cMAX_SEQUENCE_LENGTH\u003e\u003e for Value {\n\ttype Error = ();\n\n\tfn try_from(\n\t\tvalue: ArrayString\u003cMAX_SEQUENCE_LENGTH\u003e,\n\t) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tOk(Value::String(value))\n\t}\n}\n\nimpl TryFrom\u003cArrayVec\u003cu8, MAX_SEQUENCE_LENGTH\u003e\u003e for Value {\n\ttype Error = ();\n\n\tfn try_from(\n\t\tvalue: ArrayVec\u003cu8, MAX_SEQUENCE_LENGTH\u003e,\n\t) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tOk(Value::Bytes(value))\n\t}\n}\n\nimpl TryFrom\u003cValue\u003e for bool {\n\ttype Error = ();\n\n\tfn try_from(value: Value) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tmatch value {\n\t\t\tValue::Bool(v) =\u003e Ok(v),\n\t\t\t_ =\u003e Err(()),\n\t\t}\n\t}\n}\n\nimpl TryFrom\u003cValue\u003e for (f32, f32) {\n\ttype Error = ();\n\n\tfn try_from(value: Value) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tmatch value {\n\t\t\tValue::Vec2(v) =\u003e Ok(v),\n\t\t\t_ =\u003e Err(()),\n\t\t}\n\t}\n}\n\nimpl TryFrom\u003cValue\u003e for (f32, f32, f32) {\n\ttype Error = ();\n\n\tfn try_from(value: Value) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tmatch value {\n\t\t\tValue::Vec3(v) =\u003e Ok(v),\n\t\t\t_ =\u003e Err(()),\n\t\t}\n\t}\n}\n\nimpl TryFrom\u003cValue\u003e for (f64, f64) {\n\ttype Error = ();\n\n\tfn try_from(value: Value) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tmatch value {\n\t\t\tValue::Vec2d(v) =\u003e Ok(v),\n\t\t\t_ =\u003e Err(()),\n\t\t}\n\t}\n}\n\nimpl TryFrom\u003cValue\u003e for (f64, f64, f64) {\n\ttype Error = ();\n\n\tfn try_from(value: Value) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tmatch value {\n\t\t\tValue::Vec3d(v) =\u003e Ok(v),\n\t\t\t_ =\u003e Err(()),\n\t\t}\n\t}\n}\n\nimpl TryFrom\u003cValue\u003e for (f32, f32, f32, f32) {\n\ttype Error = ();\n\n\tfn try_from(value: Value) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tmatch value {\n\t\t\tValue::Vec4(v) =\u003e Ok(v),\n\t\t\t_ =\u003e Err(()),\n\t\t}\n\t}\n}\n\nimpl TryFrom\u003cValue\u003e for (f64, f64, f64, f64) {\n\ttype Error = ();\n\n\tfn try_from(value: Value) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tmatch value {\n\t\t\tValue::Vec4d(v) =\u003e Ok(v),\n\t\t\t_ =\u003e Err(()),\n\t\t}\n\t}\n}\n\nimpl TryFrom\u003cValue\u003e for u8 {\n\ttype Error = ();\n\n\tfn try_from(value: Value) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tmatch value {\n\t\t\tValue::Uint8(v) =\u003e Ok(v),\n\t\t\tValue::Uint16(v) =\u003e Ok(v as u8),\n\t\t\tValue::Uint32(v) =\u003e Ok(v as u8),\n\t\t\tValue::Uint64(v) =\u003e Ok(v as u8),\n\t\t\tValue::Int8(v) =\u003e Ok(v as u8),\n\t\t\tValue::Int16(v) =\u003e Ok(v as u8),\n\t\t\tValue::Int32(v) =\u003e Ok(v as u8),\n\t\t\tValue::Int64(v) =\u003e Ok(v as u8),\n\t\t\t_ =\u003e Err(()),\n\t\t}\n\t}\n}\n\nimpl TryFrom\u003cValue\u003e for u16 {\n\ttype Error = ();\n\n\tfn try_from(value: Value) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tmatch value {\n\t\t\tValue::Uint8(v) =\u003e Ok(v as u16),\n\t\t\tValue::Uint16(v) =\u003e Ok(v),\n\t\t\tValue::Uint32(v) =\u003e Ok(v as u16),\n\t\t\tValue::Uint64(v) =\u003e Ok(v as u16),\n\t\t\tValue::Int8(v) =\u003e Ok(v as u16),\n\t\t\tValue::Int16(v) =\u003e Ok(v as u16),\n\t\t\tValue::Int32(v) =\u003e Ok(v as u16),\n\t\t\tValue::Int64(v) =\u003e Ok(v as u16),\n\t\t\t_ =\u003e Err(()),\n\t\t}\n\t}\n}\n\nimpl TryFrom\u003cValue\u003e for u32 {\n\ttype Error = ();\n\n\tfn try_from(value: Value) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tmatch value {\n\t\t\tValue::Uint8(v) =\u003e Ok(v as u32),\n\t\t\tValue::Uint16(v) =\u003e Ok(v as u32),\n\t\t\tValue::Uint32(v) =\u003e Ok(v),\n\t\t\tValue::Uint64(v) =\u003e Ok(v as u32),\n\t\t\tValue::Int8(v) =\u003e Ok(v as u32),\n\t\t\tValue::Int16(v) =\u003e Ok(v as u32),\n\t\t\tValue::Int32(v) =\u003e Ok(v as u32),\n\t\t\tValue::Int64(v) =\u003e Ok(v as u32),\n\t\t\t_ =\u003e Err(()),\n\t\t}\n\t}\n}\n\nimpl TryFrom\u003cValue\u003e for u64 {\n\ttype Error = ();\n\n\tfn try_from(value: Value) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tmatch value {\n\t\t\tValue::Uint8(v) =\u003e Ok(v as u64),\n\t\t\tValue::Uint16(v) =\u003e Ok(v as u64),\n\t\t\tValue::Uint32(v) =\u003e Ok(v as u64),\n\t\t\tValue::Uint64(v) =\u003e Ok(v),\n\t\t\tValue::Int8(v) =\u003e Ok(v as u64),\n\t\t\tValue::Int16(v) =\u003e Ok(v as u64),\n\t\t\tValue::Int32(v) =\u003e Ok(v as u64),\n\t\t\tValue::Int64(v) =\u003e Ok(v as u64),\n\t\t\t_ =\u003e Err(()),\n\t\t}\n\t}\n}\n\nimpl TryFrom\u003cValue\u003e for i8 {\n\ttype Error = ();\n\n\tfn try_from(value: Value) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tmatch value {\n\t\t\tValue::Uint8(v) =\u003e Ok(v as i8),\n\t\t\tValue::Uint16(v) =\u003e Ok(v as i8),\n\t\t\tValue::Uint32(v) =\u003e Ok(v as i8),\n\t\t\tValue::Uint64(v) =\u003e Ok(v as i8),\n\t\t\tValue::Int8(v) =\u003e Ok(v),\n\t\t\tValue::Int16(v) =\u003e Ok(v as i8),\n\t\t\tValue::Int32(v) =\u003e Ok(v as i8),\n\t\t\tValue::Int64(v) =\u003e Ok(v as i8),\n\t\t\t_ =\u003e Err(()),\n\t\t}\n\t}\n}\n\nimpl TryFrom\u003cValue\u003e for i16 {\n\ttype Error = ();\n\n\tfn try_from(value: Value) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tmatch value {\n\t\t\tValue::Uint8(v) =\u003e Ok(v as i16),\n\t\t\tValue::Uint16(v) =\u003e Ok(v as i16),\n\t\t\tValue::Uint32(v) =\u003e Ok(v as i16),\n\t\t\tValue::Uint64(v) =\u003e Ok(v as i16),\n\t\t\tValue::Int8(v) =\u003e Ok(v as i16),\n\t\t\tValue::Int16(v) =\u003e Ok(v),\n\t\t\tValue::Int32(v) =\u003e Ok(v as i16),\n\t\t\tValue::Int64(v) =\u003e Ok(v as i16),\n\t\t\t_ =\u003e Err(()),\n\t\t}\n\t}\n}\n\nimpl TryFrom\u003cValue\u003e for i32 {\n\ttype Error = ();\n\n\tfn try_from(value: Value) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tmatch value {\n\t\t\tValue::Uint8(v) =\u003e Ok(v as i32),\n\t\t\tValue::Uint16(v) =\u003e Ok(v as i32),\n\t\t\tValue::Uint32(v) =\u003e Ok(v as i32),\n\t\t\tValue::Uint64(v) =\u003e Ok(v as i32),\n\t\t\tValue::Int8(v) =\u003e Ok(v as i32),\n\t\t\tValue::Int16(v) =\u003e Ok(v as i32),\n\t\t\tValue::Int32(v) =\u003e Ok(v),\n\t\t\tValue::Int64(v) =\u003e Ok(v as i32),\n\t\t\t_ =\u003e Err(()),\n\t\t}\n\t}\n}\n\nimpl TryFrom\u003cValue\u003e for i64 {\n\ttype Error = ();\n\n\tfn try_from(value: Value) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tmatch value {\n\t\t\tValue::Uint8(v) =\u003e Ok(v as i64),\n\t\t\tValue::Uint16(v) =\u003e Ok(v as i64),\n\t\t\tValue::Uint32(v) =\u003e Ok(v as i64),\n\t\t\tValue::Uint64(v) =\u003e Ok(v as i64),\n\t\t\tValue::Int8(v) =\u003e Ok(v as i64),\n\t\t\tValue::Int16(v) =\u003e Ok(v as i64),\n\t\t\tValue::Int32(v) =\u003e Ok(v as i64),\n\t\t\tValue::Int64(v) =\u003e Ok(v),\n\t\t\t_ =\u003e Err(()),\n\t\t}\n\t}\n}\n\nimpl TryFrom\u003cValue\u003e for f32 {\n\ttype Error = ();\n\n\tfn try_from(value: Value) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tmatch value {\n\t\t\tValue::Uint8(v) =\u003e Ok(v as f32),\n\t\t\tValue::Uint16(v) =\u003e Ok(v as f32),\n\t\t\tValue::Uint32(v) =\u003e Ok(v as f32),\n\t\t\tValue::Uint64(v) =\u003e Ok(v as f32),\n\t\t\tValue::Int8(v) =\u003e Ok(v as f32),\n\t\t\tValue::Int16(v) =\u003e Ok(v as f32),\n\t\t\tValue::Int32(v) =\u003e Ok(v as f32),\n\t\t\tValue::Int64(v) =\u003e Ok(v as f32),\n\t\t\tValue::Float32(v) =\u003e Ok(v),\n\t\t\t_ =\u003e Err(()),\n\t\t}\n\t}\n}\n\nimpl TryFrom\u003cValue\u003e for f64 {\n\ttype Error = ();\n\n\tfn try_from(value: Value) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tmatch value {\n\t\t\tValue::Uint8(v) =\u003e Ok(v as f64),\n\t\t\tValue::Uint16(v) =\u003e Ok(v as f64),\n\t\t\tValue::Uint32(v) =\u003e Ok(v as f64),\n\t\t\tValue::Uint64(v) =\u003e Ok(v as f64),\n\t\t\tValue::Int8(v) =\u003e Ok(v as f64),\n\t\t\tValue::Int16(v) =\u003e Ok(v as f64),\n\t\t\tValue::Int32(v) =\u003e Ok(v as f64),\n\t\t\tValue::Int64(v) =\u003e Ok(v as f64),\n\t\t\tValue::Float32(v) =\u003e Ok(v as f64),\n\t\t\tValue::Float64(v) =\u003e Ok(v),\n\t\t\t_ =\u003e Err(()),\n\t\t}\n\t}\n}\n\n#[derive(Debug, Clone)]\npub struct Attribute {\n\tpub key: AttributeId,\n\tpub value: Value,\n}\n\nimpl TryFrom\u003cattribute::Reader\u003c'_\u003e\u003e for Attribute {\n\ttype Error = capnp::Error;\n\n\tfn try_from(reader: attribute::Reader) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tOk(Attribute {\n\t\t\tkey: reader.get_key(),\n\t\t\tvalue: Value::from_capnp_reader(\u0026reader.get_value())?,\n\t\t})\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","client-sdk","src","bindings","consts.rs"],"content":"use {\n\tsuper::quark_attribute_id_t,\n\tcrate::{protocol, Relevance},\n};\n\n/// Supported by the spatial index.\n/// Attribute type: Vec3\n#[no_mangle]\npub static QUARK_KNOWN_ATTRIBUTE_POSITION: quark_attribute_id_t =\n\tprotocol::WellKnownAttribute::Position as quark_attribute_id_t;\n\n/// Attribute type: Vec3\n#[no_mangle]\npub static QUARK_KNOWN_ATTRIBUTE_ROTATION: quark_attribute_id_t =\n\tprotocol::WellKnownAttribute::Rotation as quark_attribute_id_t;\n\n#[no_mangle]\npub static QUARK_KNOWN_ATTRIBUTE_GROUP_ID: quark_attribute_id_t =\n\tprotocol::WellKnownAttribute::GroupId as quark_attribute_id_t;\n\n/// Attribute type: Uint64\n#[no_mangle]\npub static QUARK_KNOWN_ATTRIBUTE_CLASS_ID: quark_attribute_id_t =\n\tprotocol::WellKnownAttribute::ClassId as quark_attribute_id_t;\n\n/// Attribute type: Uint64 for objects and Uint32 for players\n#[no_mangle]\npub static QUARK_KNOWN_ATTRIBUTE_OWNER_ID: quark_attribute_id_t =\n\tprotocol::WellKnownAttribute::OwnerId as quark_attribute_id_t;\n\n/// Attribute type: Uint64\n#[no_mangle]\npub static QUARK_KNOWN_ATTRIBUTE_INTEREST_CENTROID: quark_attribute_id_t =\n\tprotocol::WellKnownAttribute::Delegate as quark_attribute_id_t;\n\n#[no_mangle]\npub static QUARK_KNOWN_ATTRIBUTE_HIDDEN: quark_attribute_id_t =\n\tprotocol::WellKnownAttribute::Hidden as quark_attribute_id_t;\n\n#[no_mangle]\npub static QUARK_MAX_INTEREST_RADIUS: f32 = Relevance::max().value();\n\n#[no_mangle]\npub static QUARK_MIN_INTEREST_RADIUS: f32 = Relevance::min().value();\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","client-sdk","src","bindings","error.rs"],"content":"use {crate::Error, std::ffi::*};\n\n#[allow(non_camel_case_types)]\npub type quark_error_t = u32;\npub const QUARK_ERROR_SUCCESS: quark_error_t = 0;\npub const QUARK_ERROR_INVALID_ARGUMENT: quark_error_t = 1;\npub const QUARK_ERROR_SESSION_IO: quark_error_t = 2;\npub const QUARK_ERROR_SESSION_REJECTED: quark_error_t = 3;\npub const QUARK_ERROR_SESSION_SERVER_STREAM_CLOSED: quark_error_t = 4;\npub const QUARK_ERROR_SESSION_PROTOCOL: quark_error_t = 5;\npub const QUARK_ERROR_SESSION_SERIALIZATION: quark_error_t = 6;\npub const QUARK_ERROR_SESSION_DESERIALIZATION: quark_error_t = 7;\npub const QUARK_ERROR_TOO_MANY_ATTRIBS: quark_error_t = 8;\npub const QUARK_ERROR_INVALID_ATTRIB_TYPE: quark_error_t = 9;\npub const QUARK_ERROR_BUFFER_TOO_SMALL: quark_error_t = 10;\npub const QUARK_ERROR_UNKNOWN: quark_error_t = 11;\npub const QUARK_ERROR_NO_DATA: quark_error_t = 12;\npub const QUARK_ERROR_BAD_ADDR_FORMAT: quark_error_t = 13;\npub const QUARK_ERROR_INVALID_DNS_NAME: quark_error_t = 14;\npub const QUARK_ERROR_CERT_LOAD_FAILED: quark_error_t = 15;\npub const QUARK_ERROR_CERT_ADD_FAILED: quark_error_t = 16;\npub const QUARK_ERROR_UDP_STREAM_NOT_AVAILABLE: quark_error_t = 17;\npub const QUARK_ERROR_DATA_NOT_SUPPORTED: quark_error_t = 18;\npub const QUARK_ERROR_INVALID_PACKET: quark_error_t = 19;\npub const QUARK_ERROR_INVALID_USER: quark_error_t = 20;\n\nmacro_rules! s {\n\t($s:literal) =\u003e {\n\t\tconcat!($s, \"\\0\").as_ptr() as *const c_char\n\t};\n}\n\n/// Returns a string describing the error code.\n///\n/// The returned string is valid until the next call to this function.\n#[no_mangle]\npub unsafe extern \"C\" fn quark_error_string(\n\terror: quark_error_t,\n) -\u003e *const c_char {\n\tmatch error {\n\t\tQUARK_ERROR_SUCCESS =\u003e s!(\"success\"),\n\t\tQUARK_ERROR_INVALID_ARGUMENT =\u003e s!(\"invalid argument\"),\n\t\tQUARK_ERROR_SESSION_IO =\u003e s!(\"session io error\"),\n\t\tQUARK_ERROR_SESSION_REJECTED =\u003e s!(\"session rejected\"),\n\t\tQUARK_ERROR_SESSION_SERVER_STREAM_CLOSED =\u003e {\n\t\t\ts!(\"session server stream closed\")\n\t\t}\n\t\tQUARK_ERROR_SESSION_PROTOCOL =\u003e s!(\"protocol error\"),\n\t\tQUARK_ERROR_SESSION_SERIALIZATION =\u003e s!(\"protocol error\"),\n\t\tQUARK_ERROR_SESSION_DESERIALIZATION =\u003e {\n\t\t\ts!(\"unexpected response from server\")\n\t\t}\n\t\tQUARK_ERROR_TOO_MANY_ATTRIBS =\u003e s!(\"too many attributes\"),\n\t\tQUARK_ERROR_INVALID_ATTRIB_TYPE =\u003e s!(\"invalid attribute type\"),\n\t\tQUARK_ERROR_BUFFER_TOO_SMALL =\u003e s!(\"buffer too small\"),\n\t\tQUARK_ERROR_BAD_ADDR_FORMAT =\u003e s!(\"bad address format\"),\n\t\tQUARK_ERROR_INVALID_DNS_NAME =\u003e s!(\"invalid dns name\"),\n\t\tQUARK_ERROR_CERT_LOAD_FAILED =\u003e s!(\"cert load failed\"),\n\t\tQUARK_ERROR_CERT_ADD_FAILED =\u003e s!(\"cert add failed\"),\n\t\tQUARK_ERROR_UDP_STREAM_NOT_AVAILABLE =\u003e s!(\"udp stream is not available\"),\n\t\tQUARK_ERROR_DATA_NOT_SUPPORTED =\u003e s!(\"data type is not supported\"),\n\t\tQUARK_ERROR_UNKNOWN =\u003e s!(\"unknown error\"),\n\t\tQUARK_ERROR_NO_DATA =\u003e s!(\"no data\"),\n\t\tQUARK_ERROR_INVALID_PACKET =\u003e s!(\"invalid packet\"),\n\t\tQUARK_ERROR_INVALID_USER =\u003e s!(\"invalid user\"),\n\t\t_ =\u003e s!(\"unknown error\"),\n\t}\n}\n\npub fn translate_error_to_code(error: Error) -\u003e quark_error_t {\n\tmatch error {\n\t\tError::Io(_) =\u003e QUARK_ERROR_SESSION_IO,\n\t\tError::Rejected(_) =\u003e QUARK_ERROR_SESSION_REJECTED,\n\t\tError::ConnectionDropped =\u003e QUARK_ERROR_SESSION_SERVER_STREAM_CLOSED,\n\t\tError::Deserialization(_) =\u003e QUARK_ERROR_SESSION_DESERIALIZATION,\n\t\tError::Serialization(_) =\u003e QUARK_ERROR_SESSION_SERIALIZATION,\n\t\tError::UnexpectedResponse =\u003e QUARK_ERROR_SESSION_PROTOCOL,\n\t\tError::TooManyAttributes =\u003e QUARK_ERROR_TOO_MANY_ATTRIBS,\n\t\tError::BadAddressFormat =\u003e QUARK_ERROR_BAD_ADDR_FORMAT,\n\t\tError::InvalidDNSName =\u003e QUARK_ERROR_INVALID_DNS_NAME,\n\t\tError::CertLoadFail =\u003e QUARK_ERROR_CERT_LOAD_FAILED,\n\t\tError::CertAddFailed =\u003e QUARK_ERROR_CERT_ADD_FAILED,\n\t\tError::UdpStreamNotAvailable =\u003e QUARK_ERROR_UDP_STREAM_NOT_AVAILABLE,\n\t\tError::ValueDataNotSupported =\u003e QUARK_ERROR_DATA_NOT_SUPPORTED,\n\t\tError::InvalidPacket =\u003e QUARK_ERROR_INVALID_PACKET,\n\t\tError::InvalidUser =\u003e QUARK_ERROR_INVALID_USER,\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","client-sdk","src","bindings","mod.rs"],"content":"#![allow(non_camel_case_types)]\n\nuse {\n\tcrate::{\n\t\tAttributeId,\n\t\tAttributeIndexError,\n\t\tAttributeType,\n\t\tEventClass,\n\t\tObjectId,\n\t\tPlayerId,\n\t\tTimestamp,\n\t\tValue,\n\t\tMAX_PAYLOAD_LEN,\n\t\tMAX_SEQUENCE_LENGTH,\n\t},\n\tarrayvec::ArrayString,\n\tonce_cell::sync::Lazy,\n\tstd::{ffi::c_char, mem::transmute, str::Utf8Error},\n\tthiserror::Error,\n\ttokio::runtime::{self, Runtime},\n};\n\nmod consts;\nmod error;\nmod receive;\nmod send;\nmod session;\nmod subscribe;\n\n/// The Tokio runtime used by the Quark client FFI interface.\nstatic RUNTIME: Lazy\u003cRuntime\u003e = Lazy::new(|| {\n\truntime::Builder::new_multi_thread()\n\t\t.enable_all()\n\t\t.build()\n\t\t.unwrap()\n});\n\npub type quark_object_id_t = ObjectId;\npub type quark_player_id_t = PlayerId;\npub type quark_event_class_t = EventClass;\npub type quark_attribute_id_t = AttributeId;\npub type quark_timestamp_t = Timestamp;\n\npub type quark_update_type_t = u8;\npub type quark_relevance_radius_t = f32;\n\npub const QUARK_UPDATE_TYPE_NONE: quark_update_type_t = 0;\npub const QUARK_UPDATE_TYPE_PLAYER: quark_update_type_t = 1;\npub const QUARK_UPDATE_TYPE_OBJECT: quark_update_type_t = 2;\npub const QUARK_UPDATE_TYPE_EVENT: quark_update_type_t = 3;\n\npub type quark_entity_id_type_t = u8;\npub const QUARK_ENTITY_ID_TYPE_PLAYER: quark_entity_id_type_t = 1;\npub const QUARK_ENTITY_ID_TYPE_OBJECT: quark_entity_id_type_t = 2;\n\n#[repr(C)]\n#[derive(Clone, Copy)]\npub union quark_entity_id_value_t {\n\tpub player: quark_player_id_t,\n\tpub object: quark_object_id_t,\n}\n\n#[repr(C)]\n#[derive(Clone, Copy)]\npub struct quark_entity_id_t {\n\tpub entity_type: quark_entity_id_type_t,\n\tpub entity_id: quark_entity_id_value_t,\n}\n\n#[repr(C)]\n#[derive(Clone, Copy)]\npub struct quark_event_payload_t {\n\tpub size: u16,\n\tpub data: [u8; MAX_PAYLOAD_LEN],\n}\n\n#[allow(non_camel_case_types)]\npub type quark_value_type_t = u8;\n\n#[repr(C)]\n#[allow(non_camel_case_types)]\n#[derive(Clone, Copy)]\npub union quark_value_payload_t {\n\tpub none: [u8; 0],\n\tpub bool_: u8,\n\tpub uint8: u8,\n\tpub uint16: u16,\n\tpub uint32: u32,\n\tpub uint64: u64,\n\tpub int8: i8,\n\tpub int16: i16,\n\tpub int32: i32,\n\tpub int64: i64,\n\tpub float32: f32,\n\tpub float64: f64,\n\tpub vec2: [f32; 2],\n\tpub vec3: [f32; 3],\n\tpub vec4: [f32; 4],\n\tpub vec2d: [f64; 2],\n\tpub vec3d: [f64; 3],\n\tpub vec4d: [f64; 4],\n\tpub string: [c_char; MAX_SEQUENCE_LENGTH],\n\tpub bytes: [u8; MAX_SEQUENCE_LENGTH],\n}\n\n/// This type exposes the raw C representation of a Value\n#[repr(C)]\n#[derive(Clone, Copy)]\npub struct quark_value_t {\n\tpub type_id: quark_value_type_t,\n\tpub payload: quark_value_payload_t,\n}\n\nimpl From\u003cValue\u003e for quark_value_t {\n\tfn from(value: Value) -\u003e Self {\n\t\tquark_value_t {\n\t\t\ttype_id: value.typeid() as quark_value_type_t,\n\t\t\tpayload: match value {\n\t\t\t\tValue::None =\u003e quark_value_payload_t { none: [] },\n\t\t\t\tValue::Bool(b) =\u003e quark_value_payload_t { bool_: b as u8 },\n\t\t\t\tValue::Uint8(u) =\u003e quark_value_payload_t { uint8: u },\n\t\t\t\tValue::Uint16(u) =\u003e quark_value_payload_t { uint16: u },\n\t\t\t\tValue::Uint32(u) =\u003e quark_value_payload_t { uint32: u },\n\t\t\t\tValue::Uint64(u) =\u003e quark_value_payload_t { uint64: u },\n\t\t\t\tValue::Int8(i) =\u003e quark_value_payload_t { int8: i },\n\t\t\t\tValue::Int16(i) =\u003e quark_value_payload_t { int16: i },\n\t\t\t\tValue::Int32(i) =\u003e quark_value_payload_t { int32: i },\n\t\t\t\tValue::Int64(i) =\u003e quark_value_payload_t { int64: i },\n\t\t\t\tValue::Float32(f) =\u003e quark_value_payload_t { float32: f },\n\t\t\t\tValue::Float64(f) =\u003e quark_value_payload_t { float64: f },\n\t\t\t\tValue::Vec2((x, y)) =\u003e quark_value_payload_t { vec2: [x, y] },\n\t\t\t\tValue::Vec3((x, y, z)) =\u003e quark_value_payload_t { vec3: [x, y, z] },\n\t\t\t\tValue::Vec4((x, y, z, w)) =\u003e {\n\t\t\t\t\tquark_value_payload_t { vec4: [x, y, z, w] }\n\t\t\t\t}\n\t\t\t\tValue::Vec2d((x, y)) =\u003e quark_value_payload_t { vec2d: [x, y] },\n\t\t\t\tValue::Vec3d((x, y, z)) =\u003e quark_value_payload_t { vec3d: [x, y, z] },\n\t\t\t\tValue::Vec4d((x, y, z, w)) =\u003e quark_value_payload_t {\n\t\t\t\t\tvec4d: [x, y, z, w],\n\t\t\t\t},\n\t\t\t\tValue::String(s) =\u003e {\n\t\t\t\t\tlet s = s.as_bytes();\n\t\t\t\t\tlet mut buffer = [0u8; MAX_SEQUENCE_LENGTH];\n\t\t\t\t\tbuffer[..s.len().min(MAX_SEQUENCE_LENGTH)].copy_from_slice(s);\n\t\t\t\t\tquark_value_payload_t {\n\t\t\t\t\t\tstring: unsafe { transmute::\u003c[u8; 32], [i8; 32]\u003e(buffer) },\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tValue::Bytes(b) =\u003e {\n\t\t\t\t\tlet mut buffer = [0u8; MAX_SEQUENCE_LENGTH];\n\t\t\t\t\tbuffer[..b.len().min(MAX_SEQUENCE_LENGTH)]\n\t\t\t\t\t\t.copy_from_slice(\u0026b[..b.len().min(MAX_SEQUENCE_LENGTH)]);\n\t\t\t\t\tquark_value_payload_t { bytes: buffer }\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t}\n}\n\n#[derive(Debug, Error)]\npub enum ValueConversionError {\n\t#[error(\"invalid type: {0:?}\")]\n\tInvalidType(#[from] AttributeIndexError),\n\n\t#[error(\"invalid value: {0:?}\")]\n\tInvlalidValue(#[from] Utf8Error),\n\n\t#[error(\"payload too large\")]\n\tPayloadTooLarge,\n\n\t#[error(\"invalid recipient type\")]\n\tInvalidRecipientType,\n}\n\nimpl TryFrom\u003cquark_value_t\u003e for Value {\n\ttype Error = ValueConversionError;\n\n\tfn try_from(value: quark_value_t) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tunsafe {\n\t\t\tOk(match AttributeType::try_from(value.type_id)? {\n\t\t\t\tAttributeType::None =\u003e Value::None,\n\t\t\t\tAttributeType::Bool =\u003e Value::Bool(value.payload.bool_ != 0),\n\t\t\t\tAttributeType::Uint8 =\u003e Value::Uint8(value.payload.uint8),\n\t\t\t\tAttributeType::Uint16 =\u003e Value::Uint16(value.payload.uint16),\n\t\t\t\tAttributeType::Uint32 =\u003e Value::Uint32(value.payload.uint32),\n\t\t\t\tAttributeType::Uint64 =\u003e Value::Uint64(value.payload.uint64),\n\t\t\t\tAttributeType::Int8 =\u003e Value::Int8(value.payload.int8),\n\t\t\t\tAttributeType::Int16 =\u003e Value::Int16(value.payload.int16),\n\t\t\t\tAttributeType::Int32 =\u003e Value::Int32(value.payload.int32),\n\t\t\t\tAttributeType::Int64 =\u003e Value::Int64(value.payload.int64),\n\t\t\t\tAttributeType::Float32 =\u003e Value::Float32(value.payload.float32),\n\t\t\t\tAttributeType::Float64 =\u003e Value::Float64(value.payload.float64),\n\t\t\t\tAttributeType::Vec2 =\u003e {\n\t\t\t\t\tValue::Vec2((value.payload.vec2[0], value.payload.vec2[1]))\n\t\t\t\t}\n\t\t\t\tAttributeType::Vec3 =\u003e Value::Vec3((\n\t\t\t\t\tvalue.payload.vec3[0],\n\t\t\t\t\tvalue.payload.vec3[1],\n\t\t\t\t\tvalue.payload.vec3[2],\n\t\t\t\t)),\n\t\t\t\tAttributeType::Vec4 =\u003e Value::Vec4((\n\t\t\t\t\tvalue.payload.vec4[0],\n\t\t\t\t\tvalue.payload.vec4[1],\n\t\t\t\t\tvalue.payload.vec4[2],\n\t\t\t\t\tvalue.payload.vec4[3],\n\t\t\t\t)),\n\t\t\t\tAttributeType::Vec2d =\u003e {\n\t\t\t\t\tValue::Vec2d((value.payload.vec2d[0], value.payload.vec2d[1]))\n\t\t\t\t}\n\t\t\t\tAttributeType::Vec3d =\u003e Value::Vec3d((\n\t\t\t\t\tvalue.payload.vec3d[0],\n\t\t\t\t\tvalue.payload.vec3d[1],\n\t\t\t\t\tvalue.payload.vec3d[2],\n\t\t\t\t)),\n\t\t\t\tAttributeType::Vec4d =\u003e Value::Vec4d((\n\t\t\t\t\tvalue.payload.vec4d[0],\n\t\t\t\t\tvalue.payload.vec4d[1],\n\t\t\t\t\tvalue.payload.vec4d[2],\n\t\t\t\t\tvalue.payload.vec4d[3],\n\t\t\t\t)),\n\t\t\t\tAttributeType::String =\u003e {\n\t\t\t\t\tValue::String(ArrayString::from_byte_string(\u0026transmute::\u003c\n\t\t\t\t\t\t[i8; 32],\n\t\t\t\t\t\t[u8; 32],\n\t\t\t\t\t\u003e(value.payload.string))?)\n\t\t\t\t}\n\t\t\t\tAttributeType::Bytes =\u003e Value::Bytes(value.payload.bytes.into()),\n\t\t\t})\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","client-sdk","src","bindings","receive.rs"],"content":"use {\n\tsuper::{error::*, session::*, *},\n\tcrate::{EntityId, Session, Timestamp},\n};\n\n/// Holds information about updates to an attribute of a player or an object.\n#[repr(C)]\n#[derive(Clone, Copy)]\npub struct quark_remote_entity_update_t {\n\t/// Entity ID of the player or object that was updated.\n\tpub entity: quark_entity_id_t,\n\n\t/// Timestamp of the change as milliseconds since UNIX epoch.\n\t///\n\t/// This timestamp is the time when the change happened on the\n\t/// originator's side, not the server storage time. This value\n\t/// can be used for dead reckoning and other time-sensitive\n\t/// interpolation operations.\n\tpub timestamp: quark_timestamp_t,\n\n\t/// The ID of the attribute that was updated.\n\tpub attribute_id: quark_attribute_id_t,\n\n\t/// New value of the attribute.\n\tpub value: quark_value_t,\n}\n\n/// Represents an event that happened remotely that was\n/// delivered to the current session.\n#[repr(C)]\n#[derive(Clone, Copy)]\npub struct quark_remote_event_t {\n\t/// The class of the event.\n\tclass_id: quark_event_class_t,\n\n\t/// The timestamp of the event in milliseconds since UNIX epoch.\n\t///\n\t/// This is the timestamp of the origination of the event on the\n\t/// emitter machine.\n\ttimestamp: quark_timestamp_t,\n\n\t/// The sender of the event.\n\t///\n\t/// Can be an object or a player.\n\tsender: quark_entity_id_t,\n\n\t/// The payload of the event.\n\tpayload: quark_event_payload_t,\n}\n\n#[repr(C)]\n#[derive(Clone, Copy)]\npub union quark_remote_update_value_t {\n\tpub entity: quark_remote_entity_update_t,\n\tpub event: quark_remote_event_t,\n}\n\n/// Represents a single update that was received from the server.\n#[repr(C)]\n#[derive(Clone, Copy)]\npub struct quark_remote_update_t {\n\t/// The type of the update.\n\tpub update_type: quark_update_type_t,\n\n\t/// The update value.\n\tpub value: quark_remote_update_value_t,\n}\n\n/// Polls a connected session for the next available update.\n///\n/// This is a non-blocking call. If there are no updates available\n/// the function will return `QUARK_ERROR_NO_DATA`.\n#[no_mangle]\npub unsafe extern \"C\" fn quark_session_try_receive(\n\tsession: quark_session_t,\n\toutput: *mut quark_remote_update_t,\n) -\u003e quark_error_t {\n\tif session.is_null() || output.is_null() {\n\t\treturn QUARK_ERROR_INVALID_ARGUMENT;\n\t}\n\n\tlet output = \u0026mut *output;\n\tlet session = \u0026mut *(session as *mut Session).as_mut().unwrap();\n\n\tlet Some(update) = session.streams().try_receive() else {\n\t\toutput.update_type = QUARK_UPDATE_TYPE_NONE;\n\t\treturn QUARK_ERROR_NO_DATA;\n\t};\n\n\t// we have an update, now we need to populate the output C struct\n\t// that describes the update.\n\n\t*output = match update {\n\t\tcrate::RemoteUpdate::Player(player_id, attrib_id, value, timestamp) =\u003e {\n\t\t\tquark_remote_update_t {\n\t\t\t\tupdate_type: QUARK_UPDATE_TYPE_PLAYER,\n\t\t\t\tvalue: quark_remote_update_value_t {\n\t\t\t\t\tentity: create_player_update(player_id, attrib_id, value, timestamp),\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\tcrate::RemoteUpdate::Object(object_id, attrib_id, value, timestamp) =\u003e {\n\t\t\tquark_remote_update_t {\n\t\t\t\tupdate_type: QUARK_UPDATE_TYPE_OBJECT,\n\t\t\t\tvalue: quark_remote_update_value_t {\n\t\t\t\t\tentity: create_object_update(object_id, attrib_id, value, timestamp),\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\tcrate::RemoteUpdate::Event(class, payload, sender, timestamp) =\u003e {\n\t\t\tquark_remote_update_t {\n\t\t\t\tupdate_type: QUARK_UPDATE_TYPE_EVENT,\n\t\t\t\tvalue: quark_remote_update_value_t {\n\t\t\t\t\tevent: create_event_update(class, payload, sender, timestamp),\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t};\n\n\tQUARK_ERROR_SUCCESS\n}\n\nfn create_player_update(\n\tplayer_id: quark_player_id_t,\n\tattrib_id: quark_attribute_id_t,\n\tvalue: Value,\n\ttimestamp: quark_timestamp_t,\n) -\u003e quark_remote_entity_update_t {\n\tquark_remote_entity_update_t {\n\t\tentity: quark_entity_id_t {\n\t\t\tentity_type: QUARK_ENTITY_ID_TYPE_PLAYER,\n\t\t\tentity_id: quark_entity_id_value_t { player: player_id },\n\t\t},\n\t\ttimestamp,\n\t\tattribute_id: attrib_id,\n\t\tvalue: value.into(),\n\t}\n}\n\nfn create_object_update(\n\tobject_id: quark_object_id_t,\n\tattrib_id: quark_attribute_id_t,\n\tvalue: Value,\n\ttimestamp: quark_timestamp_t,\n) -\u003e quark_remote_entity_update_t {\n\tquark_remote_entity_update_t {\n\t\tentity: quark_entity_id_t {\n\t\t\tentity_type: QUARK_ENTITY_ID_TYPE_OBJECT,\n\t\t\tentity_id: quark_entity_id_value_t { object: object_id },\n\t\t},\n\t\ttimestamp,\n\t\tattribute_id: attrib_id,\n\t\tvalue: value.into(),\n\t}\n}\n\nfn create_event_update(\n\tclass: quark_event_class_t,\n\tpayload: Box\u003c[u8]\u003e,\n\tsender: EntityId,\n\ttimestamp: Timestamp,\n) -\u003e quark_remote_event_t {\n\tquark_remote_event_t {\n\t\tclass_id: class,\n\t\ttimestamp,\n\t\tsender: match sender {\n\t\t\tEntityId::Player(id) =\u003e quark_entity_id_t {\n\t\t\t\tentity_type: QUARK_ENTITY_ID_TYPE_PLAYER,\n\t\t\t\tentity_id: quark_entity_id_value_t { player: id },\n\t\t\t},\n\t\t\tEntityId::Object(id) =\u003e quark_entity_id_t {\n\t\t\t\tentity_type: QUARK_ENTITY_ID_TYPE_OBJECT,\n\t\t\t\tentity_id: quark_entity_id_value_t { object: id },\n\t\t\t},\n\t\t},\n\t\tpayload: {\n\t\t\tlet mut event_payload = quark_event_payload_t {\n\t\t\t\tsize: payload.len() as u16,\n\t\t\t\tdata: [0; MAX_PAYLOAD_LEN],\n\t\t\t};\n\t\t\tevent_payload.data[..payload.len()].copy_from_slice(\u0026payload);\n\t\t\tevent_payload\n\t\t},\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","client-sdk","src","bindings","send.rs"],"content":"#![allow(non_camel_case_types)]\n\nuse {\n\tsuper::{\n\t\terror::*,\n\t\tsession::{\n\t\t\tquark_qos_t,\n\t\t\tquark_session_t,\n\t\t\tQUARK_QOS_RELIABLE,\n\t\t\tQUARK_QOS_UNRELIABLE,\n\t\t},\n\t\t*,\n\t},\n\tcrate::{EntityId, LocalUpdate, QoS, Recipient, Session},\n\tstd::time::Duration,\n};\n\n/// Describes an update to a property to the player controlled by the local\n/// session.\n#[repr(C)]\n#[derive(Clone, Copy)]\npub struct quark_local_player_update_t {\n\t/// The ID of the attribute that was updated.\n\tpub attribute_id: quark_attribute_id_t,\n\n\t/// New value of the attribute.\n\tpub value: quark_value_t,\n}\n\n/// Describes an update to a property of an object.\n#[repr(C)]\n#[derive(Clone, Copy)]\npub struct quark_local_object_update_t {\n\t/// The ID of the object that was updated.\n\tpub object_id: quark_object_id_t,\n\n\t/// The ID of the attribute that was updated.\n\tpub attribute_id: quark_attribute_id_t,\n\n\t/// New value of the attribute.\n\tpub value: quark_value_t,\n}\n\npub type quark_recipient_type_t = u8;\npub const QUARK_EVENT_RECIPIENT_TYPE_PLAYER: quark_recipient_type_t = 1;\npub const QUARK_EVENT_RECIPIENT_TYPE_OBJECT: quark_recipient_type_t = 2;\npub const QUARK_EVENT_RECIPIENT_TYPE_RADIUS: quark_recipient_type_t = 3;\n\n#[repr(C)]\n#[derive(Clone, Copy)]\npub union quark_recipient_value_t {\n\tpub player: quark_player_id_t,\n\tpub object: quark_object_id_t,\n\tpub radius: quark_relevance_radius_t,\n}\n\n#[repr(C)]\n#[derive(Clone, Copy)]\npub struct quark_recipient_t {\n\tpub recipient_type: quark_recipient_type_t,\n\tpub recipient: quark_recipient_value_t,\n}\n\n#[repr(C)]\n#[derive(Clone, Copy)]\npub struct quark_local_event_t {\n\t/// The class of the event.\n\tpub class_id: quark_event_class_t,\n\n\t/// The recipient of the event.\n\tpub recipient: quark_recipient_t,\n\n\t/// The payload of the event.\n\tpub payload: quark_event_payload_t,\n}\n\n#[repr(C)]\n#[derive(Clone, Copy)]\npub union quark_local_update_value_t {\n\t/// Update for a player.\n\tpub player: quark_local_player_update_t,\n\tpub object: quark_local_object_update_t,\n\tpub event: quark_local_event_t,\n}\n\n#[repr(C)]\n#[derive(Clone, Copy)]\npub struct quark_local_update_t {\n\t/// The type of the update.\n\tpub update_type: u8,\n\n\t/// The value of the update.\n\tpub value: quark_local_update_value_t,\n}\n\n/// Configures the interval between outbound ticks for the session\n/// for the given QoS level. The tick rate is in milliseconds.\n#[no_mangle]\npub unsafe extern \"C\" fn quark_set_outbound_tick_interval(\n\tsession: quark_session_t,\n\ttick_rate_ms: u32,\n\tqos: quark_qos_t,\n) -\u003e quark_error_t {\n\tif session.is_null() {\n\t\treturn QUARK_ERROR_INVALID_ARGUMENT;\n\t}\n\n\tif tick_rate_ms \u003c 30 {\n\t\treturn QUARK_ERROR_INVALID_ARGUMENT;\n\t}\n\n\tlet session = (session as *const Session).cast_mut().as_mut().unwrap();\n\tlet interval = Duration::from_millis(tick_rate_ms as u64);\n\tlet qos = match qos {\n\t\tQUARK_QOS_UNRELIABLE =\u003e QoS::Unreliable,\n\t\tQUARK_QOS_RELIABLE =\u003e QoS::Reliable,\n\t\t_ =\u003e return QUARK_ERROR_INVALID_ARGUMENT,\n\t};\n\n\tif let Err(e) = session.streams().set_outbound_tick_interval(interval, qos) {\n\t\ttranslate_error_to_code(e)\n\t} else {\n\t\tQUARK_ERROR_SUCCESS\n\t}\n}\n\n/// Pushes a new update to the server.\n///\n/// This function will not send the value immediately instead it will schedule\n/// it for sending in the next network tick. The function will return\n/// immediately.\n///\n/// The outbound tick rate can be controlled by the\n/// `quark_session_set_tick_rate` function.\n///\n/// The `qos` parameter controls the quality of service of the update. Reliable\n/// updates go over TCP and UNRELIABLE updates go over UDP.\n#[no_mangle]\npub unsafe extern \"C\" fn quark_session_send(\n\tsession: quark_session_t,\n\tqos: quark_qos_t,\n\tupdate: *const quark_local_update_t,\n) -\u003e quark_error_t {\n\tif update.is_null() || session.is_null() {\n\t\treturn QUARK_ERROR_INVALID_ARGUMENT;\n\t}\n\n\tlet session = \u0026mut *(session as *mut Session);\n\tlet update = \u0026*update;\n\n\tlet Ok(update) = (match update.update_type {\n\t\tu if u == QUARK_UPDATE_TYPE_PLAYER =\u003e {\n\t\t\tcreate_player_update(\u0026update.value.player)\n\t\t}\n\t\tu if u == QUARK_UPDATE_TYPE_OBJECT =\u003e {\n\t\t\tcreate_object_update(\u0026update.value.object)\n\t\t}\n\t\tu if u == QUARK_UPDATE_TYPE_EVENT =\u003e {\n\t\t\tcreate_event_update(\u0026update.value.event)\n\t\t}\n\t\t_ =\u003e return QUARK_ERROR_INVALID_ARGUMENT,\n\t}) else {\n\t\treturn QUARK_ERROR_INVALID_ARGUMENT;\n\t};\n\n\tlet qos = match qos {\n\t\tQUARK_QOS_RELIABLE =\u003e QoS::Reliable,\n\t\tQUARK_QOS_UNRELIABLE =\u003e QoS::Unreliable,\n\t\t_ =\u003e return QUARK_ERROR_INVALID_ARGUMENT,\n\t};\n\n\tif let Err(e) = session.streams().send(update, qos) {\n\t\ttranslate_error_to_code(e)\n\t} else {\n\t\tQUARK_ERROR_SUCCESS\n\t}\n}\n\nunsafe fn create_player_update(\n\tupdate: \u0026quark_local_player_update_t,\n) -\u003e Result\u003cLocalUpdate, ValueConversionError\u003e {\n\tOk(LocalUpdate::Player(\n\t\tupdate.attribute_id,\n\t\tupdate.value.try_into()?,\n\t))\n}\n\nunsafe fn create_object_update(\n\tupdate: \u0026quark_local_object_update_t,\n) -\u003e Result\u003cLocalUpdate, ValueConversionError\u003e {\n\tOk(LocalUpdate::Object(\n\t\tupdate.object_id,\n\t\tupdate.attribute_id,\n\t\tupdate.value.try_into()?,\n\t))\n}\n\nunsafe fn create_event_update(\n\tupdate: \u0026quark_local_event_t,\n) -\u003e Result\u003cLocalUpdate, ValueConversionError\u003e {\n\tif update.payload.size as usize \u003e update.payload.data.len() {\n\t\treturn Err(ValueConversionError::PayloadTooLarge);\n\t}\n\n\tlet payload = update.payload.data[..update.payload.size as usize]\n\t\t.to_vec()\n\t\t.into_boxed_slice();\n\n\tlet recipient = match update.recipient.recipient_type {\n\t\tr if r == QUARK_EVENT_RECIPIENT_TYPE_PLAYER =\u003e {\n\t\t\tRecipient::Entity(EntityId::Player(update.recipient.recipient.player))\n\t\t}\n\t\tr if r == QUARK_EVENT_RECIPIENT_TYPE_OBJECT =\u003e {\n\t\t\tRecipient::Entity(EntityId::Object(update.recipient.recipient.object))\n\t\t}\n\t\tr if r == QUARK_EVENT_RECIPIENT_TYPE_RADIUS =\u003e {\n\t\t\tRecipient::Radius(update.recipient.recipient.radius.into())\n\t\t}\n\t\t_ =\u003e return Err(ValueConversionError::InvalidRecipientType),\n\t};\n\n\tOk(LocalUpdate::Event(update.class_id, payload, recipient))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","client-sdk","src","bindings","session.rs"],"content":"#![allow(non_camel_case_types)]\n\nuse {\n\tsuper::{error::*, quark_object_id_t, RUNTIME},\n\tcrate::{session::derive_shared_id, Session},\n\tstd::{ffi::*, slice},\n};\n\npub type quark_session_id_t = u32;\npub type quark_session_t = *const c_void;\n\npub type quark_qos_t = u32;\npub const QUARK_QOS_RELIABLE: quark_qos_t = 1;\npub const QUARK_QOS_UNRELIABLE: quark_qos_t = 2;\n\n/// Starts a new session with the server. This is a blocking function that\n/// returns when the session is established or an error occurs.\n///\n/// The server address is a string in the form of \"host:port\" or \"ip:port\" (port\n/// is optional). The authentication buffer is a byte blob that is sent to the\n/// server as part of the authentication process. The server will either accept\n/// and assign a player id or reject the connection.\n#[no_mangle]\npub unsafe extern \"C\" fn quark_session_start(\n\tserver_addr: *const c_char,\n\tauth_buffer: *const u8,\n\tauth_len: u8,\n\toutput: *mut quark_session_t,\n) -\u003e quark_error_t {\n\tif server_addr.is_null() || output.is_null() {\n\t\treturn QUARK_ERROR_INVALID_ARGUMENT;\n\t}\n\n\tif auth_len != 0 \u0026\u0026 auth_buffer.is_null() {\n\t\treturn QUARK_ERROR_INVALID_ARGUMENT;\n\t}\n\n\tlet Ok(server_addr) = CStr::from_ptr(server_addr).to_str() else {\n\t\treturn QUARK_ERROR_INVALID_ARGUMENT;\n\t};\n\n\tlet auth = if auth_buffer.is_null() \u0026\u0026 auth_len == 0 {\n\t\t\u0026[]\n\t} else {\n\t\tslice::from_raw_parts(auth_buffer, auth_len as usize)\n\t};\n\n\tlet session =\n\t\tRUNTIME.block_on(async { Session::start(server_addr, auth).await });\n\n\tmatch session {\n\t\tOk(session) =\u003e {\n\t\t\t*output = Box::into_raw(Box::new(session)) as *const _ as quark_session_t;\n\t\t\tQUARK_ERROR_SUCCESS\n\t\t}\n\t\tErr(error) =\u003e translate_error_to_code(error),\n\t}\n}\n\n/// Resumes the connection with the server using the resume token (can be\n/// obtained during the session runtime)\n///\n/// The server address is a string in the form of \"ip:port\".\n/// The resume token buffer is a byte blob that is received from the server\n/// as part of the authentication process.\n#[no_mangle]\npub unsafe extern \"C\" fn quark_session_resume(\n\tserver_addr: *const c_char,\n\tresume_token_buf: *const u8,\n\tresume_token_len: usize,\n\toutput: *mut quark_session_t,\n) -\u003e quark_error_t {\n\tif server_addr.is_null() || output.is_null() {\n\t\treturn QUARK_ERROR_INVALID_ARGUMENT;\n\t}\n\n\tif resume_token_len != 0 \u0026\u0026 resume_token_buf.is_null() {\n\t\treturn QUARK_ERROR_INVALID_ARGUMENT;\n\t}\n\n\tlet Ok(server_addr) = CStr::from_ptr(server_addr).to_str() else {\n\t\treturn QUARK_ERROR_INVALID_ARGUMENT;\n\t};\n\n\tlet resume_token = slice::from_raw_parts(resume_token_buf, resume_token_len);\n\n\tlet session = RUNTIME\n\t\t.block_on(async { Session::resume(server_addr, resume_token).await });\n\n\tmatch session {\n\t\tOk(session) =\u003e {\n\t\t\t*output = Box::into_raw(Box::new(session)) as *const _ as quark_session_t;\n\t\t\tQUARK_ERROR_SUCCESS\n\t\t}\n\t\tErr(error) =\u003e translate_error_to_code(error),\n\t}\n}\n\n/// Returns the session id which is also the public id of the player.\n#[no_mangle]\npub unsafe extern \"C\" fn quark_session_get_assigned_id(\n\tsession: quark_session_t,\n\toutput: *mut quark_session_id_t,\n) -\u003e quark_error_t {\n\tif session.is_null() || output.is_null() {\n\t\treturn QUARK_ERROR_INVALID_ARGUMENT;\n\t}\n\n\tlet session = \u0026*(session as *const Session);\n\t*output = session.id();\n\n\tQUARK_ERROR_SUCCESS\n}\n\n/// Returns the resume token that can be used to resume a session.\n///\n/// The resume token is allocated inside the SDK memeory and lives as long as\n/// the session object. The user is not responsible for freeing the memory,\n/// except for destroying the session object.\n#[no_mangle]\npub unsafe extern \"C\" fn quark_session_get_resume_token(\n\tsession: quark_session_t,\n\toutput: *mut *const u8,\n\toutput_len: *mut usize,\n) -\u003e quark_error_t {\n\tif session.is_null() || output.is_null() {\n\t\treturn QUARK_ERROR_INVALID_ARGUMENT;\n\t}\n\n\tlet session = \u0026*(session as *const Session);\n\tlet resume_token = session.resume_token();\n\n\t*output = resume_token.as_ptr();\n\t*output_len = resume_token.len();\n\n\tQUARK_ERROR_SUCCESS\n}\n\n/// Disconnects the session from the server and frees the session object.\n#[no_mangle]\npub unsafe extern \"C\" fn quark_session_destroy(\n\tsession: *mut quark_session_t,\n) -\u003e quark_error_t {\n\tif session.is_null() {\n\t\treturn QUARK_ERROR_INVALID_ARGUMENT;\n\t}\n\n\t// retake ownership and dispose in Drop\n\tlet _ = Box::from_raw(*session as *mut Session);\n\n\t*session = std::ptr::null_mut();\n\n\tQUARK_ERROR_SUCCESS\n}\n\n/// Given a local object id, return an object id derived from the current\n/// player id. Only this kind of IDs can be assigned to objects spawned by\n/// this player. The user is responsible for ensuring that the local object id\n/// id is unique for this player.\n#[no_mangle]\npub unsafe extern \"C\" fn quark_session_derive_object_id(\n\tsession: quark_session_t,\n\tlocal_id: u32,\n\toutput: *mut quark_object_id_t,\n) -\u003e quark_error_t {\n\tif session.is_null() || output.is_null() {\n\t\treturn QUARK_ERROR_INVALID_ARGUMENT;\n\t}\n\n\tlet session = \u0026*(session as *const Session);\n\t*output = session.derive_global_id(local_id);\n\n\tQUARK_ERROR_SUCCESS\n}\n\n/// Given a local object id, return an object id in the shared objects\n/// namespace.\n#[no_mangle]\npub unsafe extern \"C\" fn quark_derive_shared_object_id(\n\tlocal_id: u32,\n\toutput: *mut quark_object_id_t,\n) -\u003e quark_error_t {\n\tif output.is_null() || local_id == 0 {\n\t\treturn QUARK_ERROR_INVALID_ARGUMENT;\n\t}\n\n\t*output = derive_shared_id(local_id);\n\n\tQUARK_ERROR_SUCCESS\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","client-sdk","src","bindings","subscribe.rs"],"content":"#![allow(non_camel_case_types)]\n\nuse {\n\tsuper::{error::*, session::*, *},\n\tcrate::{EventsFilter, QoS, Query, Session, SubscriptionId},\n\tstd::{ffi::c_char, time::Duration},\n};\n\npub type quark_duration_t = u64;\npub type quark_subscription_priority_t = u8;\npub type quark_subscription_id = SubscriptionId;\n\npub type quark_event_filter_mode_t = u8;\npub const QUARK_EVENT_FILTER_MODE_BLACKLIST: quark_event_filter_mode_t = 1;\npub const QUARK_EVENT_FILTER_MODE_WHITELIST: quark_event_filter_mode_t = 2;\n\n#[repr(C)]\n#[derive(Clone, Copy)]\npub struct quark_events_filter_t {\n\t/// The number of classes.\n\tpub count: u32,\n\n\t/// The mode of the filter.\n\t/// It can be either\n\t/// - `QUARK_EVENT_FILTER_MODE_BLACKLIST` or\n\t/// - `QUARK_EVENT_FILTER_MODE_WHITELIST`.\n\tpub mode: quark_event_filter_mode_t,\n\n\t/// Pointer to an array of length `count` of event classes.\n\tpub classes: *const quark_event_class_t,\n}\n\n#[repr(C)]\n#[derive(Clone, Copy)]\npub struct quark_tags_t {\n\t/// The number of tags.\n\tpub count: u32,\n\n\t/// Array of poiners to strings containing the tags of length `count`.\n\tpub tags: *const *const c_char,\n}\n\n#[repr(C)]\n#[derive(Clone, Copy)]\npub struct quark_subscription_query_t {\n\t/// The relevance radius of the query.\n\tpub radius: quark_relevance_radius_t,\n\n\t/// The filter tags of the query, empty tags means no filter.\n\tpub tags: quark_tags_t,\n\n\t/// The interval between tick of the subscription.\n\tpub interval: quark_duration_t,\n\n\t/// The priority of the subscription.\n\tpub priority: quark_subscription_priority_t,\n\n\t/// The events filter of the subscription.\n\tpub events: quark_events_filter_t,\n\n\t/// The number of events this subscription can backlog between ticks.\n\tpub backlog: u32,\n}\n\n/// Creates a new subscription.\n///\n/// The subscription is created with the given query and it instructs the server\n/// to start sending updates with the given specification to the client over the\n/// chosen channel. The channel can be either reliable (tcp) or unreliable\n/// (udp).\n///\n/// On success the subscription id is returned in the `subscription_id`\n/// parameter.\n#[no_mangle]\npub unsafe extern \"C\" fn quark_session_subscribe(\n\tsession: quark_session_t,\n\tqos: quark_qos_t,\n\tquery: *const quark_subscription_query_t,\n\tsubscription_id: *mut quark_subscription_id,\n) -\u003e quark_error_t {\n\tif session.is_null() || query.is_null() {\n\t\treturn QUARK_ERROR_INVALID_ARGUMENT;\n\t}\n\n\tlet mut query = *query;\n\tlet session = \u0026mut *(session as *mut Session);\n\tlet qos = match qos {\n\t\tq if q == QUARK_QOS_RELIABLE =\u003e QoS::Reliable,\n\t\tq if q == QUARK_QOS_UNRELIABLE =\u003e QoS::Unreliable,\n\t\t_ =\u003e return QUARK_ERROR_INVALID_ARGUMENT,\n\t};\n\n\tif query.backlog == 0 {\n\t\tquery.backlog = 64; // apply default backlog\n\t}\n\n\tlet query = Query {\n\t\tradius: query.radius.into(),\n\t\ttags: std::slice::from_raw_parts(\n\t\t\tquery.tags.tags,\n\t\t\tquery.tags.count as usize,\n\t\t)\n\t\t.iter()\n\t\t.map(|\u0026tag| std::ffi::CStr::from_ptr(tag).to_string_lossy().into_owned())\n\t\t.collect(),\n\t\tinterval: Duration::from_millis(query.interval),\n\t\tpriority: query.priority.into(),\n\t\tevents: {\n\t\t\tlet classes = std::slice::from_raw_parts(\n\t\t\t\tquery.events.classes,\n\t\t\t\tquery.events.count as usize,\n\t\t\t)\n\t\t\t.iter()\n\t\t\t.copied()\n\t\t\t.collect();\n\n\t\t\tmatch query.events.mode {\n\t\t\t\tm if m == QUARK_EVENT_FILTER_MODE_BLACKLIST =\u003e {\n\t\t\t\t\tEventsFilter::Blacklist(classes)\n\t\t\t\t}\n\t\t\t\tm if m == QUARK_EVENT_FILTER_MODE_WHITELIST =\u003e {\n\t\t\t\t\tEventsFilter::Whitelist(classes)\n\t\t\t\t}\n\t\t\t\t_ =\u003e return QUARK_ERROR_INVALID_ARGUMENT,\n\t\t\t}\n\t\t},\n\t\tbacklog: query.backlog as usize,\n\t};\n\n\tmatch session.streams().subscribe(query, qos) {\n\t\tOk(id) =\u003e {\n\t\t\t*subscription_id = id;\n\t\t\tQUARK_ERROR_SUCCESS\n\t\t}\n\t\tErr(e) =\u003e crate::bindings::error::translate_error_to_code(e),\n\t}\n}\n\n/// Unsubscribes from a subscription.\n///\n/// Instructs the server to stop sending updates for a previously subscribed\n/// query.\n#[no_mangle]\npub unsafe extern \"C\" fn quark_session_unsubscribe(\n\tsession: quark_session_t,\n\tsubscription_id: quark_subscription_id,\n) -\u003e quark_error_t {\n\tif session.is_null() {\n\t\treturn QUARK_ERROR_INVALID_ARGUMENT;\n\t}\n\tlet session = \u0026mut *(session as *mut Session);\n\tif let Err(e) = session.streams().unsubscribe(subscription_id) {\n\t\ttranslate_error_to_code(e)\n\t} else {\n\t\tQUARK_ERROR_SUCCESS\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","client-sdk","src","error.rs"],"content":"use {crate::protocol, thiserror::Error};\n\n#[derive(Error, Debug)]\npub enum Error {\n\t#[error(\"Connection with server dropped\")]\n\tConnectionDropped,\n\n\t#[error(\"Rejected by server: {0:?}\")]\n\tRejected(protocol::SessionErrorCode),\n\n\t#[error(\"Unexpected response from server\")]\n\tUnexpectedResponse,\n\n\t#[error(\"Failed to serialize packet\")]\n\tSerialization(#[from] capnp::Error),\n\n\t#[error(\"Failed to deserialize packet\")]\n\tDeserialization(#[from] capnp::NotInSchema),\n\n\t#[error(\"IO Error: {0}\")]\n\tIo(#[from] std::io::Error),\n\n\t#[error(\"too many attributes\")]\n\tTooManyAttributes,\n\n\t#[error(\"Bad address format\")]\n\tBadAddressFormat,\n\n\t#[error(\"Invalid DNS name\")]\n\tInvalidDNSName,\n\n\t#[error(\"Root Certificate load failed\")]\n\tCertLoadFail,\n\n\t#[error(\"Cannot add certificate to root store\")]\n\tCertAddFailed,\n\n\t#[error(\"UDP channel is not available\")]\n\tUdpStreamNotAvailable,\n\n\t#[error(\"Value data type is not supported\")]\n\tValueDataNotSupported,\n\n\t#[error(\"Invalid packet\")]\n\tInvalidPacket,\n\n\t#[error(\"Invalid user\")]\n\tInvalidUser,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","client-sdk","src","event.rs"],"content":"use {\n\tcrate::{EntityId, Relevance},\n\tarrayvec::ArrayVec,\n\tserde::{Deserialize, Serialize},\n};\n\npub const MAX_PAYLOAD_LEN: usize = 256; // bytes\n\npub type EventClass = u16;\npub type EventPayload = ArrayVec\u003cu8, MAX_PAYLOAD_LEN\u003e;\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Deserialize, Serialize)]\n#[repr(C)]\npub enum Recipient {\n\tRadius(Relevance),\n\tEntity(EntityId),\n}\n\nimpl Default for Recipient {\n\tfn default() -\u003e Self {\n\t\tRecipient::Radius(Relevance::default())\n\t}\n}\n\n/// Represents an event that is raised by the player.\n#[derive(Debug, Clone, PartialEq, Eq, Deserialize, Serialize)]\n#[repr(C)]\npub struct OutboundEvent {\n\t/// Message type.\n\t/// Payload is parsed based on this.\n\tpub class: EventClass,\n\n\t/// The payload of the message.\n\t/// Should be parsed based on the `id` field.\n\tpub payload: EventPayload,\n\n\t/// Recipient of the message.\n\tpub recipient: Recipient,\n}\n\nimpl OutboundEvent {\n\tpub const MAX_PAYLOAD_SIZE: usize = MAX_PAYLOAD_LEN;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","client-sdk","src","interest.rs"],"content":"use {\n\tschemars::JsonSchema,\n\tserde::{Deserialize, Deserializer, Serialize, Serializer},\n\tstd::{\n\t\tfmt::{Display, Formatter},\n\t\tops::{Add, Deref, Sub},\n\t},\n};\n\n/// A value between 0 and 100 that represents the percentage of the interest\n/// radius in relevant entities. When a player sends a tick update, the radius\n/// of returned entities is defined by this value.\n#[derive(Debug, Clone, Copy, PartialEq, JsonSchema)]\npub struct Relevance(f32);\n\nimpl Serialize for Relevance {\n\tfn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n\twhere\n\t\tS: Serializer,\n\t{\n\t\tserializer.serialize_f32(self.0)\n\t}\n}\n\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for Relevance {\n\tfn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n\twhere\n\t\tD: Deserializer\u003c'de\u003e,\n\t{\n\t\tOk(f32::deserialize(deserializer)?.into())\n\t}\n}\n\nimpl Eq for Relevance {}\nimpl PartialOrd for Relevance {\n\tfn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cstd::cmp::Ordering\u003e {\n\t\tSome(self.cmp(other))\n\t}\n}\n\nimpl Ord for Relevance {\n\tfn cmp(\u0026self, other: \u0026Self) -\u003e std::cmp::Ordering {\n\t\t// SAFETY: we're guaranteed in the constructor of `Relevance` that the\n\t\t// value is between 0 and 1. And is never NaN, -inf or +inf.\n\t\t//\n\t\t// IEEE 754-2008 section 5.11:\n\t\t// https://grouper.ieee.org/groups/msc/ANSI_IEEE-Std-754-2019/background/predicates.txt\n\t\t// allows total ordering if values are finite.\n\t\tself.0.partial_cmp(\u0026other.0).unwrap()\n\t}\n}\n\nimpl Default for Relevance {\n\tfn default() -\u003e Self {\n\t\tSelf::max()\n\t}\n}\n\nimpl Display for Relevance {\n\tfn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n\t\twrite!(f, \"{}\", self.0)\n\t}\n}\n\nimpl Relevance {\n\tconst MAX: Self = Relevance(1.0);\n\tconst MIN: Self = Relevance(0.0);\n\n\tpub const fn max() -\u003e Self {\n\t\tSelf::MAX\n\t}\n\n\tpub const fn min() -\u003e Self {\n\t\tSelf::MIN\n\t}\n\n\tpub fn none() -\u003e Self {\n\t\tSelf::MIN\n\t}\n\n\tpub fn new(value: f32) -\u003e Self {\n\t\tif value.is_finite() {\n\t\t\tSelf(value.clamp(0.0, 1.0))\n\t\t} else {\n\t\t\tSelf::none()\n\t\t}\n\t}\n\n\tpub const fn value(\u0026self) -\u003e f32 {\n\t\tself.0\n\t}\n\n\tpub fn is_none(\u0026self) -\u003e bool {\n\t\tself.0 == Self::none().0\n\t}\n}\n\nimpl Deref for Relevance {\n\ttype Target = f32;\n\n\tfn deref(\u0026self) -\u003e \u0026Self::Target {\n\t\t\u0026self.0\n\t}\n}\n\nimpl From\u003cRelevance\u003e for f32 {\n\tfn from(radius: Relevance) -\u003e Self {\n\t\tradius.0\n\t}\n}\n\nimpl From\u003cRelevance\u003e for usize {\n\tfn from(radius: Relevance) -\u003e Self {\n\t\tradius.0 as usize\n\t}\n}\n\nimpl From\u003cf32\u003e for Relevance {\n\tfn from(radius: f32) -\u003e Self {\n\t\tSelf::new(radius)\n\t}\n}\n\nimpl Sub for Relevance {\n\ttype Output = Self;\n\n\tfn sub(self, rhs: Self) -\u003e Self::Output {\n\t\tif self.0 \u003c rhs.0 {\n\t\t\treturn Self::MIN;\n\t\t}\n\n\t\tSelf::new(self.0 - rhs.0)\n\t}\n}\n\nimpl Add for Relevance {\n\ttype Output = Self;\n\n\tfn add(self, rhs: Self) -\u003e Self::Output {\n\t\tif self.0 + rhs.0 \u003e 1.0 {\n\t\t\treturn Self::MAX;\n\t\t}\n\n\t\tSelf::new(self.0 + rhs.0)\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","client-sdk","src","lib.rs"],"content":"mod attribute;\nmod error;\nmod event;\nmod interest;\npub mod protocol;\nmod session;\n\npub use {\n\tattribute::{\n\t\tAttribute,\n\t\tAttributeId,\n\t\tAttributeIndexError,\n\t\tAttributeType,\n\t\tValue,\n\t\tMAX_SEQUENCE_LENGTH,\n\t},\n\terror::Error,\n\tevent::{EventClass, OutboundEvent, Recipient, MAX_PAYLOAD_LEN},\n\tinterest::Relevance,\n\tprotocol::WellKnownAttribute,\n\tsession::{\n\t\tderive_shared_id,\n\t\tstreams::{\n\t\t\tEventsFilter,\n\t\t\tLocalUpdate,\n\t\t\tMTUBytes,\n\t\t\tPacket,\n\t\t\tPriority,\n\t\t\tQoS,\n\t\t\tQuery,\n\t\t\tRemoteUpdate,\n\t\t\tStreams,\n\t\t\tSubscriptionId,\n\t\t},\n\t\ttime::LocalTime,\n\t\tSession,\n\t},\n};\nuse {\n\tserde::{Deserialize, Serialize},\n\tstd::fmt::Display,\n};\n\n#[cfg(feature = \"generate-bindings\")]\nmod bindings;\n\npub type IndexId = u32;\npub type PlayerId = u32;\npub type ObjectId = u64;\npub type SessionId = PlayerId;\npub type Timestamp = u64;\n\ntype TimestampedVal = (Value, Timestamp);\n\n#[derive(\n\tDebug,\n\tClone,\n\tCopy,\n\tPartialOrd,\n\tOrd,\n\tPartialEq,\n\tEq,\n\tHash,\n\tSerialize,\n\tDeserialize,\n)]\npub enum EntityId {\n\tObject(ObjectId),\n\tPlayer(PlayerId),\n}\n\nimpl EntityId {\n\tpub const SYSTEM_PLAYER: Self = Self::Player(0);\n\n\tpub const fn is_player(\u0026self) -\u003e bool {\n\t\tmatches!(self, Self::Player(_))\n\t}\n\n\tpub const fn is_object(\u0026self) -\u003e bool {\n\t\tmatches!(self, Self::Object(_))\n\t}\n}\n\nimpl Display for EntityId {\n\tfn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n\t\tmatch self {\n\t\t\tEntityId::Object(id) =\u003e write!(f, \"Object({})\", id),\n\t\t\tEntityId::Player(id) =\u003e write!(f, \"Player({})\", id),\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","client-sdk","src","protocol.rs"],"content":"pub mod common_capnp {\n\tinclude!(concat!(env!(\"OUT_DIR\"), \"/common_capnp.rs\"));\n}\n\npub mod attributes_capnp {\n\tinclude!(concat!(env!(\"OUT_DIR\"), \"/attributes_capnp.rs\"));\n}\n\npub mod handshake_capnp {\n\tinclude!(concat!(env!(\"OUT_DIR\"), \"/handshake_capnp.rs\"));\n}\n\npub mod inbound_capnp {\n\tinclude!(concat!(env!(\"OUT_DIR\"), \"/inbound_capnp.rs\"));\n}\n\npub mod outbound_capnp {\n\tinclude!(concat!(env!(\"OUT_DIR\"), \"/outbound_capnp.rs\"));\n}\n\npub mod events_capnp {\n\tinclude!(concat!(env!(\"OUT_DIR\"), \"/events_capnp.rs\"));\n}\n\nuse bytes::{BufMut, Bytes};\npub use {\n\tattributes::WellKnownAttribute,\n\tattributes_capnp as attributes,\n\tcommon_capnp as common,\n\tevents_capnp as events,\n\thandshake::SessionErrorCode,\n\thandshake_capnp as handshake,\n\tinbound_capnp as inbound,\n\toutbound_capnp as outbound,\n};\n\npub type Error = capnp::Error;\n\npub async fn send_builder\u003cS, A\u003e(\n\tstream: \u0026mut S,\n\tbuilder: capnp::message::Builder\u003cA\u003e,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e\nwhere\n\tS: futures::Sink\u003cbytes::Bytes, Error = std::io::Error\u003e + Unpin,\n\tA: capnp::message::Allocator,\n{\n\tuse futures::SinkExt;\n\n\tstream.send(builder.as_bytes()?).await?;\n\tOk(())\n}\n\npub trait BuilderExt {\n\tfn as_bytes(\u0026self) -\u003e Result\u003cBytes, Error\u003e;\n}\n\nimpl\u003cA: capnp::message::Allocator\u003e BuilderExt for capnp::message::Builder\u003cA\u003e {\n\tfn as_bytes(\u0026self) -\u003e Result\u003cBytes, Error\u003e {\n\t\tlet outbuf = bytes::BytesMut::new();\n\t\tlet mut writer = outbuf.writer();\n\t\tcapnp::serialize_packed::write_message(\u0026mut writer, self)?;\n\t\tOk(writer.into_inner().freeze())\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","client-sdk","src","session","mod.rs"],"content":"use {\n\tcrate::{\n\t\tprotocol::handshake::{\n\t\t\tsession_handshake_request,\n\t\t\tsession_handshake_response,\n\t\t},\n\t\tError,\n\t\tObjectId,\n\t},\n\tbytes::{Buf, BufMut, BytesMut},\n\tcapnp::message::ReaderOptions,\n\tfutures::{SinkExt, StreamExt},\n\tstreams::Streams,\n\ttokio::net::TcpStream,\n\ttokio_util::codec::{Framed, LengthDelimitedCodec},\n};\n\npub mod streams;\npub mod time;\n\n/// A unique identifier for a session across the\n/// entire game world at a given time.\n///\n/// This ID may be reused after a session ends by\n/// another session.\npub type SessionId = u32;\n\n/// Represents a client connection to the server.\npub struct Session {\n\t/// A server-wide unique identifier for this session.\n\t///\n\t/// This is also the player's ID.\n\tassigned_id: SessionId,\n\n\t/// A token that can be used to resume this session if dropped within a short\n\t/// period.\n\tresume_token: Vec\u003cu8\u003e,\n\n\t/// The streams associated with this session.\n\tstreams: Streams,\n}\n\nunsafe impl Send for Session {}\n\nimpl Session {\n\tfn create(\n\t\ttcplink: Framed\u003cTcpStream, LengthDelimitedCodec\u003e,\n\t\tassigned_id: SessionId,\n\t\tresume_token: Vec\u003cu8\u003e,\n\t) -\u003e Result\u003cSelf, Error\u003e {\n\t\tOk(Self {\n\t\t\tassigned_id,\n\t\t\tresume_token,\n\t\t\tstreams: Streams::new(tcplink, assigned_id)?,\n\t\t})\n\t}\n}\n\nimpl Session {\n\t/// Invoked by the client to initiate a new session with the server.\n\t///\n\t/// The initial connection to the server has the following steps:\n\t/// 1. The client opens a socket to the server.\n\t/// 2. The client sends a handshake request to the server.\n\t/// 3. The server responds with a handshake response that assigns this session\n\t///    an ID, or rejects the connection with the reason it was rejected.\n\tpub async fn start(server_addr: \u0026str, auth: \u0026[u8]) -\u003e Result\u003cSelf, Error\u003e {\n\t\tlet server_addr = make_server_addr(server_addr)?;\n\t\tlet mut stream = Framed::new(\n\t\t\tTcpStream::connect(server_addr.clone()).await?,\n\t\t\tLengthDelimitedCodec::new(),\n\t\t);\n\n\t\t// send the handshake request to the server\n\t\tlet message = {\n\t\t\tlet outbuf = BytesMut::new();\n\t\t\t// build the start session handshake request\n\t\t\tlet mut request = capnp::message::Builder::new_default();\n\t\t\tlet builder = request.init_root::\u003csession_handshake_request::Builder\u003e();\n\t\t\tlet mut builder = builder.init_start();\n\t\t\tbuilder.set_auth(auth);\n\n\t\t\tlet mut writer = outbuf.writer();\n\t\t\tcapnp::serialize_packed::write_message(\u0026mut writer, \u0026request)?;\n\t\t\twriter.into_inner()\n\t\t};\n\n\t\tstream.send(message.freeze()).await?;\n\n\t\t// wait for the server to respond\n\t\tlet response = match stream.next().await {\n\t\t\tSome(Ok(bytes)) =\u003e bytes,\n\t\t\tSome(Err(e)) =\u003e return Err(Error::Io(e)),\n\t\t\tNone =\u003e return Err(Error::ConnectionDropped),\n\t\t};\n\n\t\t// parse the server's response\n\t\tlet message = capnp::serialize_packed::read_message(\n\t\t\t\u0026mut response.reader(),\n\t\t\tReaderOptions::default(),\n\t\t)?;\n\n\t\tlet reader = message.get_root::\u003csession_handshake_response::Reader\u003e()?;\n\t\tlet session_id;\n\t\tlet resume_token;\n\n\t\tmatch reader.which()? {\n\t\t\tsession_handshake_response::Which::Started(success) =\u003e {\n\t\t\t\tlet success = success?;\n\t\t\t\tsession_id = success.get_assigned_id();\n\t\t\t\tresume_token = success.get_resume_token()?.to_vec();\n\t\t\t}\n\t\t\tsession_handshake_response::Which::Rejected(code) =\u003e {\n\t\t\t\treturn Err(Error::Rejected(code?));\n\t\t\t}\n\t\t}\n\n\t\tSelf::create(stream, session_id, resume_token)\n\t}\n\n\t/// Invoked by the client to resume the session from the server.\n\t///\n\t/// Resuming of the connection to the server has the following steps:\n\t/// 1. The client opens a socket to the server.\n\t/// 2. The client sends a handshake request to the server.\n\t/// 3. The server responds with a handshake response that assigns this session\n\t///    an ID, or rejects the connection with the reason it was rejected.\n\tpub async fn resume(\n\t\tserver_addr: \u0026str,\n\t\tresume_token: \u0026[u8],\n\t) -\u003e Result\u003cSelf, Error\u003e {\n\t\tlet server_addr = make_server_addr(server_addr)?;\n\t\tlet mut stream = Framed::new(\n\t\t\tTcpStream::connect(server_addr.clone()).await?,\n\t\t\tLengthDelimitedCodec::new(),\n\t\t);\n\n\t\t// build the resume session handshake request\n\t\tlet outbuf = {\n\t\t\tlet mut request = capnp::message::Builder::new_default();\n\t\t\tlet builder = request.init_root::\u003csession_handshake_request::Builder\u003e();\n\t\t\tlet mut builder = builder.init_resume();\n\t\t\tbuilder.set_token(resume_token);\n\t\t\t// send the handshake request to the server\n\t\t\tlet outbuf = BytesMut::new();\n\t\t\tlet mut writer = outbuf.writer();\n\t\t\tcapnp::serialize_packed::write_message(\u0026mut writer, \u0026request)?;\n\t\t\tlet outbuf = writer.into_inner();\n\t\t\toutbuf.freeze()\n\t\t};\n\n\t\tstream.send(outbuf).await?;\n\n\t\t// wait for the server to respond\n\t\tlet response = match stream.next().await {\n\t\t\tSome(Ok(bytes)) =\u003e bytes,\n\t\t\tSome(Err(e)) =\u003e return Err(Error::Io(e)),\n\t\t\tNone =\u003e return Err(Error::ConnectionDropped),\n\t\t};\n\n\t\t// parse the server's response\n\t\tlet message = capnp::serialize_packed::read_message(\n\t\t\t\u0026mut response.reader(),\n\t\t\tReaderOptions::default(),\n\t\t)?;\n\n\t\tlet reader = message.get_root::\u003csession_handshake_response::Reader\u003e()?;\n\n\t\tmatch reader.which()? {\n\t\t\tsession_handshake_response::Which::Started(success) =\u003e {\n\t\t\t\tlet success = success?;\n\t\t\t\tSelf::create(\n\t\t\t\t\tstream,\n\t\t\t\t\tsuccess.get_assigned_id(),\n\t\t\t\t\tsuccess.get_resume_token()?.to_vec(),\n\t\t\t\t)\n\t\t\t}\n\t\t\tsession_handshake_response::Which::Rejected(code) =\u003e {\n\t\t\t\tErr(Error::Rejected(code?))\n\t\t\t}\n\t\t}\n\t}\n\n\t/// Entrypoint to the Streams API.\n\tpub fn streams(\u0026mut self) -\u003e \u0026mut Streams {\n\t\t\u0026mut self.streams\n\t}\n}\n\nimpl Session {\n\tpub const fn id(\u0026self) -\u003e SessionId {\n\t\tself.assigned_id\n\t}\n\n\tpub const fn derive_global_id(\u0026self, local_id: u32) -\u003e ObjectId {\n\t\t(self.assigned_id as u64) \u003c\u003c 32 | (local_id as u64)\n\t}\n\n\tpub fn resume_token(\u0026self) -\u003e \u0026[u8] {\n\t\t\u0026self.resume_token\n\t}\n}\n\npub const fn derive_shared_id(local_id: u32) -\u003e ObjectId {\n\t(u32::MAX as u64) \u003c\u003c 32 | (local_id as u64)\n}\n\nfn make_server_addr(server_addr: \u0026str) -\u003e Result\u003cString, Error\u003e {\n\tlet server_addr: Vec\u003c_\u003e = server_addr.split(':').collect();\n\tif server_addr.is_empty() {\n\t\treturn Err(Error::BadAddressFormat);\n\t}\n\n\tlet server_addr = server_addr[0].to_owned()\n\t\t+ \":\"\n\t\t+ if server_addr.len() == 1 {\n\t\t\t\"5670\"\n\t\t} else {\n\t\t\tserver_addr[1]\n\t\t};\n\n\tOk(server_addr)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","client-sdk","src","session","streams","mod.rs"],"content":"use {\n\tself::muxer::Muxer,\n\tsuper::time::LocalTime,\n\tcrate::{\n\t\tAttributeId,\n\t\tEntityId,\n\t\tError,\n\t\tEventClass,\n\t\tObjectId,\n\t\tPlayerId,\n\t\tRecipient,\n\t\tRelevance,\n\t\tTimestamp,\n\t\tValue,\n\t},\n\tfutures::{Stream, StreamExt},\n\trand::random,\n\tstd::{\n\t\tcollections::HashSet,\n\t\tpin::Pin,\n\t\ttask::{Context, Poll},\n\t\ttime::Duration,\n\t},\n\tthiserror::Error,\n\ttokio::net::TcpStream,\n\ttokio_util::codec::{Framed, LengthDelimitedCodec},\n};\n\nmod muxer;\nmod packet;\nmod pending;\nmod tcp;\nmod udp;\n\nuse fxhash::FxHashSet;\npub use packet::{MTUBytes, Packet};\npub(crate) use {tcp::TcpStreams, udp::UdpStreams};\n\n/// This enum represents an update that originates on the local client and is\n/// sent to the server.\n///\n/// Those updates types are independent of the transport protocol\n/// (reliable/unreliable) used.\n#[derive(Debug, Clone, PartialEq)]\npub enum LocalUpdate {\n\t/// A change to an attribute of the local player entity.\n\tPlayer(AttributeId, Value),\n\n\t/// A change to some object's attribute value.\n\tObject(ObjectId, AttributeId, Value),\n\n\t/// An event emitted by the local client.\n\tEvent(EventClass, Box\u003c[u8]\u003e, Recipient),\n}\n\n/// This enum represents the quality of service of a single change to an\n/// attribute of an entity or an event.\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum QoS {\n\t/// Slower but reliable and ordered delivery\n\tReliable,\n\n\t/// Fast but unreliable and unordered delivery\n\tUnreliable,\n}\n\n/// This enum represents an update that is sent by the server to the local\n/// client.\n///\n/// Those updates types are independent of the transport protocol\n/// (reliable/unreliable) used.\n#[derive(Debug, Clone, PartialEq)]\npub enum RemoteUpdate {\n\t/// A change to some player's attribute value.\n\tPlayer(PlayerId, AttributeId, Value, Timestamp),\n\n\t/// A change to some object's attribute value.\n\tObject(ObjectId, AttributeId, Value, Timestamp),\n\n\t/// An event emitted by the server.\n\t/// (class_id, payload, sender)\n\tEvent(EventClass, Box\u003c[u8]\u003e, EntityId, Timestamp),\n}\n\n/// This struct represents a query that is used to subscribe to updates from the\n/// server.\n///\n/// Periodically the server will send updates to the client that match the\n/// query.\n#[derive(Debug, PartialEq, Eq, Clone)]\npub struct Query {\n\t/// The relevance radius of the query\n\tpub radius: Relevance,\n\n\t/// The tags that the relevant objects, players and their attributes must\n\t/// have to match the query.\n\t///\n\t/// If this field is empty, the query will return all objects and players and\n\t/// their.\n\tpub tags: Vec\u003cString\u003e,\n\n\t/// The interval at which the server sends updates to the client\n\tpub interval: Duration,\n\n\t/// The priority of the query.\n\t///\n\t/// This value is considered when the server has to decide which queries to\n\t/// send updates to first when throttling bandwidth usage for a client.\n\tpub priority: Priority,\n\n\t/// The events filter that decides which events the subscription is\n\t/// interested in.\n\tpub events: EventsFilter,\n\n\t/// The maximum number of events that the query will queue up between\n\t/// updates.\n\tpub backlog: usize,\n}\n\nimpl Default for Query {\n\tfn default() -\u003e Self {\n\t\tSelf {\n\t\t\tradius: Relevance::default(),\n\t\t\ttags: Vec::new(),\n\t\t\tinterval: Duration::from_secs(1),\n\t\t\tpriority: Priority::default(),\n\t\t\tevents: EventsFilter::default(),\n\t\t\tbacklog: 64,\n\t\t}\n\t}\n}\n\n#[derive(Debug, Eq, PartialOrd, Ord, Clone, PartialEq)]\n#[repr(transparent)]\npub struct Priority(u8);\n\nimpl From\u003cu8\u003e for Priority {\n\tfn from(value: u8) -\u003e Self {\n\t\tSelf(value)\n\t}\n}\n\nimpl From\u003cPriority\u003e for u8 {\n\tfn from(value: Priority) -\u003e Self {\n\t\tvalue.0\n\t}\n}\n\nimpl Default for Priority {\n\tfn default() -\u003e Self {\n\t\tSelf::NORMAL\n\t}\n}\n\nimpl Priority {\n\tpub const HIGH: Self = Self(100);\n\tpub const HIGHEST: Self = Self(u8::MAX);\n\tpub const LOW: Self = Self(1);\n\tpub const LOWEST: Self = Self(0);\n\tpub const NORMAL: Self = Self(50);\n\n\tpub fn new(value: u8) -\u003e Self {\n\t\tSelf(value)\n\t}\n}\n\n/// Used to configure the events that a query is interested in.\n///\n/// If there is more than one query that is interested in the same event,\n/// then the server will return that event in only one of the queries\n/// that is unspecified.\n#[derive(Debug, PartialEq, Eq, Clone)]\npub enum EventsFilter {\n\tWhitelist(FxHashSet\u003cEventClass\u003e),\n\tBlacklist(FxHashSet\u003cEventClass\u003e),\n}\n\nimpl Default for EventsFilter {\n\t/// by default we're interested in all events\n\tfn default() -\u003e Self {\n\t\tSelf::all()\n\t}\n}\n\nimpl EventsFilter {\n\tpub fn all() -\u003e Self {\n\t\tSelf::Blacklist(HashSet::default())\n\t}\n\n\tpub fn none() -\u003e Self {\n\t\tSelf::Whitelist(HashSet::default())\n\t}\n\n\tpub fn only(events: \u0026[EventClass]) -\u003e Self {\n\t\tSelf::Whitelist(events.iter().copied().collect())\n\t}\n\n\tpub fn except(events: \u0026[EventClass]) -\u003e Self {\n\t\tSelf::Blacklist(events.iter().copied().collect())\n\t}\n\n\t/// Checks if this query accepts an event class. If yes, then the server\n\t/// will send that event to the client over this query subscription.\n\t///\n\t/// If more than one query accepts the same event, then the server will\n\t/// pick random one of the subscription to send the event to.\n\tpub fn accepts(\u0026self, event: EventClass) -\u003e bool {\n\t\tmatch self {\n\t\t\tSelf::Whitelist(whitelist) =\u003e whitelist.contains(\u0026event),\n\t\t\tSelf::Blacklist(blacklist) =\u003e !blacklist.contains(\u0026event),\n\t\t}\n\t}\n}\n\n/// A unique udentifier for a registered `Query`` subscription.\npub type SubscriptionId = u32;\n\n/// Commands that the client can send to the server.\n#[derive(Debug)]\nenum C2SCommand {\n\tSubscribe {\n\t\tid: SubscriptionId,\n\t\tquery: Query,\n\t\tqos: QoS,\n\t},\n\tUnsubscribe(SubscriptionId),\n\tSendUpdate {\n\t\tupdate: LocalUpdate,\n\t\ttimestamp: Timestamp,\n\t},\n\tSetTickInterval(Duration),\n\tFlush,\n\tDisconnect,\n\tSyncTime,\n}\n\n/// Commands that the server can send to the client.\n#[derive(Debug)]\nenum S2CCommand {\n\t/// An update from the server.\n\tUpdate(RemoteUpdate),\n\n\t/// An update from the server asking the client to\n\t/// adjust its tick rate by a given factor. Those values\n\t/// are between 0.0 and 1.0.\n\tAdjustTickRate(f32),\n\n\t/// Instructs the client session to terminate\n\tDisconnect,\n}\n\npub struct Streams {\n\t/// The unreliable fast and lightweight streams for high-frequency updates\n\t/// that can tolerate packet loss and out of order delivery.\n\tudp: UdpStreams,\n\n\t/// The reliable streams for low-frequency updates that require guaranteed\n\t/// delivery and order.\n\ttcp: TcpStreams,\n\n\t/// Here incoming updates from both the reliable and unreliable channels are\n\t/// merged and made available to the client. The muxer also takes care of\n\t/// overriting duplicate updates with the latest versions.\n\t///\n\t/// The channel over which the update was received is not exposed to the\n\t/// client and is abstracted away by the muxer.\n\tmuxer: Muxer,\n\n\tlocal_time: LocalTime,\n}\n\nimpl Streams {\n\tpub fn new(\n\t\ttcplink: Framed\u003cTcpStream, LengthDelimitedCodec\u003e,\n\t\tassigned_id: PlayerId,\n\t) -\u003e Result\u003cSelf, std::io::Error\u003e {\n\t\tlet server_addr = tcplink.get_ref().peer_addr()?;\n\t\tlet local_addr = tcplink.get_ref().local_addr()?;\n\n\t\tlet local_time = LocalTime::default();\n\t\tlet mut tcp = TcpStreams::new(assigned_id, tcplink, local_time.clone());\n\t\tlet mut udp = UdpStreams::new(server_addr, assigned_id, local_addr);\n\n\t\tlet muxer = Muxer::new(\n\t\t\tudp\n\t\t\t\t.take_receiver()\n\t\t\t\t.expect(\"UDP receiver taken by someone else\"),\n\t\t\ttcp\n\t\t\t\t.take_receiver()\n\t\t\t\t.expect(\"TCP receiver taken by someone else\"),\n\t\t);\n\n\t\tOk(Self {\n\t\t\tudp,\n\t\t\ttcp,\n\t\t\tmuxer,\n\t\t\tlocal_time,\n\t\t})\n\t}\n}\n\nimpl Streams {\n\t/// Pushes a new update to the server.\n\t///\n\t/// This method will not immediately send the update, instead\n\t/// it will schedule it to be sent at the next tick interval.\n\t///\n\t///\n\t/// If `reliable` is set to `true`, the update will be sent over the\n\t/// TCP channel, otherwise it will be sent over the UDP channel.\n\tpub fn send(\u0026self, update: LocalUpdate, qos: QoS) -\u003e Result\u003c(), Error\u003e {\n\t\tlet command = C2SCommand::SendUpdate {\n\t\t\tupdate,\n\t\t\ttimestamp: self.local_time.timestamp(),\n\t\t};\n\t\tmatch qos {\n\t\t\tQoS::Reliable =\u003e self.tcp.send(command),\n\t\t\tQoS::Unreliable =\u003e self.udp.send(command),\n\t\t}\n\t\t.map_err(|_| Error::ConnectionDropped)\n\t}\n\n\t/// Similar to [Self::send()] except it allows to indicate that the update\n\t/// happened at some time in the past. This time is defined by the `age`\n\t/// parameter.\n\tpub fn send_postponed(\n\t\t\u0026self,\n\t\tupdate: LocalUpdate,\n\t\tqos: QoS,\n\t\tage: Timestamp,\n\t) -\u003e Result\u003c(), Error\u003e {\n\t\tlet command = C2SCommand::SendUpdate {\n\t\t\tupdate,\n\t\t\ttimestamp: self.local_time.timestamp_sub(age),\n\t\t};\n\t\tmatch qos {\n\t\t\tQoS::Reliable =\u003e self.tcp.send(command),\n\t\t\tQoS::Unreliable =\u003e self.udp.send(command),\n\t\t}\n\t\t.map_err(|_| Error::ConnectionDropped)\n\t}\n\n\t/// Flushes the outgoing buffers of both the reliable and unreliable channels,\n\t/// and forces all accumulated changes to be sent immediately to the server.\n\tpub fn flush(\u0026self) -\u003e Result\u003c(), Error\u003e {\n\t\tself.tcp.flush().map_err(|_| Error::ConnectionDropped)?;\n\t\tself.udp.flush().map_err(|_| Error::ConnectionDropped)?;\n\t\tOk(())\n\t}\n\n\t/// Creates new query subscription.\n\t///\n\t/// Subscription requests are always sent to the server over a reliable\n\t/// channel.\n\tpub fn subscribe(\n\t\t\u0026self,\n\t\tquery: Query,\n\t\tqos: QoS,\n\t) -\u003e Result\u003cSubscriptionId, Error\u003e {\n\t\tlet id = random();\n\t\tself\n\t\t\t.tcp\n\t\t\t.send(C2SCommand::Subscribe { id, query, qos })\n\t\t\t.map_err(|_| Error::ConnectionDropped)?;\n\t\tOk(id)\n\t}\n\n\t/// Unsubscribes from a previously created query subscription.\n\t///\n\t/// Unsubscription requests are always sent to the server over a reliable\n\tpub fn unsubscribe(\n\t\t\u0026self,\n\t\tsubscription_id: SubscriptionId,\n\t) -\u003e Result\u003c(), Error\u003e {\n\t\tself\n\t\t\t.tcp\n\t\t\t.send(C2SCommand::Unsubscribe(subscription_id))\n\t\t\t.map_err(|_| Error::ConnectionDropped)\n\t}\n\n\t/// Receives an update from the server.\n\t///\n\t/// This method will return updates that were sent by the server over the\n\t/// reliable and unreliable channels. Updates are merged and newers updates\n\t/// will overwrite older updates for the same entity and attribute pair.\n\t///\n\t/// If there is no update to receive, this method will block the future until\n\t/// an update is received.\n\tpub async fn receive(\u0026mut self) -\u003e Result\u003cRemoteUpdate, Error\u003e {\n\t\tself.muxer.receive().await\n\t}\n\n\t/// Tries to receive an update from the server.\n\t///\n\t/// This method will return updates that were sent by the server over the\n\t/// reliable and unreliable channels. Updates are merged and newers updates\n\t/// will overwrite older updates for the same entity and attribute pair.\n\t///\n\t/// If there is no update to receive, this method will return `None`.\n\tpub fn try_receive(\u0026mut self) -\u003e Option\u003cRemoteUpdate\u003e {\n\t\tself.muxer.try_receive()\n\t}\n\n\t/// Sets the interval at which the client sends updates to the server.\n\t/// The second parameter `qos` determines if we're updating the\n\t/// interval for the reliable or unreliable channel.\n\t///\n\t/// As a rule of thumb the reliable channel should have a much higher tick\n\t/// interval than the unreliable channel. The default tick interval for the\n\t/// reliable channel is 1s and for the unreliable channel is 100ms.\n\tpub fn set_outbound_tick_interval(\n\t\t\u0026self,\n\t\tinterval: Duration,\n\t\tqos: QoS,\n\t) -\u003e Result\u003c(), Error\u003e {\n\t\tmatch qos {\n\t\t\tQoS::Reliable =\u003e self.tcp.send(C2SCommand::SetTickInterval(interval)),\n\t\t\tQoS::Unreliable =\u003e self.udp.send(C2SCommand::SetTickInterval(interval)),\n\t\t}\n\t\t.map_err(|_| Error::ConnectionDropped)\n\t}\n\n\tpub fn time(\u0026self) -\u003e \u0026LocalTime {\n\t\t\u0026self.local_time\n\t}\n\n\tpub fn sync_time(\u0026self) {\n\t\tlet _ = self.tcp.send(C2SCommand::SyncTime);\n\t}\n}\n\nimpl Drop for Streams {\n\tfn drop(\u0026mut self) {\n\t\t// terminate the event loops on both channgels\n\t\tlet _ = self.udp.send(C2SCommand::Disconnect);\n\t\tlet _ = self.tcp.send(C2SCommand::Disconnect);\n\t}\n}\n\nimpl Stream for Streams {\n\ttype Item = RemoteUpdate;\n\n\tfn poll_next(\n\t\tmut self: Pin\u003c\u0026mut Self\u003e,\n\t\tcx: \u0026mut Context,\n\t) -\u003e Poll\u003cOption\u003cSelf::Item\u003e\u003e {\n\t\tself.muxer.poll_next_unpin(cx)\n\t}\n}\n\n/// Similar semantics to `Stream`, but this will\n/// iterate over all updates that are available\n/// at the time of calling `next`. and exhaust the\n/// updates before returning None.\nimpl Iterator for Streams {\n\ttype Item = RemoteUpdate;\n\n\tfn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n\t\tself.try_receive()\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","client-sdk","src","session","streams","muxer.rs"],"content":"use {\n\tsuper::{Error, S2CCommand},\n\tcrate::{\n\t\tAttributeId,\n\t\tEntityId,\n\t\tEventClass,\n\t\tRemoteUpdate,\n\t\tTimestamp,\n\t\tTimestampedVal,\n\t},\n\tcrossbeam::queue::SegQueue,\n\tdashmap::DashMap,\n\tfutures::{FutureExt, Stream, StreamExt},\n\tstd::{\n\t\tpin::{pin, Pin},\n\t\tsync::{\n\t\t\tatomic::{AtomicBool, Ordering},\n\t\t\tArc,\n\t\t},\n\t\ttask::{Context, Poll},\n\t},\n\ttokio::sync::{mpsc, Notify},\n};\n\nstruct Event {\n\tclass: EventClass,\n\tpayload: Box\u003c[u8]\u003e,\n\tsender: EntityId,\n\ttimestamp: Timestamp,\n}\n\n#[derive(Default)]\nstruct UpdatesAccumulator {\n\tevents: SegQueue\u003cEvent\u003e,\n\tentities: DashMap\u003cEntityId, DashMap\u003cAttributeId, TimestampedVal\u003e\u003e,\n}\n\nimpl UpdatesAccumulator {\n\tfn is_empty(\u0026self) -\u003e bool {\n\t\tself.events.is_empty() \u0026\u0026 self.entities.is_empty()\n\t}\n\n\tfn pop(\u0026self) -\u003e Option\u003cRemoteUpdate\u003e {\n\t\tif self.is_empty() {\n\t\t\treturn None;\n\t\t}\n\n\t\tif let Some(event) = self.events.pop() {\n\t\t\treturn Some(RemoteUpdate::Event(\n\t\t\t\tevent.class,\n\t\t\t\tevent.payload,\n\t\t\t\tevent.sender,\n\t\t\t\tevent.timestamp,\n\t\t\t));\n\t\t}\n\n\t\tlet (entity_key, attribute_key, attribute_value, timestamp, last) = {\n\t\t\tlet entity = self.entities.iter().next()?;\n\t\t\tlet attribute = entity.value().iter().next()?;\n\n\t\t\tlet attribute_key = *attribute.key();\n\t\t\tdrop(attribute);\n\n\t\t\tlet (_, (attribute_value, timestamp)) =\n\t\t\t\tentity.remove(\u0026attribute_key).expect(\n\t\t\t\t\t\"try_receive is \u0026mut self and we're guaranteed that we don't have \\\n\t\t\t\t\t concurrent pops\",\n\t\t\t\t);\n\n\t\t\tlet entity_key = *entity.key();\n\t\t\tlet was_last = entity.is_empty();\n\n\t\t\t(\n\t\t\t\tentity_key,\n\t\t\t\tattribute_key,\n\t\t\t\tattribute_value,\n\t\t\t\ttimestamp,\n\t\t\t\twas_last,\n\t\t\t)\n\t\t};\n\n\t\tif last {\n\t\t\tself.entities.remove(\u0026entity_key);\n\t\t}\n\n\t\tSome(match entity_key {\n\t\t\tEntityId::Object(object_id) =\u003e RemoteUpdate::Object(\n\t\t\t\tobject_id,\n\t\t\t\tattribute_key,\n\t\t\t\tattribute_value,\n\t\t\t\ttimestamp,\n\t\t\t),\n\t\t\tEntityId::Player(player_id) =\u003e RemoteUpdate::Player(\n\t\t\t\tplayer_id,\n\t\t\t\tattribute_key,\n\t\t\t\tattribute_value,\n\t\t\t\ttimestamp,\n\t\t\t),\n\t\t})\n\t}\n}\n\n/// This type is the sink for all updates that are received from the server\n/// over the network, regardless of the channel they're received on.\n///\n/// It will accumulate all received values and ensure that only the latest\n/// version of each attribute is kept.\n///\n/// On the consuming end of this type, there is a stream that will yield\n/// one random update that are available at the time of polling.\n///\n/// Polling will yield a value if there is an update available, otherwise\n/// it will wait for an update to be available.\n///\n/// Iterating over this type will yield all updates that are available at\n/// the time of calling `next`.\n\npub struct Muxer {\n\tprogress: Arc\u003cNotify\u003e,\n\tdisconnected: Arc\u003cAtomicBool\u003e,\n\taccumulator: Arc\u003cUpdatesAccumulator\u003e,\n}\n\nimpl Muxer {\n\tpub fn new(\n\t\tudp_recv: mpsc::UnboundedReceiver\u003cS2CCommand\u003e,\n\t\ttcp_recv: mpsc::UnboundedReceiver\u003cS2CCommand\u003e,\n\t) -\u003e Self {\n\t\tlet progress = Arc::new(Notify::new());\n\t\tlet accumulator = Arc::default();\n\t\tlet disconnected = Arc::new(AtomicBool::new(false));\n\n\t\ttokio::spawn(receiver_loop(\n\t\t\tArc::clone(\u0026disconnected),\n\t\t\tArc::clone(\u0026progress),\n\t\t\tudp_recv,\n\t\t\ttcp_recv,\n\t\t\tArc::clone(\u0026accumulator),\n\t\t));\n\n\t\tSelf {\n\t\t\tprogress,\n\t\t\taccumulator,\n\t\t\tdisconnected,\n\t\t}\n\t}\n\n\t/// Receives the next update from the server.\n\t/// This method will block until an update is available.\n\tpub async fn receive(\u0026mut self) -\u003e Result\u003cRemoteUpdate, Error\u003e {\n\t\tStreamExt::next(self)\n\t\t\t.await\n\t\t\t.ok_or(Error::Io(std::io::Error::new(\n\t\t\t\tstd::io::ErrorKind::Other,\n\t\t\t\t\"Muxer stream ended unexpectedly\",\n\t\t\t)))\n\t}\n\n\t/// Tries to receive an update from the server.\n\t/// This method will return an update if one is available, otherwise it will\n\t/// return None.\n\tpub fn try_receive(\u0026mut self) -\u003e Option\u003cRemoteUpdate\u003e {\n\t\tself.accumulator.pop()\n\t}\n}\n\nasync fn receiver_loop(\n\tdisconnected: Arc\u003cAtomicBool\u003e,\n\tprogress: Arc\u003cNotify\u003e,\n\tudp_recv: mpsc::UnboundedReceiver\u003cS2CCommand\u003e,\n\ttcp_recv: mpsc::UnboundedReceiver\u003cS2CCommand\u003e,\n\taccumulator: Arc\u003cUpdatesAccumulator\u003e,\n) {\n\tlet mut udp_recv = udp_recv;\n\tlet mut tcp_recv = tcp_recv;\n\n\tloop {\n\t\tlet update = tokio::select! {\n\t\t\t\tSome(update) = tcp_recv.recv() =\u003e update,\n\t\t\t\tSome(update) = udp_recv.recv() =\u003e update,\n\t\t};\n\n\t\tmatch update {\n\t\t\tS2CCommand::Update(update) =\u003e match update {\n\t\t\t\tRemoteUpdate::Player(id, attr, value, timestamp) =\u003e {\n\t\t\t\t\taccumulator\n\t\t\t\t\t\t.entities\n\t\t\t\t\t\t.entry(EntityId::Player(id))\n\t\t\t\t\t\t.or_default()\n\t\t\t\t\t\t.insert(attr, (value, timestamp));\n\t\t\t\t\tprogress.notify_one();\n\t\t\t\t}\n\t\t\t\tRemoteUpdate::Object(id, attr, value, timestamp) =\u003e {\n\t\t\t\t\taccumulator\n\t\t\t\t\t\t.entities\n\t\t\t\t\t\t.entry(EntityId::Object(id))\n\t\t\t\t\t\t.or_default()\n\t\t\t\t\t\t.insert(attr, (value, timestamp));\n\t\t\t\t\tprogress.notify_one();\n\t\t\t\t}\n\t\t\t\tRemoteUpdate::Event(class, payload, sender, timestamp) =\u003e {\n\t\t\t\t\taccumulator.events.push(Event {\n\t\t\t\t\t\tclass,\n\t\t\t\t\t\tpayload,\n\t\t\t\t\t\tsender,\n\t\t\t\t\t\ttimestamp,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t},\n\t\t\tS2CCommand::AdjustTickRate(_rate) =\u003e {\n\t\t\t\ttodo!()\n\t\t\t}\n\t\t\tS2CCommand::Disconnect =\u003e {\n\t\t\t\tdisconnected.store(true, Ordering::SeqCst);\n\t\t\t\tprogress.notify_one();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t};\n\t}\n}\n\nimpl Stream for Muxer {\n\ttype Item = RemoteUpdate;\n\n\tfn poll_next(\n\t\tmut self: Pin\u003c\u0026mut Self\u003e,\n\t\tcx: \u0026mut Context,\n\t) -\u003e Poll\u003cOption\u003cSelf::Item\u003e\u003e {\n\t\tloop {\n\t\t\tif self.disconnected.load(Ordering::SeqCst) {\n\t\t\t\treturn Poll::Ready(None);\n\t\t\t}\n\n\t\t\tif let Some(next) = self.try_receive() {\n\t\t\t\treturn Poll::Ready(Some(next));\n\t\t\t}\n\n\t\t\tlet notify = self.progress.notified();\n\t\t\tif pin!(notify).poll_unpin(cx).is_pending() {\n\t\t\t\treturn Poll::Pending;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/// Similar semantics to `Stream`, but this will\n/// iterate over all updates that are available\n/// at the time of calling `next`. and exhaust the\n/// updates before returning None.\nimpl Iterator for Muxer {\n\ttype Item = RemoteUpdate;\n\n\tfn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n\t\tself.try_receive()\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","client-sdk","src","session","streams","packet.rs"],"content":"//! UPD Stream Packet\n//!\n//! This module implements the UDP packet structure that is used when\n//! communicating between an open client session and the server.\n//!\n//! In this type of packets we want to pack as many different types of updates\n//! into as few packets as possible.\n//!\n//! Each packet has a header that defines the session id that is sending the\n//! update, followed by a list of datums that contain the actual updates.\n//!\n//! Each datum has a type that defines the type of update that is being sent.\n//! Unlike in UDP replication packets, here we are not packing packets by their\n//! type, instead we're packing all types of updates in the same packet.\n\nuse {crate::PlayerId, std::mem::size_of};\n\n/// Maximum Transmission Unit\n///\n/// This is the maximum payload size of a UDP packet that guarantees\n/// that it will not be fragmented by the network.\nconst MTU_PAYLOAD_LEN: usize = 1400;\n\n/// A raw static buffer that can hold a single unfragmented UDP packet.\n#[repr(align(8))]\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct MTUBytes([u8; MTU_PAYLOAD_LEN]);\n\nimpl Default for MTUBytes {\n\tfn default() -\u003e Self {\n\t\tSelf([0; MTU_PAYLOAD_LEN])\n\t}\n}\n\nimpl MTUBytes {\n\tpub const SIZE: usize = MTU_PAYLOAD_LEN;\n\n\tpub fn clear(\u0026mut self) {\n\t\tself.0.fill(0);\n\t}\n\n\tpub fn header(\u0026self) -\u003e Option\u003c\u0026PacketHeader\u003e {\n\t\tPacketHeader::peek(\u0026self.0)\n\t}\n}\n\nimpl AsMut\u003c[u8]\u003e for MTUBytes {\n\tfn as_mut(\u0026mut self) -\u003e \u0026mut [u8] {\n\t\t\u0026mut self.0[..]\n\t}\n}\n\nimpl AsRef\u003c[u8]\u003e for MTUBytes {\n\tfn as_ref(\u0026self) -\u003e \u0026[u8] {\n\t\t\u0026self.0[..]\n\t}\n}\n\nimpl From\u003cPacket\u003e for MTUBytes {\n\tfn from(packet: Packet) -\u003e Self {\n\t\tpacket.payload\n\t}\n}\n\n/// A packet header that is prepended to the payload.\n///\n/// It stores the session id that is sending the update and the size of the\n/// packet.\n#[repr(align(8))]\npub struct PacketHeader {\n\tplayer_id: PlayerId,\n\tcursor: u16,\n}\n\nimpl PacketHeader {\n\t/// Initializes a packet header for a given session id.\n\tpub const fn new(player_id: PlayerId) -\u003e Self {\n\t\tSelf {\n\t\t\tplayer_id,\n\t\t\tcursor: size_of::\u003cSelf\u003e() as u16,\n\t\t}\n\t}\n\n\t/// The number of bytes actually used in the packet.\n\tpub const fn packet_size(\u0026self) -\u003e usize {\n\t\tself.cursor as usize\n\t}\n\n\t/// The session id that is sending the packet.\n\tpub const fn player_id(\u0026self) -\u003e PlayerId {\n\t\tself.player_id\n\t}\n\n\t/// Gets a byte representation of the header.\n\tpub const fn as_bytes(\u0026self) -\u003e \u0026[u8] {\n\t\t// SAFETY: this is safe because the header is always initialized\n\t\t// during packet construction and the address is within the memory\n\t\t// address of the containing MTBytes buffer.\n\t\tunsafe {\n\t\t\tlet ptr = self as *const Self as *const u8;\n\t\t\tcore::slice::from_raw_parts(ptr, size_of::\u003cSelf\u003e())\n\t\t}\n\t}\n\n\t/// Advances the cursor by a given number of bytes from its current position.\n\tpub fn advance_cursor(\u0026mut self, bytes: usize) {\n\t\tself.cursor += bytes as u16;\n\t}\n\n\t/// Resets the cursor to the start of the packet.\n\tpub fn reset_cursor(\u0026mut self) {\n\t\tself.cursor = size_of::\u003cSelf\u003e() as u16;\n\t}\n\n\t/// Tries to decode a header from a buffer.\n\t/// Fails if the buffer is not large enough to hold the header,\n\t/// or if the header is invalid.\n\t///\n\t/// It is up to the caller to ensure that the buffer is a valid\n\t/// UDP replication packet.\n\tpub const fn peek(buffer: \u0026[u8]) -\u003e Option\u003c\u0026Self\u003e {\n\t\tif buffer.len() \u003c size_of::\u003cSelf\u003e() {\n\t\t\treturn None;\n\t\t}\n\n\t\t// SAFETY: We've already checked that the buffer is large enough\n\t\tSome(unsafe { \u0026*(buffer.as_ptr() as *const Self) })\n\t}\n\n\t/// Tries to decode a header from a mutable buffer.\n\t/// Fails if the buffer is not large enough to hold the header,\n\t/// or if the header is invalid.\n\t///\n\t/// It is up to the caller to ensure that the buffer is a valid\n\t/// UDP replication packet.\n\tpub fn peek_mut(buffer: \u0026mut [u8]) -\u003e Option\u003c\u0026mut Self\u003e {\n\t\tif buffer.len() \u003c size_of::\u003cSelf\u003e() {\n\t\t\treturn None;\n\t\t}\n\n\t\t// SAFETY: We've already checked that the buffer is large enough\n\t\tSome(unsafe { \u0026mut *(buffer.as_mut_ptr() as *mut Self) })\n\t}\n}\n\nimpl std::fmt::Debug for PacketHeader {\n\tfn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n\t\twrite!(f, \"PLayer({}) [{} bytes]\", self.player_id, self.cursor)\n\t}\n}\n\n/// A UDP packet that is sent over the network carrying session updates to and\n/// from the server.\n///\n/// The packet is composed of a header that contains the session id of the\n/// player that is sending the update, followed by a list of datums that\n/// contain the actual updates.\n///\n/// Unlike in UDP replication packets, here datums are of different sizes\n/// and we cannot determine the number of datums without scanning the packet\n/// and decoding the datums. We also cannot determine the capacity of the\n/// packet as it depends on the size of the datums.\n#[derive(Debug, Clone, PartialEq, Eq)]\n#[repr(transparent)]\npub struct Packet {\n\tpayload: MTUBytes,\n}\n\nimpl Packet {\n\t/// Creates a new packet for a given session id ready for storing datums.\n\tpub fn new(player_id: PlayerId) -\u003e Self {\n\t\tlet header = PacketHeader::new(player_id);\n\t\tlet mut payload = MTUBytes([0; MTU_PAYLOAD_LEN]);\n\t\tpayload.0[0..header.cursor as usize].copy_from_slice(header.as_bytes());\n\t\tSelf { payload }\n\t}\n\n\t/// Tries to decode a packet from a buffer.\n\tpub fn header(\u0026self) -\u003e \u0026PacketHeader {\n\t\tPacketHeader::peek(\u0026self.payload.0)\n\t\t\t.expect(\"packet is guaranteed to be large enough to hold a header\")\n\t}\n\n\tpub fn header_mut(\u0026mut self) -\u003e \u0026mut PacketHeader {\n\t\tPacketHeader::peek_mut(\u0026mut self.payload.0)\n\t\t\t.expect(\"packet is guaranteed to be large enough to hold a header\")\n\t}\n\n\t/// Returns the raw bytes of the packet payload.\n\t/// This includes the header and the datums.\n\t///\n\t/// This buffer can be sent over the wire as is.\n\tpub fn as_bytes(\u0026self) -\u003e \u0026[u8] {\n\t\tlet header = self.header();\n\t\t\u0026self.payload.as_ref()[0..header.cursor as usize]\n\t}\n\n\t/// Returns the raw bytes of the packet payload.\n\t/// without the packet header.\n\tpub fn payload(\u0026self) -\u003e \u0026[u8] {\n\t\tlet header = self.header();\n\t\t\u0026self.payload.0[size_of::\u003cPacketHeader\u003e()..header.cursor as usize]\n\t}\n\n\tpub fn cursor(\u0026mut self) -\u003e std::io::Cursor\u003c\u0026mut [u8]\u003e {\n\t\tstd::io::Cursor::new(self.remaining())\n\t}\n\n\t/// Returns true if the packet is empty and does not contain any datums.\n\tpub fn is_empty(\u0026self) -\u003e bool {\n\t\tself.as_bytes().len() \u003c= size_of::\u003cPacketHeader\u003e()\n\t}\n\n\tpub fn write(\u0026mut self, bytes: \u0026[u8]) {\n\t\tlet cursor = self.header().cursor as usize;\n\t\tlet start = cursor;\n\t\tlet end = cursor + bytes.len();\n\t\tself.payload.0[start..end].copy_from_slice(bytes);\n\t\tself.header_mut().advance_cursor(bytes.len());\n\t}\n\n\t/// Returns the remaining bytes in the packet that have not been written to\n\t/// yet. This is where new datums can be written to.\n\tpub fn remaining(\u0026mut self) -\u003e \u0026mut [u8] {\n\t\tlet cursor = self.header().cursor;\n\t\t\u0026mut self.payload.0[cursor as usize..]\n\t}\n}\n\nimpl TryFrom\u003cMTUBytes\u003e for Packet {\n\ttype Error = ();\n\n\tfn try_from(payload: MTUBytes) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tPacketHeader::peek(\u0026payload.0).ok_or(())?; // header check\n\t\tOk(Self { payload })\n\t}\n}\n\nimpl TryFrom\u003c\u0026MTUBytes\u003e for \u0026Packet {\n\ttype Error = ();\n\n\tfn try_from(payload: \u0026MTUBytes) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tPacketHeader::peek(\u0026payload.0).ok_or(())?; // header check\n\t\tOk(unsafe { \u0026*(payload as *const MTUBytes as *const Packet) })\n\t}\n}\n\nimpl TryFrom\u003c\u0026mut MTUBytes\u003e for \u0026Packet {\n\ttype Error = ();\n\n\tfn try_from(payload: \u0026mut MTUBytes) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tPacketHeader::peek(\u0026payload.0).ok_or(())?; // header check\n\t\tOk(unsafe { \u0026*(payload as *const MTUBytes as *const Packet) })\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","client-sdk","src","session","streams","pending.rs"],"content":"//! This module contains logic that maintains the state of pending changes\n//! accumulated between outbound and inbound ticks.\n//!\n//! Users may post changes on every game tick which is often significantly more\n//! frequent that the network tick rate. Those changes are coalesced and deduped\n//! before being sent.\n//!\n//! Also sending pending changes differs between TCP and UDP streams. In TCP we\n//! always send the entire accumulated changes in one go, while in UDP we send\n//! them in chunks that fit in MTU sized packets.\n\nuse {\n\tcrate::{\n\t\tprotocol::{\n\t\t\tattributes::attribute,\n\t\t\tinbound_capnp::{inbound, stream_tick},\n\t\t},\n\t\tAttributeId,\n\t\tEntityId,\n\t\tEventClass,\n\t\tLocalUpdate,\n\t\tMTUBytes,\n\t\tObjectId,\n\t\tPacket,\n\t\tPlayerId,\n\t\tRecipient,\n\t\tTimestamp,\n\t\tTimestampedVal,\n\t\tMAX_SEQUENCE_LENGTH,\n\t},\n\tbytes::{BufMut, Bytes, BytesMut},\n\tcapnp::{\n\t\tmessage::{ReaderSegments, ScratchSpaceHeapAllocator},\n\t\tserialize_packed::write_message,\n\t\tstruct_list,\n\t},\n\tfxhash::FxHashMap,\n\tstd::mem::size_of,\n\ttracing::trace,\n};\n\ntype EntityChanges = FxHashMap\u003cAttributeId, TimestampedVal\u003e;\ntype EntitiesChanges = FxHashMap\u003cEntityId, EntityChanges\u003e;\n\n/// Represents an outgoing event.\nstruct OutboundEvent {\n\tclass: EventClass,\n\tpayload: Box\u003c[u8]\u003e,\n\trecipient: Recipient,\n\ttimestamp: Timestamp,\n}\n\n/// Accumulates changes that are going to be sent in the next tick.\n///\n/// This is used in both udp and tcp streams to accumulate changes\n/// that are going to be sent in the, however in TCP we alwayd write the\n/// entire contents of the accumulated changes in one go, while in UDP\n/// we write in chunks that fit in MTU sized UDP packets.\npub struct PendingOutbound {\n\tplayer_id: PlayerId,\n\tentities: EntitiesChanges,\n\tevents: Vec\u003cOutboundEvent\u003e,\n}\n\nimpl PendingOutbound {\n\tpub fn new(player_id: PlayerId) -\u003e Self {\n\t\tSelf {\n\t\t\tplayer_id,\n\t\t\tevents: Vec::new(),\n\t\t\tentities: EntitiesChanges::default(),\n\t\t}\n\t}\n\n\tpub fn take(\u0026mut self) -\u003e Self {\n\t\tSelf {\n\t\t\tplayer_id: self.player_id,\n\t\t\tevents: std::mem::take(\u0026mut self.events),\n\t\t\tentities: std::mem::take(\u0026mut self.entities),\n\t\t}\n\t}\n\n\t// Is there anything left to send?\n\tpub fn is_empty(\u0026self) -\u003e bool {\n\t\tself.entities.is_empty() \u0026\u0026 self.events.is_empty()\n\t}\n\n\t/// Adds a new update to the pending changes.\n\t/// Updates to the same attribute will be merged and the latest\n\t/// value will be sent.\n\t///\n\t/// Events are not deduplicated and will be sent as is.\n\tpub fn insert(\u0026mut self, update: LocalUpdate, timestamp: Timestamp) {\n\t\tmatch update {\n\t\t\tLocalUpdate::Player(key, value) =\u003e {\n\t\t\t\tself\n\t\t\t\t\t.entities\n\t\t\t\t\t.entry(EntityId::Player(self.player_id))\n\t\t\t\t\t.or_default()\n\t\t\t\t\t.insert(key, (value, timestamp));\n\t\t\t}\n\t\t\tLocalUpdate::Object(object_id, key, value) =\u003e {\n\t\t\t\tself\n\t\t\t\t\t.entities\n\t\t\t\t\t.entry(EntityId::Object(object_id))\n\t\t\t\t\t.or_default()\n\t\t\t\t\t.insert(key, (value, timestamp));\n\t\t\t}\n\t\t\tLocalUpdate::Event(class, payload, recipients) =\u003e {\n\t\t\t\tself.events.push(OutboundEvent {\n\t\t\t\t\tclass,\n\t\t\t\t\tpayload,\n\t\t\t\t\ttimestamp,\n\t\t\t\t\trecipient: recipients,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n}\n\nimpl PendingOutbound {\n\t/// Returns an iterator that packs all changes into\n\t/// MTU sized UDP packets. After the iterator is consumed\n\t/// the changes are removed from this type and it should be\n\t/// empty by the end of the iteration.\n\tpub fn into_packets(self) -\u003e PacketWriterIterator {\n\t\tPacketWriterIterator::new(self)\n\t}\n\n\t/// Write all accumulated changes to a capnp encoded byte buffer.\n\t///\n\t/// This is used by the TCP stream where the size of the message\n\t/// is not a concern.\n\tpub fn into_bytes(mut self) -\u003e Result\u003cBytes, capnp::Error\u003e {\n\t\tlet mut message = capnp::message::Builder::new_default();\n\t\tlet root = message.init_root::\u003cinbound::Builder\u003e();\n\t\tlet mut builder = root.init_stream();\n\n\t\tif let Some(attribs) =\n\t\t\tself.entities.remove(\u0026EntityId::Player(self.player_id))\n\t\t{\n\t\t\tlet mut player = builder.reborrow().init_player();\n\t\t\tplayer.set_id(self.player_id);\n\t\t\tlet count = attribs.len() as u32;\n\t\t\tbuild_attribs(attribs, player.reborrow().init_attributes(count));\n\t\t}\n\n\t\tif !self.entities.is_empty() {\n\t\t\tlet objects_count = self.entities.len();\n\t\t\tlet mut objects = builder.reborrow().init_objects(objects_count as u32);\n\t\t\tfor (ix, (entity, attribs)) in self.entities.drain().enumerate() {\n\t\t\t\tlet EntityId::Object(id) = entity else {\n\t\t\t\t\tunreachable!(\"Player was already handled in the previous block\");\n\t\t\t\t};\n\n\t\t\t\tlet mut object = objects.reborrow().get(ix as u32);\n\t\t\t\tobject.set_id(id);\n\t\t\t\tlet count = attribs.len() as u32;\n\t\t\t\tbuild_attribs(attribs, object.reborrow().init_attributes(count));\n\t\t\t}\n\t\t}\n\n\t\tbuild_events(self.events, builder);\n\n\t\tlet outbuf = BytesMut::new();\n\t\tlet mut writer = outbuf.writer();\n\t\twrite_message(\u0026mut writer, \u0026message)?;\n\t\tOk(writer.into_inner().freeze())\n\t}\n}\n\n/// This iterator consumes a `PendingOutbound` and produces MTU sized packets.\npub struct PacketWriterIterator {\n\tpending: PendingOutbound,\n}\n\nimpl PacketWriterIterator {\n\tpub fn new(pending: PendingOutbound) -\u003e Self {\n\t\tSelf { pending }\n\t}\n\n\t/// Returns the pending changes include the player entity.\n\t///\n\t/// Local changes contain only one (own) player entity and potentially\n\t/// many object entities.\n\tfn take_player(\u0026mut self) -\u003e Option\u003cEntityChanges\u003e {\n\t\tself\n\t\t\t.pending\n\t\t\t.entities\n\t\t\t.remove(\u0026EntityId::Player(self.pending.player_id))\n\t}\n}\n\n/// Produces MTU sized packets\nimpl Iterator for PacketWriterIterator {\n\ttype Item = Packet;\n\n\tfn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n\t\tif self.pending.is_empty() {\n\t\t\treturn None;\n\t\t}\n\n\t\tlet mut scratch = MTUBytes::default();\n\t\tlet mut builder = capnp::message::Builder::new(\n\t\t\tScratchSpaceHeapAllocator::new(scratch.as_mut()),\n\t\t);\n\t\tlet mut tick_builder = builder.init_root::\u003cstream_tick::Builder\u003e();\n\n\t\tif let Some(attribs) = self.take_player() {\n\t\t\tlet player_id = self.pending.player_id;\n\t\t\t// write the pending player changes to the current UDP packet.\n\t\t\t// if we run out of space, we will write only the data that fits\n\t\t\t// create a new packet and push the remaining data back to the\n\t\t\t// pending changes to be picked up in the next iteration.\n\t\t\tlet remaining = build_player(player_id, tick_builder.reborrow(), attribs);\n\n\t\t\tif !remaining.is_empty() {\n\t\t\t\t// we have filled a packet but there is still data remaining\n\t\t\t\t// in the current entity, push it back to the queue, and produce\n\t\t\t\t// a new packet.\n\t\t\t\tself\n\t\t\t\t\t.pending\n\t\t\t\t\t.entities\n\t\t\t\t\t.insert(EntityId::Player(player_id), remaining);\n\n\t\t\t\t// we have filled a packet, return it.\n\t\t\t\treturn Some(build_packet(player_id, builder));\n\t\t\t}\n\t\t}\n\n\t\t// getting here means the we only have object entities left to process\n\t\t// see how much we can fit in the remining space of the current packet.\n\t\tlet entities = std::mem::take(\u0026mut self.pending.entities);\n\t\tself.pending.entities = drain_objects_changes(\n\t\t\ttick_builder.reborrow(), //\n\t\t\tentities,\n\t\t);\n\n\t\tif !self.pending.entities.is_empty() {\n\t\t\t// there are still entities to process that didn't fit in this\n\t\t\t// packet we need to produce another packet to send the remaining data.\n\t\t\treturn Some(build_packet(self.pending.player_id, builder));\n\t\t}\n\n\t\t// we've processed all the entities, now events\n\t\tlet events = std::mem::take(\u0026mut self.pending.events);\n\t\tself.pending.events = drain_events(tick_builder.reborrow(), events);\n\n\t\tif !self.pending.events.is_empty() {\n\t\t\t// there are still events to process that didn't fit in this\n\t\t\t// packet we need to produce another packet to send the remaining data.\n\t\t\treturn Some(build_packet(self.pending.player_id, builder));\n\t\t}\n\n\t\t// we've processed all the entities and events, if there is\n\t\t// something left in the current builder, pack it into a packet\n\t\t// and return it.\n\t\tif !builder.is_empty() {\n\t\t\treturn Some(build_packet(self.pending.player_id, builder));\n\t\t}\n\n\t\t// we've processed all the entities and events, and there is\n\t\t// nothing left in the current builder, we are done.\n\t\tNone\n\t}\n}\n\n/// Composes a final UDP packet from the given capnp message builder.\n/// The returned packet is ready to be sent over the wire.\nfn build_packet(\n\tplayer_id: PlayerId,\n\tbuilder: capnp::message::Builder\u003cScratchSpaceHeapAllocator\u003e,\n) -\u003e Packet {\n\tlet mut builder = builder;\n\tlet mut packet = Packet::new(player_id);\n\tlet mut cursor = packet.cursor();\n\twrite_message(\u0026mut cursor, \u0026builder)\n\t\t.expect(\"failed to serialize message to packet buffer\");\n\tlet position = cursor.position() as usize;\n\tpacket.header_mut().advance_cursor(position);\n\n\ttrace!(\n\t\tsession = player_id,\n\t\t\"sending UDP packet to server: {:?}\",\n\t\tbuilder\n\t\t\t.get_root::\u003cstream_tick::Builder\u003e()\n\t\t\t.unwrap()\n\t\t\t.into_reader()\n\t);\n\n\tpacket\n}\n\n/// populates a tick builder with changes to the player attributes.\n/// Returns the remaining attributes that didn't fit in the packet.\n///\n/// Otherwise if all attributes were successfully packed into the\n/// packet, it will return ControlFlow::Continue(()) signalling that\n/// the packet can still be filled with more data for other entities.\nfn build_player(\n\tplayer_id: PlayerId,\n\tbuilder: stream_tick::Builder,\n\tattribs: EntityChanges,\n) -\u003e EntityChanges {\n\tlet mut attribs = attribs;\n\tlet mut builder = builder;\n\tlet max_attribs = approximate_max_attribs(\u0026builder).min(attribs.len());\n\n\tlet mut remainder = EntityChanges::default();\n\tlet mut this_batch = EntityChanges::default();\n\n\t// split the attributes into two batches, one that fits in the packet\n\t// in this iteration, and the remainder that will be processed in the\n\t// next iteration.\n\tfor (key, value) in attribs.drain() {\n\t\tif this_batch.len() == max_attribs {\n\t\t\tremainder.insert(key, value);\n\t\t} else {\n\t\t\tthis_batch.insert(key, value);\n\t\t}\n\t}\n\n\tlet mut player_builder = builder.reborrow().init_player();\n\tplayer_builder.set_id(player_id);\n\tlet count = this_batch.len() as u32;\n\tbuild_attribs(this_batch, player_builder.init_attributes(count));\n\n\tremainder\n}\n\n/// populates the player update message with the given attributes up to the\n/// maximum size of a packet. Returns the remaining attributes that didn't fit\n/// in the packet.\nfn build_attribs(\n\tattribs: EntityChanges,\n\tbuilder: struct_list::Builder\u003cattribute::Owned\u003e,\n) {\n\tlet mut builder = builder;\n\tfor (ix, (attrib_key, (value, timestamp))) in attribs.into_iter().enumerate()\n\t{\n\t\tlet mut attrib_builder = builder.reborrow().get(ix as u32);\n\t\tattrib_builder.set_key(attrib_key);\n\t\tattrib_builder.set_timestamp(timestamp);\n\t\tvalue.write_to_capnp(\u0026mut attrib_builder.init_value());\n\t}\n}\n\nfn build_events(events: Vec\u003cOutboundEvent\u003e, builder: stream_tick::Builder) {\n\tif events.is_empty() {\n\t\treturn;\n\t}\n\n\tlet mut events_builder = builder.init_events(events.len() as u32);\n\tfor (ix, event) in events.into_iter().enumerate() {\n\t\tlet mut event_builder = events_builder.reborrow().get(ix as u32);\n\t\tevent_builder.set_class(event.class);\n\t\tevent_builder.set_payload(\u0026event.payload);\n\t\tevent_builder.set_timestamp(event.timestamp);\n\t\tmatch event.recipient {\n\t\t\tcrate::Recipient::Radius(radius) =\u003e {\n\t\t\t\tevent_builder.init_recipient().set_radius(radius.value());\n\t\t\t}\n\t\t\tcrate::Recipient::Entity(recipient) =\u003e match recipient {\n\t\t\t\tEntityId::Player(player_id) =\u003e {\n\t\t\t\t\tevent_builder.init_recipient().set_player(player_id);\n\t\t\t\t}\n\t\t\t\tEntityId::Object(object_id) =\u003e {\n\t\t\t\t\tevent_builder.init_recipient().set_object(object_id);\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t}\n}\n\n/// Given pending object changes this function will calculate how many\n/// attributes we can pack into the remaining space in the packet, write those\n/// attributes to the packet and return the remaining attributes that didn't fit\n/// in the packet.\nfn drain_objects_changes(\n\tbuilder: stream_tick::Builder,\n\tchanges: EntitiesChanges,\n) -\u003e EntitiesChanges {\n\tlet mut changes = changes;\n\tlet mut builder = builder;\n\tlet mut drained = EntitiesChanges::default();\n\tlet mut remaining = EntitiesChanges::default();\n\tlet mut remaining_attribs = approximate_max_attribs(\u0026builder);\n\n\tfor (entity, mut attribs) in changes.drain() {\n\t\tif remaining_attribs == 0 {\n\t\t\t// we've reached the maximum number of attributes that can fit\n\t\t\t// in a packet, push the remaining data back to the queue and\n\t\t\t// return the drained data.\n\t\t\tremaining.insert(entity, attribs);\n\t\t} else {\n\t\t\tfor (key, value) in attribs.drain() {\n\t\t\t\tif remaining_attribs == 0 {\n\t\t\t\t\t// we've reached the maximum number of attributes that can fit\n\t\t\t\t\t// in a packet, push the remaining data back to the queue and\n\t\t\t\t\t// return the drained data.\n\t\t\t\t\tremaining.entry(entity).or_default().insert(key, value);\n\t\t\t\t} else {\n\t\t\t\t\tdrained.entry(entity).or_default().insert(key, value);\n\t\t\t\t\tremaining_attribs -= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// now that we have the set of changes that we can fit in the packet,\n\t// write them to the packet.\n\tlet mut objects_builder =\n\t\tbuilder.reborrow().init_objects(drained.len() as u32);\n\n\tfor (ix, (entity, attribs)) in drained.into_iter().enumerate() {\n\t\tlet EntityId::Object(object_id) = entity else {\n\t\t\tcontinue;\n\t\t};\n\n\t\tlet mut object_builder = objects_builder.reborrow().get(ix as u32);\n\t\tobject_builder.set_id(object_id);\n\t\tlet count = attribs.len() as u32;\n\t\tbuild_attribs(attribs, object_builder.init_attributes(count));\n\t}\n\n\tremaining\n}\n\n/// Given a capnp message builder and a list of events, this function will\n/// write as many events as possible to the message builder and return the\n/// remaining events that didn't fit in the message.\nfn drain_events(\n\tbuilder: stream_tick::Builder,\n\tevents: Vec\u003cOutboundEvent\u003e,\n) -\u003e Vec\u003cOutboundEvent\u003e {\n\tlet mut events = events;\n\tlet mut remaining = Vec::new();\n\n\tlet words = builder.total_size().unwrap().word_count;\n\tlet current_size = words as usize * size_of::\u003ccapnp::Word\u003e();\n\tlet mut remaining_space = MAX_WRITE_OFFSET - current_size;\n\n\tlet mut this_batch = Vec::new();\n\tfor event in events.drain(..) {\n\t\tlet event_size = size_of::\u003cEntityId\u003e()\n\t\t\t+ size_of::\u003cEventClass\u003e()\n\t\t\t+ event.payload.len()\n\t\t\t+ size_of::\u003cTimestamp\u003e()\n\t\t\t+ 1;\n\n\t\tif event_size \u003e remaining_space {\n\t\t\t// the event is too large to fit in the current packet\n\t\t\t// push it back to the queue and return the drained events.\n\t\t\tremaining.push(event);\n\t\t} else {\n\t\t\tthis_batch.push(event);\n\t\t\tremaining_space -= event_size;\n\t\t}\n\t}\n\n\t// write the events that fit in this packet to the message builder\n\tbuild_events(this_batch, builder);\n\n\tremaining\n}\n\nconst MAX_PAYLOAD_SIZE: usize = MTUBytes::SIZE;\n// This value was measured by trying the most pessimistic scenario for\n// the structure of the data that contains the most overhead, and that\n// is when we have large attributes with uncompressable values, each\n// attribute belonging to a different object.\nconst MIN_FREE_SPACE: usize = 384;\nconst MAX_WRITE_OFFSET: usize = MAX_PAYLOAD_SIZE - MIN_FREE_SPACE;\n\n/// Returns the maximum number of attributes that can be packed into a\n/// tick message. This is a rough approximation based on the current\n/// tick builder size and the maximum size of a packet.\n///\n/// This function takes into account the most pessimitic scenario where\n/// each attribute is the maximum size possible, each attribute belongs\n/// to a different object.\nfn approximate_max_attribs(builder: \u0026stream_tick::Builder) -\u003e usize {\n\tlet words = builder.total_size().unwrap().word_count;\n\tlet current_size = words as usize * size_of::\u003ccapnp::Word\u003e();\n\n\tlet remaining_space = MAX_WRITE_OFFSET.saturating_sub(current_size);\n\tlet max_attribute_size = size_of::\u003cAttributeId\u003e()\n\t\t+ MAX_SEQUENCE_LENGTH\n\t\t+ size_of::\u003cObjectId\u003e()\n\t\t+ size_of::\u003cTimestamp\u003e()\n\t\t+ 1;\n\tremaining_space / max_attribute_size\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","client-sdk","src","session","streams","tcp.rs"],"content":"use {\n\tsuper::{pending::PendingOutbound, C2SCommand, S2CCommand, SubscriptionId},\n\tcrate::{\n\t\tprotocol::{\n\t\t\tinbound_capnp::inbound,\n\t\t\toutbound_capnp::{event, outbound, stream_world_update},\n\t\t\tBuilderExt,\n\t\t},\n\t\tsession::time::{calculate_offset, calculate_rtt},\n\t\tEntityId,\n\t\tEventClass,\n\t\tLocalTime,\n\t\tPlayerId,\n\t\tQoS,\n\t\tQuery,\n\t\tRemoteUpdate,\n\t\tValue,\n\t},\n\tbytes::BytesMut,\n\tcapnp::{\n\t\tmessage::ReaderOptions,\n\t\tprimitive_list,\n\t\tserialize_packed::read_message,\n\t},\n\tfutures::{SinkExt, StreamExt},\n\tfxhash::FxHashSet,\n\tstd::{ops::ControlFlow, time::Duration},\n\ttokio::{\n\t\tnet::TcpStream,\n\t\tsync::mpsc::{self, error::SendError},\n\t\ttime::{interval, Interval},\n\t},\n\ttokio_util::codec::{Framed, LengthDelimitedCodec},\n};\n\nconst SYNC_TIME_MAX_INTERVAL: Duration = Duration::from_secs(60);\nconst SYNC_TIME_MIN_INTERVAL: Duration = Duration::from_secs(5);\n\npub struct TcpStreams {\n\t/// A channel used to push updates to the server through UDP.\n\tc2s_sender: mpsc::UnboundedSender\u003cC2SCommand\u003e,\n\n\t/// A channel used to receive updates from the server through UDP.\n\ts2c_receiver: Option\u003cmpsc::UnboundedReceiver\u003cS2CCommand\u003e\u003e,\n}\n\nimpl TcpStreams {\n\t/// Instantiates a new TCP Streams object and returns an instance to the\n\t/// object and a receive channel that can be used to watch for updates coming\n\t/// from the server.\n\tpub fn new(\n\t\tplayer_id: PlayerId,\n\t\ttcplink: Framed\u003cTcpStream, LengthDelimitedCodec\u003e,\n\t\tlocal_time: LocalTime,\n\t) -\u003e Self {\n\t\t// client to server\n\t\tlet (c2s_sender, c2s_receiver) = mpsc::unbounded_channel();\n\n\t\t// server to client\n\t\tlet (s2c_sender, s2c_receiver) = mpsc::unbounded_channel();\n\n\t\t// start UDP worker in the background\n\t\ttokio::spawn(event_loop(\n\t\t\tplayer_id,\n\t\t\ttcplink,\n\t\t\tc2s_receiver,\n\t\t\ts2c_sender,\n\t\t\tlocal_time,\n\t\t));\n\n\t\tSelf {\n\t\t\tc2s_sender,\n\t\t\ts2c_receiver: Some(s2c_receiver),\n\t\t}\n\t}\n\n\t/// Sends a Client2Server command to the TCP worker task.\n\tpub(super) fn send(\n\t\t\u0026self,\n\t\tcommand: C2SCommand,\n\t) -\u003e Result\u003c(), SendError\u003cC2SCommand\u003e\u003e {\n\t\tself.c2s_sender.send(command)\n\t}\n\n\t/// Instructs the TCP worker task to send any accumulated changes immediately\n\t/// to the server without waiting for the next tick.\n\tpub(super) fn flush(\u0026self) -\u003e Result\u003c(), SendError\u003cC2SCommand\u003e\u003e {\n\t\tself.c2s_sender.send(C2SCommand::Flush)\n\t}\n\n\t/// Takes the receiver channel from the TCP worker task that is used\n\t/// to receive updates from thw worker task.\n\tpub(super) fn take_receiver(\n\t\t\u0026mut self,\n\t) -\u003e Option\u003cmpsc::UnboundedReceiver\u003cS2CCommand\u003e\u003e {\n\t\tself.s2c_receiver.take()\n\t}\n}\n\n/// The TCP worker loop that handles all the communication between the client\n/// and the server. It communicates with the rest of the client API through\n/// the `C2SCommand` and `S2CCommand` channels.\npub async fn event_loop(\n\tplayer_id: PlayerId,\n\ttcplink: Framed\u003cTcpStream, LengthDelimitedCodec\u003e,\n\tc2s_receiver: mpsc::UnboundedReceiver\u003cC2SCommand\u003e,\n\ts2c_sender: mpsc::UnboundedSender\u003cS2CCommand\u003e,\n\tlocal_time: LocalTime,\n) {\n\tlet mut tcplink = tcplink;\n\tlet mut c2s_receiver = c2s_receiver;\n\n\tlet mut pending = PendingOutbound::new(player_id);\n\tlet mut tick = interval(Duration::from_millis(500));\n\tlet mut sync_time_interval = interval(SYNC_TIME_MAX_INTERVAL);\n\t// use up first tick that resolves immediately\n\tsync_time_interval.tick().await;\n\tlet mut rtt = 0;\n\n\tloop {\n\t\ttokio::select! {\n\t\t\t// Runs when we receive a new TCP frame on the wire. Here we will have to decide\n\t\t\t// whether this is part of the streams API or not and reroute it accordingly.\n\t\t\tmessage = tcplink.next() =\u003e {\n\t\t\t\tif process_incoming_tcp(message, \u0026s2c_sender).is_err() {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Runs periodically and pushes accumulated updates to the server.\n\t\t\t_ = tick.tick() =\u003e {\n\t\t\t\tif send_to_server(\n\t\t\t\t\t\tpending.take(),\n\t\t\t\t\t\t\u0026mut tcplink\n\t\t\t\t\t).await.is_err() {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Handles client Stream API commands\n\t\t\tSome(command) = c2s_receiver.recv() =\u003e {\n\t\t\t\tif handle_client_command(\n\t\t\t\t\t\tcommand,\n\t\t\t\t\t\t\u0026mut pending,\n\t\t\t\t\t\t\u0026mut tick,\n\t\t\t\t\t\t\u0026mut sync_time_interval,\n\t\t\t\t\t\t\u0026mut tcplink\n\t\t\t\t\t).await.is_break() {\n\t\t\t\t\tbreak;\n\t\t\t\t};\n\t\t\t},\n\n\t\t // Sync time with server periodically.\n\t\t\t_ = sync_time_interval.tick() =\u003e {\n\t\t\t\tif sync_time(\u0026local_time, \u0026mut rtt, \u0026mut sync_time_interval, \u0026mut tcplink, \u0026s2c_sender).await.is_err() {\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t}\n}\n\n/// Invoked on every new frame received through TCP.\n///\n/// If the incoming frame is part of the streams API, it will be translated into\n/// a `S2CCommand` and sent to the muxer. Otherwise, it will be forwarded as a\n/// raw message to the TCP consumer.\nfn process_incoming_tcp(\n\tmessage: Option\u003cResult\u003cBytesMut, std::io::Error\u003e\u003e,\n\ts2c_sender: \u0026mpsc::UnboundedSender\u003cS2CCommand\u003e,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n\tlet message = message.transpose()?.ok_or(std::io::Error::new(\n\t\tstd::io::ErrorKind::ConnectionAborted,\n\t\t\"tcp connection dropped\",\n\t))?;\n\tlet message = read_message(message.as_ref(), ReaderOptions::new())?;\n\tmatch message.get_root::\u003coutbound::Reader\u003e()?.which()? {\n\t\toutbound::Which::Stream(Ok(stream)) =\u003e {\n\t\t\tprocess_incoming_stream(stream, s2c_sender)\n\t\t}\n\t\toutbound::Which::TickRate(rate) =\u003e {\n\t\t\tprocess_incoming_tick_rate(rate, s2c_sender)\n\t\t}\n\t\toutbound::Which::SyncTime(Ok(_)) =\u003e Ok(()),\n\t\t_ =\u003e Err(Box::new(std::io::Error::new(\n\t\t\tstd::io::ErrorKind::InvalidData,\n\t\t\tformat!(\n\t\t\t\t\"unexpected message: {:?}\",\n\t\t\t\tmessage.get_root::\u003coutbound::Reader\u003e()\n\t\t\t)\n\t\t\t.as_str(),\n\t\t))),\n\t}\n}\n\n/// Invoked when the server sends us a stream message with updates to the\n/// world state as a response to a registered subscription. This update carries\n/// information about changes in players and objects that are currently relevant\n/// to us and any events that have occurred.\nfn process_incoming_stream(\n\tstream: stream_world_update::Reader,\n\ts2c_sender: \u0026mpsc::UnboundedSender\u003cS2CCommand\u003e,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n\tfor player in stream.get_players()? {\n\t\tfor attribute in player.get_attributes()? {\n\t\t\tlet player_id = player.get_id();\n\t\t\tlet attribute_id = attribute.get_key();\n\t\t\tlet timestamp = attribute.get_timestamp();\n\t\t\tlet value = Value::from_capnp_reader(\u0026attribute.get_value())?;\n\t\t\ts2c_sender.send(S2CCommand::Update(RemoteUpdate::Player(\n\t\t\t\tplayer_id,\n\t\t\t\tattribute_id,\n\t\t\t\tvalue,\n\t\t\t\ttimestamp,\n\t\t\t)))?;\n\t\t}\n\t}\n\n\tfor object in stream.get_objects()? {\n\t\tfor attribute in object.get_attributes()? {\n\t\t\tlet object_id = object.get_id();\n\t\t\tlet attribute_id = attribute.get_key();\n\t\t\tlet timestamp = attribute.get_timestamp();\n\t\t\tlet value = Value::from_capnp_reader(\u0026attribute.get_value())?;\n\t\t\ts2c_sender.send(S2CCommand::Update(RemoteUpdate::Object(\n\t\t\t\tobject_id,\n\t\t\t\tattribute_id,\n\t\t\t\tvalue,\n\t\t\t\ttimestamp,\n\t\t\t)))?;\n\t\t}\n\t}\n\n\tfor event in stream.get_events()? {\n\t\tlet class = event.get_class();\n\t\tlet sender = match event.get_sender().which()? {\n\t\t\tevent::sender::Which::Object(object) =\u003e EntityId::Object(object),\n\t\t\tevent::sender::Which::Player(player) =\u003e EntityId::Player(player),\n\t\t};\n\t\tlet payload = event.get_payload()?;\n\t\tlet timestamp = event.get_timestamp();\n\n\t\ts2c_sender.send(S2CCommand::Update(RemoteUpdate::Event(\n\t\t\tclass,\n\t\t\tpayload.to_vec().into_boxed_slice(),\n\t\t\tsender,\n\t\t\ttimestamp,\n\t\t)))?;\n\t}\n\tOk(())\n}\n\n/// Invoked when the server asks us to adjust our tick rate as\n/// part of the automatic bandwidth management system.\nfn process_incoming_tick_rate(\n\trate: f32,\n\ts2c_sender: \u0026mpsc::UnboundedSender\u003cS2CCommand\u003e,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n\ts2c_sender.send(S2CCommand::AdjustTickRate(rate))?;\n\tOk(())\n}\n\n/// Invoked when the API used wants to create a new Query subscription.\nasync fn subscribe(\n\tid: SubscriptionId,\n\tquery: Query,\n\tqos: QoS,\n\ttcplink: \u0026mut Framed\u003cTcpStream, LengthDelimitedCodec\u003e,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n\tlet message = {\n\t\tlet mut message = capnp::message::Builder::new_default();\n\t\tlet root = message.init_root::\u003cinbound::Builder\u003e();\n\t\tlet mut subscription = root.init_subscribe();\n\n\t\tsubscription.set_subscription_id(id);\n\t\tsubscription.set_interest_radius(query.radius.value());\n\t\tsubscription.set_interval(query.interval.as_millis() as u32);\n\t\tsubscription.set_priority(query.priority.into());\n\t\tsubscription.set_reliable(qos == QoS::Reliable);\n\n\t\tlet mut tags_list =\n\t\t\tsubscription.reborrow().init_tags(query.tags.len() as u32);\n\t\tfor (ix, tag) in query.tags.iter().enumerate() {\n\t\t\ttags_list.reborrow().set(ix as u32, tag.as_str().into());\n\t\t}\n\n\t\tlet populate_events =\n\t\t\t|mut builder: primitive_list::Builder\u003c'_, EventClass\u003e,\n\t\t\t events: FxHashSet\u003cEventClass\u003e| {\n\t\t\t\tfor (ix, event) in events.iter().enumerate() {\n\t\t\t\t\tbuilder.set(ix as u32, *event);\n\t\t\t\t}\n\t\t\t};\n\n\t\tlet events_filter = subscription.reborrow().init_events();\n\n\t\tmatch query.events {\n\t\t\tsuper::EventsFilter::Whitelist(list) =\u003e {\n\t\t\t\tpopulate_events(events_filter.init_whitelist(list.len() as u32), list)\n\t\t\t}\n\t\t\tsuper::EventsFilter::Blacklist(list) =\u003e {\n\t\t\t\tpopulate_events(events_filter.init_blacklist(list.len() as u32), list)\n\t\t\t}\n\t\t};\n\t\tmessage.as_bytes()?\n\t};\n\n\ttcplink.send(message).await?;\n\tOk(())\n}\n\n/// Invoked when the API used wants to remove a subscription.\nasync fn unsubscribe(\n\tid: SubscriptionId,\n\ttcplink: \u0026mut Framed\u003cTcpStream, LengthDelimitedCodec\u003e,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n\tlet message = {\n\t\tlet mut message = capnp::message::Builder::new_default();\n\t\tmessage.init_root::\u003cinbound::Builder\u003e().set_unsubscribe(id);\n\t\tmessage.as_bytes()?\n\t};\n\ttcplink.send(message).await?;\n\n\tOk(())\n}\n\n/// Called periodically when the deadline of an outgoing tick is reached.\n/// It will push all accumulated updates to the local state of the world\n/// to the server.\nasync fn send_to_server(\n\tpending: PendingOutbound,\n\ttcplink: \u0026mut Framed\u003cTcpStream, LengthDelimitedCodec\u003e,\n) -\u003e Result\u003c(), super::Error\u003e {\n\tif pending.is_empty() {\n\t\t// nothing to send, and in TCP we don't need to send\n\t\t// keepalive messages manually.\n\t\treturn Ok(());\n\t}\n\n\tOk(tcplink.send(pending.into_bytes()?).await?)\n}\n\nasync fn handle_client_command(\n\tcommand: C2SCommand,\n\tpending: \u0026mut PendingOutbound,\n\ttick_interval: \u0026mut Interval,\n\tsync_time_interval: \u0026mut Interval,\n\ttcplink: \u0026mut Framed\u003cTcpStream, LengthDelimitedCodec\u003e,\n) -\u003e ControlFlow\u003c()\u003e {\n\tmatch command {\n\t\tC2SCommand::Subscribe { id, query, qos } =\u003e {\n\t\t\tif subscribe(id, query, qos, tcplink).await.is_err() {\n\t\t\t\treturn ControlFlow::Break(());\n\t\t\t}\n\t\t}\n\t\tC2SCommand::Unsubscribe(id) =\u003e {\n\t\t\tif unsubscribe(id, tcplink).await.is_err() {\n\t\t\t\treturn ControlFlow::Break(());\n\t\t\t}\n\t\t}\n\t\tC2SCommand::Disconnect =\u003e return ControlFlow::Break(()),\n\t\tC2SCommand::SetTickInterval(update_interval) =\u003e {\n\t\t\t*tick_interval = tokio::time::interval(update_interval);\n\t\t\ttick_interval\n\t\t\t\t.set_missed_tick_behavior(tokio::time::MissedTickBehavior::Delay);\n\t\t}\n\t\tC2SCommand::SendUpdate { update, timestamp } =\u003e {\n\t\t\tpending.insert(update, timestamp);\n\t\t}\n\t\tC2SCommand::Flush =\u003e {\n\t\t\t// send the packet to the server asap\n\t\t\ttick_interval.reset_immediately();\n\t\t}\n\t\tC2SCommand::SyncTime =\u003e {\n\t\t\t// trigger time sync now\n\t\t\tsync_time_interval.reset_immediately();\n\t\t}\n\t};\n\n\tControlFlow::Continue(())\n}\n\n/// Perform time sync with server.\n/// If server returns another response, we give up the sync and process that\n/// response. Client's time adjustment is performed gradually and each step\n/// is capped. If the calculated time offset (difference between client's and\n/// server's clock times) is bigger than the cap we speed up the inverval\n/// between steps.\nasync fn sync_time(\n\tlocal_time: \u0026LocalTime,\n\trtt: \u0026mut u32,\n\tsync_time_interval: \u0026mut Interval,\n\ttcplink: \u0026mut Framed\u003cTcpStream, LengthDelimitedCodec\u003e,\n\ts2c_sender: \u0026mpsc::UnboundedSender\u003cS2CCommand\u003e,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n\tconst OFFSET_ADJUSTMENT_CAP: u64 = 50;\n\n\tlet message = {\n\t\tlet mut message = capnp::message::Builder::new_default();\n\t\tmessage\n\t\t\t.init_root::\u003cinbound::Builder\u003e()\n\t\t\t.init_sync_time()\n\t\t\t.set_rtt(*rtt);\n\t\tmessage.as_bytes()?\n\t};\n\tlet t0 = local_time.timestamp();\n\ttcplink.send(message).await?;\n\tlet response = tcplink.next().await;\n\tlet t3 = local_time.timestamp();\n\n\tlet response = response.transpose()?.ok_or(std::io::Error::new(\n\t\tstd::io::ErrorKind::ConnectionAborted,\n\t\t\"tcp connection dropped\",\n\t))?;\n\tlet message = read_message(response.as_ref(), ReaderOptions::new())?;\n\tlet t1_2 = match message.get_root::\u003coutbound::Reader\u003e()?.which()? {\n\t\toutbound::Which::SyncTime(Ok(reader)) =\u003e reader.get_timestamp(),\n\t\t_ =\u003e return process_incoming_tcp(Some(Ok(response)), s2c_sender),\n\t};\n\tif let Some(offset) = calculate_offset(t0, t1_2, t1_2, t3) {\n\t\tif local_time.adjust_capped(offset, OFFSET_ADJUSTMENT_CAP) {\n\t\t\tsync_time_interval.reset_after(SYNC_TIME_MIN_INTERVAL);\n\t\t}\n\t}\n\tif let Some(new_rtt) = calculate_rtt(t0, t1_2, t1_2, t3) {\n\t\t*rtt = new_rtt;\n\t}\n\tOk(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","client-sdk","src","session","streams","udp.rs"],"content":"use {\n\tsuper::{\n\t\tpacket::{MTUBytes, Packet},\n\t\tpending::PendingOutbound,\n\t\tC2SCommand,\n\t\tError,\n\t\tS2CCommand,\n\t},\n\tcrate::{\n\t\tprotocol::outbound_capnp::{event, stream_world_update},\n\t\tEntityId,\n\t\tPlayerId,\n\t\tRemoteUpdate,\n\t\tValue,\n\t},\n\tcapnp::{message::ReaderOptions, serialize_packed::read_message},\n\tstd::{\n\t\tnet::{Ipv4Addr, SocketAddr},\n\t\tops::ControlFlow,\n\t\ttime::{Duration, Instant},\n\t},\n\ttokio::{\n\t\tnet::UdpSocket,\n\t\tsync::mpsc::{self, error::SendError},\n\t\ttime::{Interval, MissedTickBehavior},\n\t},\n};\n\npub struct UdpStreams {\n\t/// A channel used to push updates to the server through UDP.\n\tc2s_sender: mpsc::UnboundedSender\u003cC2SCommand\u003e,\n\n\t/// A channel used to receive updates from the server through UDP.\n\ts2c_receiver: Option\u003cmpsc::UnboundedReceiver\u003cS2CCommand\u003e\u003e,\n}\n\nimpl UdpStreams {\n\tpub fn new(\n\t\tserver_addr: SocketAddr,\n\t\tassigned_id: PlayerId,\n\t\tlocal_addr: SocketAddr,\n\t) -\u003e Self {\n\t\t// client to server\n\t\tlet (c2s_sender, c2s_receiver) = mpsc::unbounded_channel();\n\n\t\t// server to client\n\t\tlet (s2c_sender, s2c_receiver) = mpsc::unbounded_channel();\n\n\t\t// start UDP worker in the background\n\t\ttokio::spawn(event_loop(\n\t\t\tassigned_id,\n\t\t\tserver_addr,\n\t\t\tc2s_receiver,\n\t\t\ts2c_sender,\n\t\t\tlocal_addr,\n\t\t));\n\n\t\tSelf {\n\t\t\tc2s_sender,\n\t\t\ts2c_receiver: Some(s2c_receiver),\n\t\t}\n\t}\n\n\tpub(super) fn send(\n\t\t\u0026self,\n\t\tcommand: C2SCommand,\n\t) -\u003e Result\u003c(), SendError\u003cC2SCommand\u003e\u003e {\n\t\tself.c2s_sender.send(command)\n\t}\n\n\t/// Sends the currently accumulated changes immediately without waiting\n\t/// for the next outbound tick.\n\tpub(super) fn flush(\u0026self) -\u003e Result\u003c(), SendError\u003cC2SCommand\u003e\u003e {\n\t\tself.c2s_sender.send(C2SCommand::Flush)\n\t}\n\n\t/// Can be called only once. It takes the receiver that can be used to listen\n\t/// on incoming updates from the UDP worker.\n\tpub(super) fn take_receiver(\n\t\t\u0026mut self,\n\t) -\u003e Option\u003cmpsc::UnboundedReceiver\u003cS2CCommand\u003e\u003e {\n\t\tself.s2c_receiver.take()\n\t}\n}\n\n/// The UDP worker that sends updates to the server and receives updates from\n/// the server. This worker loop communicates with its user through the receiver\n/// returned by `take_receiver`.\npub async fn event_loop(\n\tplayer_id: PlayerId,\n\tserver_addr: SocketAddr,\n\tc2s_receiver: mpsc::UnboundedReceiver\u003cC2SCommand\u003e,\n\ts2c_sender: mpsc::UnboundedSender\u003cS2CCommand\u003e,\n\tlocal_addr: SocketAddr,\n) {\n\tlet mut c2s_receiver = c2s_receiver;\n\n\tlet local_socket = match create_udp_socket(local_addr, server_addr).await {\n\t\tOk(socket) =\u003e socket,\n\t\tErr(e) =\u003e {\n\t\t\ttracing::error!(\"Failed to create UDP socket: {e:?}\");\n\t\t\tlet _ = s2c_sender.send(S2CCommand::Disconnect);\n\t\t\treturn;\n\t\t}\n\t};\n\n\t// how often to send updates to the server\n\tlet update_interval = Duration::from_millis(30);\n\tlet keepalive_interval = Duration::from_secs(10);\n\n\t// the last time we sent or received a packet from the server\n\tlet mut last_exchange = Instant::now();\n\n\t// timer to send updates to the server. This is the outbound udp tickrate\n\tlet mut update_timer = tokio::time::interval(update_interval);\n\tupdate_timer.set_missed_tick_behavior(MissedTickBehavior::Delay);\n\n\t// This timer is used to send keepalive packets to the server for NAT\n\t// punchthrough\n\tlet mut keepalive_timer = tokio::time::interval(keepalive_interval);\n\tkeepalive_timer.set_missed_tick_behavior(MissedTickBehavior::Delay);\n\n\t// buffer to receive incoming packets\n\tlet mut inbound = MTUBytes::default();\n\n\t// Pending updates to send to the server.\n\t// value are accumulated here until the next update interval\n\tlet mut pending = PendingOutbound::new(player_id);\n\n\tloop {\n\t\ttokio::select! {\n\t\t\t_ = update_timer.tick() =\u003e {\n\t\t\t\t// send the packet to the server, if it's empty and we didn't send anything\n\t\t\t\t// for a long time we send an empty keepalive packet to keep the connection alive\n\t\t\t\t// and have NAT punchthrough work, otherwise we don't send anything if there are no updates\n\t\t\t\tif !pending.is_empty() {\n\t\t\t\t\tsend_to_server(\u0026local_socket, pending.take()).await;\n\t\t\t\t\tlast_exchange = Instant::now();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_ = keepalive_timer.tick() =\u003e {\n\t\t\t\t// send a keepalive packet to the server if we haven't sent anything for a while\n\t\t\t\t// to keep the connection alive and have NAT punchthrough work\n\t\t\t\tif last_exchange.elapsed() \u003e keepalive_interval {\n\t\t\t\t\t// send a keepalive packet to the server\n\t\t\t\t\tsend_keepalive(\u0026local_socket, player_id).await;\n\t\t\t\t\tlast_exchange = Instant::now();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// commands from the user of this worker\n\t\t\tSome(command) = c2s_receiver.recv() =\u003e {\n\t\t\t\tif handle_command(command, \u0026mut pending, \u0026mut update_timer).is_break() {\n\t\t\t\t\tbreak; // end the event loop\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// received a packet from the server\n\t\t\tOk((length, _)) = local_socket.recv_from(inbound.as_mut()) =\u003e {\n\t\t\t\tlast_exchange = Instant::now();\n\t\t\t\tif handle_incoming_packet(length, \u0026mut inbound, player_id, \u0026s2c_sender).is_err() {\n\t\t\t\t\tbreak; // protocol violation, disconnect\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlet _ = s2c_sender.send(S2CCommand::Disconnect);\n}\n\nasync fn create_udp_socket(\n\tlocal_tcp_addr: SocketAddr,\n\tserver_addr: SocketAddr,\n) -\u003e Result\u003cUdpSocket, Error\u003e {\n\t// bind the local UDP socket to the same port local port\n\t// that was used for the TCP connection on all interfaces\n\tlet local_udp_addr: SocketAddr =\n\t\t(Ipv4Addr::UNSPECIFIED, local_tcp_addr.port()).into();\n\tlet socket = UdpSocket::bind(local_udp_addr).await?;\n\tsocket.connect(server_addr).await?;\n\tOk(socket)\n}\n\nfn handle_command(\n\tupdate: C2SCommand,\n\tpending: \u0026mut PendingOutbound,\n\tupdate_timer: \u0026mut Interval,\n) -\u003e ControlFlow\u003c()\u003e {\n\tmatch update {\n\t\tC2SCommand::Disconnect =\u003e {\n\t\t\tControlFlow::Break(()) // end the event loop\n\t\t}\n\t\tC2SCommand::SetTickInterval(update_interval) =\u003e {\n\t\t\t*update_timer = tokio::time::interval(update_interval);\n\t\t\tupdate_timer.set_missed_tick_behavior(MissedTickBehavior::Delay);\n\t\t\tControlFlow::Continue(())\n\t\t}\n\n\t\t// accumulate updates and group them by attribute id,\n\t\t// several updates to the same attribute will override older\n\t\t// values until the next update interval\n\t\tC2SCommand::SendUpdate { update, timestamp } =\u003e {\n\t\t\tpending.insert(update, timestamp);\n\t\t\tControlFlow::Continue(())\n\t\t}\n\t\tC2SCommand::Flush =\u003e {\n\t\t\t// send the packet to the server\n\t\t\tupdate_timer.reset_immediately();\n\t\t\tControlFlow::Continue(())\n\t\t}\n\t\tC2SCommand::Subscribe { .. } =\u003e {\n\t\t\tunreachable!(\"Subscription requests always go over TCP\")\n\t\t}\n\t\tC2SCommand::Unsubscribe(_) =\u003e {\n\t\t\tunreachable!(\"Unsubscription requests always go over TCP\")\n\t\t}\n\t\tC2SCommand::SyncTime =\u003e {\n\t\t\tunreachable!(\"Time syncs always go over TCP\")\n\t\t}\n\t}\n}\n\nfn handle_incoming_packet(\n\tlength: usize,\n\tinbound: \u0026mut MTUBytes,\n\tplayer_id: PlayerId,\n\ts2c_sender: \u0026mpsc::UnboundedSender\u003cS2CCommand\u003e,\n) -\u003e Result\u003c(), Error\u003e {\n\t// process the incoming packet inplace from the buffer\n\tlet packet: \u0026Packet = inbound.try_into().map_err(|_| Error::InvalidPacket)?;\n\n\t// ignore packets not meant for us\n\tif packet.header().player_id() != player_id {\n\t\tinbound.clear();\n\t\treturn Err(Error::InvalidUser);\n\t}\n\n\tif packet.header().packet_size() != length {\n\t\t// ignore packets with invalid size\n\t\tinbound.clear();\n\t\treturn Err(Error::InvalidPacket);\n\t}\n\n\tlet message = read_message(packet.payload(), ReaderOptions::new())\n\t\t.map_err(|_| Error::InvalidPacket)?;\n\n\tlet reader = message\n\t\t.get_root::\u003cstream_world_update::Reader\u003e()\n\t\t.map_err(|_| Error::InvalidPacket)?;\n\n\tfor player in reader.get_players()? {\n\t\tlet player_id = player.get_id();\n\t\tfor attrib in player.get_attributes()?.iter() {\n\t\t\tlet attrib_id = attrib.get_key();\n\t\t\tlet timestamp = attrib.get_timestamp();\n\t\t\tlet value = Value::from_capnp_reader(\u0026attrib.get_value())?;\n\t\t\ts2c_sender\n\t\t\t\t.send(S2CCommand::Update(RemoteUpdate::Player(\n\t\t\t\t\tplayer_id, attrib_id, value, timestamp,\n\t\t\t\t)))\n\t\t\t\t.map_err(|_| Error::ConnectionDropped)?;\n\t\t}\n\t}\n\n\tfor object in reader.get_objects()? {\n\t\tlet object_id = object.get_id();\n\t\tfor attrib in object.get_attributes()?.iter() {\n\t\t\tlet attrib_id = attrib.get_key();\n\t\t\tlet timestamp = attrib.get_timestamp();\n\t\t\tlet value = Value::from_capnp_reader(\u0026attrib.get_value())?;\n\t\t\ts2c_sender\n\t\t\t\t.send(S2CCommand::Update(RemoteUpdate::Object(\n\t\t\t\t\tobject_id, attrib_id, value, timestamp,\n\t\t\t\t)))\n\t\t\t\t.map_err(|_| Error::ConnectionDropped)?;\n\t\t}\n\t}\n\n\tfor event in reader.get_events()?.iter() {\n\t\tlet event_class = event.get_class();\n\t\tlet sender = match event.get_sender().which()? {\n\t\t\tevent::sender::Object(obj) =\u003e EntityId::Object(obj),\n\t\t\tevent::sender::Player(player) =\u003e EntityId::Player(player),\n\t\t};\n\t\tlet payload = event.get_payload()?.to_vec();\n\t\tlet timestamp = event.get_timestamp();\n\n\t\ts2c_sender\n\t\t\t.send(S2CCommand::Update(RemoteUpdate::Event(\n\t\t\t\tevent_class,\n\t\t\t\tpayload.into_boxed_slice(),\n\t\t\t\tsender,\n\t\t\t\ttimestamp,\n\t\t\t)))\n\t\t\t.map_err(|_| Error::ConnectionDropped)?;\n\t}\n\n\t// clear the buffer for the next packet\n\tinbound.clear();\n\n\tOk(())\n}\n\n/// Given a snapshot of changes, send them to the server\n/// in one or more packets. if no changes are present, an empty\n/// packet is sent to keep the connection alive.\nasync fn send_to_server(socket: \u0026UdpSocket, pending: PendingOutbound) {\n\tif pending.is_empty() {\n\t\treturn; // nothing to send\n\t}\n\n\t// split the changes into packets and send each packet individually\n\t// over UDP. Packets are at most MTU bytes long so they can be sent\n\t// without worrying about fragmentation.\n\tfor packet in pending.into_packets() {\n\t\tif let Err(e) = socket.send(packet.as_bytes()).await {\n\t\t\ttracing::error!(\"Failed to send udp packet: {e:?}\");\n\t\t}\n\t}\n}\n\n/// Sends an empty keepalive packet to the server to keep the connection alive\n/// and have NAT punchthrough work.\nasync fn send_keepalive(socket: \u0026UdpSocket, player_id: PlayerId) {\n\tif let Err(e) = socket.send(Packet::new(player_id).as_bytes()).await {\n\t\ttracing::error!(\"Failed to send udp keepalive packet: {e:?}\");\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","client-sdk","src","session","time.rs"],"content":"use {\n\tcrate::Timestamp,\n\tstd::{\n\t\tsync::{\n\t\t\tatomic::{AtomicI64, Ordering::Relaxed},\n\t\t\tArc,\n\t\t},\n\t\ttime::{SystemTime, UNIX_EPOCH},\n\t},\n};\n\n#[derive(Debug, Clone, Default)]\npub struct LocalTime {\n\tdelta: Arc\u003cAtomicI64\u003e,\n}\n\nimpl LocalTime {\n\tpub fn timestamp(\u0026self) -\u003e Timestamp {\n\t\tlet delta = self.delta.load(Relaxed);\n\t\tif delta == 0 {\n\t\t\tcurrent_timestamp()\n\t\t} else {\n\t\t\tlet delta_abs = delta.unsigned_abs();\n\t\t\tlet timestamp = current_timestamp();\n\t\t\tif delta.is_positive() {\n\t\t\t\ttimestamp.checked_add(delta_abs)\n\t\t\t} else {\n\t\t\t\ttimestamp.checked_sub(delta_abs)\n\t\t\t}\n\t\t\t.unwrap_or(timestamp)\n\t\t}\n\t}\n\n\tpub fn timestamp_sub(\u0026self, diff: Timestamp) -\u003e Timestamp {\n\t\tlet timestamp = self.timestamp();\n\t\ttimestamp.checked_sub(diff).unwrap_or(timestamp)\n\t}\n\n\t/// Adjust the current delta by `diff` with the `cap`.\n\t/// Returns true if the cap was used.\n\tpub(crate) fn adjust_capped(\u0026self, diff: i64, cap: u64) -\u003e bool {\n\t\tlet delta: i64 =\n\t\t\tdiff.unsigned_abs().min(cap).try_into().unwrap_or_default();\n\t\tif diff.is_positive() {\n\t\t\tself.delta.fetch_add(delta, Relaxed);\n\t\t} else {\n\t\t\tself.delta.fetch_sub(delta, Relaxed);\n\t\t}\n\t\tdiff.abs_diff(delta) \u003e 0\n\t}\n\n\tpub fn move_forward(\u0026self) {\n\t\tself.delta.fetch_add(1, Relaxed);\n\t}\n\n\tpub fn set_delta(\u0026self, val: i64) {\n\t\tself.delta.store(val, Relaxed);\n\t}\n\n\tpub fn delta(\u0026self) -\u003e i64 {\n\t\tself.delta.load(Relaxed)\n\t}\n}\n\nfn current_timestamp() -\u003e Timestamp {\n\tSystemTime::now()\n\t\t.duration_since(UNIX_EPOCH)\n\t\t.unwrap_or_default()\n\t\t.as_millis()\n\t\t.try_into()\n\t\t.unwrap_or_default()\n}\n\n// https://en.wikipedia.org/wiki/Network_Time_Protocol\npub(crate) fn calculate_offset(\n\tt0: Timestamp,\n\tt1: Timestamp,\n\tt2: Timestamp,\n\tt3: Timestamp,\n) -\u003e Option\u003ci64\u003e {\n\tlet t0 = i64::try_from(t0).ok()?;\n\tlet t1 = i64::try_from(t1).ok()?;\n\tlet t2 = i64::try_from(t2).ok()?;\n\tlet t3 = i64::try_from(t3).ok()?;\n\n\t//((t1 - t0) + (t2 - t3)) / 2\n\tt1.checked_sub(t0)?\n\t\t.checked_add(t2.checked_sub(t3)?)?\n\t\t.checked_div(2)\n}\n\n// https://en.wikipedia.org/wiki/Network_Time_Protocol\npub(crate) fn calculate_rtt(\n\tt0: Timestamp,\n\tt1: Timestamp,\n\tt2: Timestamp,\n\tt3: Timestamp,\n) -\u003e Option\u003cu32\u003e {\n\tlet t0 = i64::try_from(t0).ok()?;\n\tlet t1 = i64::try_from(t1).ok()?;\n\tlet t2 = i64::try_from(t2).ok()?;\n\tlet t3 = i64::try_from(t3).ok()?;\n\n\t// (t3 - t0) - (t2 - t1)\n\tt3.checked_sub(t0)?\n\t\t.checked_sub(t2.checked_sub(t1)?)?\n\t\t.try_into()\n\t\t.ok()\n}\n\n#[cfg(test)]\nmod tests {\n\tuse super::*;\n\n\t#[test]\n\tfn test_timestamp_positive_delta() {\n\t\t// given\n\t\tlet local_time = LocalTime::default();\n\t\tlet delta = 5i64;\n\t\tlocal_time.set_delta(delta);\n\n\t\t// when\n\t\tlet sys_timestamp = SystemTime::now()\n\t\t\t.duration_since(UNIX_EPOCH)\n\t\t\t.unwrap_or_default()\n\t\t\t.as_millis() as u64;\n\t\tlet timestamp = local_time.timestamp();\n\n\t\t// then\n\t\tassert!(timestamp - sys_timestamp \u003e= 5);\n\t}\n\n\t#[test]\n\tfn test_timestamp_negative_delta() {\n\t\t// given\n\t\tlet local_time = LocalTime::default();\n\t\tlet delta = -5i64;\n\t\tlocal_time.set_delta(delta);\n\n\t\t// when\n\t\tlet timestamp = local_time.timestamp();\n\n\t\tlet sys_timestamp = SystemTime::now()\n\t\t\t.duration_since(UNIX_EPOCH)\n\t\t\t.unwrap_or_default()\n\t\t\t.as_millis() as u64;\n\n\t\t// then\n\t\tassert!(sys_timestamp - timestamp \u003e= 5);\n\t}\n\n\t#[test]\n\tfn test_timestamp_sub() {\n\t\t// given\n\t\tlet local_time = LocalTime::default();\n\t\tlet age = 5u64;\n\n\t\t// when\n\t\tlet timestamp = local_time.timestamp_sub(age);\n\n\t\tlet sys_timestamp = SystemTime::now()\n\t\t\t.duration_since(UNIX_EPOCH)\n\t\t\t.unwrap_or_default()\n\t\t\t.as_millis() as u64;\n\n\t\t// then\n\t\tassert!(sys_timestamp - timestamp \u003e= 5);\n\t}\n\n\t#[test]\n\tfn test_calculate_offset_and_rtt() {\n\t\t// given\n\t\tlet t1 = 231;\n\t\tlet t2 = 135;\n\t\tlet t3 = 137;\n\t\tlet t4 = 298;\n\n\t\t// when\n\t\tlet offset = calculate_offset(t1, t2, t3, t4);\n\t\tlet rtt = calculate_rtt(t1, t2, t3, t4);\n\n\t\t// then\n\t\tassert_eq!(offset, Some(-128));\n\t\tassert_eq!(rtt, Some(65));\n\t}\n\n\t#[test]\n\tfn test_calculate_offset_and_rtt_u64_overflow() {\n\t\t// given\n\t\tlet t1 = Timestamp::MAX;\n\t\tlet t2 = Timestamp::MAX;\n\t\tlet t3 = Timestamp::MAX;\n\t\tlet t4 = Timestamp::MAX;\n\n\t\t// when\n\t\tlet offset = calculate_offset(t1, t2, t3, t4);\n\t\tlet rtt = calculate_rtt(t1, t2, t3, t4);\n\n\t\t// then\n\t\tassert_eq!(offset, None);\n\t\tassert_eq!(rtt, None);\n\t}\n\n\t#[test]\n\tfn test_calculate_offset_i64_overflow() {\n\t\t// given\n\t\tlet t1 = 0;\n\t\tlet t2 = i64::MAX.try_into().unwrap();\n\t\tlet t3 = i64::MAX.try_into().unwrap();\n\t\tlet t4 = 0;\n\n\t\t// when\n\t\tlet offset = calculate_offset(t1, t2, t3, t4);\n\n\t\t// then\n\t\tassert_eq!(offset, None);\n\t}\n\n\t#[test]\n\tfn test_calculate_rtt_i64_overflow() {\n\t\t// given\n\t\tlet t1 = i64::MAX.try_into().unwrap();\n\t\tlet t2 = 0;\n\t\tlet t3 = i64::MAX.try_into().unwrap();\n\t\tlet t4 = 0;\n\n\t\t// when\n\t\tlet rtt = calculate_rtt(t1, t2, t3, t4);\n\n\t\t// then\n\t\tassert_eq!(rtt, None);\n\t}\n\n\t#[test]\n\tfn test_adjust_capped() {\n\t\t// given\n\t\tlet cap = 10;\n\t\tlet time = LocalTime::default();\n\n\t\t// when\n\t\ttime.adjust_capped(30, cap);\n\t\tassert_eq!(time.delta.load(Relaxed), 10);\n\n\t\ttime.adjust_capped(5, cap);\n\t\tassert_eq!(time.delta.load(Relaxed), 15);\n\n\t\ttime.adjust_capped(-15, cap);\n\t\tassert_eq!(time.delta.load(Relaxed), 5);\n\n\t\ttime.adjust_capped(-9, cap);\n\t\tassert_eq!(time.delta.load(Relaxed), -4);\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","devtools","charsim","src","connection.rs"],"content":"use {\n\tcrate::{controllers::Controller, movement::MovementGenerator},\n\tmetrics::histogram,\n\tquark_client_sdk::Relevance,\n\tstd::time::Instant,\n};\n\npub struct Connection {\n\titeration: usize,\n\tsession: quark_client_sdk::Session,\n\tmovement: Box\u003cdyn MovementGenerator\u003e,\n\tcontroller: Box\u003cdyn Controller\u003e,\n}\n\nimpl Connection {\n\tpub async fn new(\n\t\tserver: String,\n\t\tmovement: Box\u003cdyn MovementGenerator\u003e,\n\t\tcontroller: Box\u003cdyn Controller\u003e,\n\t) -\u003e anyhow::Result\u003cSelf\u003e {\n\t\tlet session = controller\n\t\t\t.setup(quark_client_sdk::Session::start(\u0026server, \u0026[]).await?)?;\n\n\t\tOk(Self {\n\t\t\titeration: 0,\n\t\t\tmovement,\n\t\t\tcontroller,\n\t\t\tsession,\n\t\t})\n\t}\n\n\tpub async fn step(\u0026mut self) -\u003e anyhow::Result\u003c()\u003e {\n\t\tlet Some(next) = self.movement.next() else {\n\t\t\treturn Err(anyhow::anyhow!(\"Character has no next step\"));\n\t\t};\n\n\t\tlet mut tick = self.session.ticks().build();\n\t\tif self.iteration % 10 == 0 {\n\t\t\ttick.set_interest_radius(Relevance::max());\n\t\t} else {\n\t\t\ttick.set_interest_radius(Relevance::new(0.1));\n\t\t}\n\n\t\tlet tick = self.controller.step(tick, \u0026next)?;\n\n\t\tlet start = Instant::now();\n\t\tself.session.ticks().send(tick)?;\n\t\tlet send_duration = start.elapsed();\n\t\tlet response = self.session.ticks().receive().await?;\n\t\tlet receive_duration = start.elapsed() - send_duration;\n\t\tlet rtt = start.elapsed();\n\n\t\thistogram!(\n      \"send_duration\", send_duration.as_micros() as f64, \n      \"@unit\" =\u003e metrics_cloudwatch::Unit::Microseconds);\n\n\t\thistogram!(\n      \"receive_duration\", receive_duration.as_micros() as f64, \n      \"@unit\" =\u003e metrics_cloudwatch::Unit::Microseconds);\n\n\t\tif self.iteration % 10 == 0 {\n\t\t\thistogram!(\n      \"rtt_wide\", rtt.as_micros() as f64, \n      \"@unit\" =\u003e metrics_cloudwatch::Unit::Microseconds);\n\t\t} else {\n\t\t\thistogram!(\n      \"rtt_narrow\", rtt.as_micros() as f64, \n      \"@unit\" =\u003e metrics_cloudwatch::Unit::Microseconds);\n\t\t}\n\n\t\tlet relevant_players_count = response.players()?.count();\n\t\tlet relevant_objects_count = response.objects()?.count();\n\n\t\thistogram!(\n      \"relevant_players_count\", relevant_players_count as f64, \n      \"@unit\" =\u003e metrics_cloudwatch::Unit::Count);\n\n\t\thistogram!(\n      \"relevant_object_count\", relevant_objects_count as f64, \n      \"@unit\" =\u003e metrics_cloudwatch::Unit::Count);\n\n\t\tself.iteration += 1;\n\n\t\tif self.iteration % 100 == 0 {\n\t\t\tprintln!(\"rtt: {}\", humantime::format_duration(rtt));\n\t\t\tprintln!(\"relevant players: {}\", relevant_players_count);\n\t\t\tprintln!(\"relevant objects: {}\", relevant_objects_count);\n\t\t}\n\n\t\tOk(())\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","devtools","charsim","src","controllers","avatar.rs"],"content":"use {\n\tsuper::Controller,\n\tcrate::movement::State,\n\tquark_client_sdk::{\n\t\tAttributeId,\n\t\tObjectId,\n\t\tSession,\n\t\tTickBuilder,\n\t\tValue,\n\t\tWellKnownAttribute,\n\t},\n\tstd::sync::RwLock,\n};\n\npub struct AvatarController {\n\tavatar_id: RwLock\u003cObjectId\u003e,\n}\n\nconst VELOCITY_ATTRIB: u16 = 18;\n\nimpl AvatarController {\n\tpub fn new() -\u003e Self {\n\t\tSelf {\n\t\t\tavatar_id: RwLock::new(0),\n\t\t}\n\t}\n}\n\nimpl Controller for AvatarController {\n\tfn setup(\u0026self, session: Session) -\u003e anyhow::Result\u003cSession\u003e {\n\t\t// When controlling an avatar, we need to create a delegated object that\n\t\t// represents the avatar in the world. This object need to be the delegate\n\t\t// of the player entity in the world.\n\n\t\t{\n\t\t\tlet object_id = session.derive_global_id(1);\n\t\t\t*self.avatar_id.write().unwrap() = object_id;\n\t\t}\n\n\t\tlet mut session = session;\n\t\tlet mut tick = session.ticks().build();\n\n\t\tlet mut player = tick.build_player();\n\t\tlet mut attribs = player.build_attributes(1);\n\t\tattribs.set(\n\t\t\tWellKnownAttribute::Delegate as AttributeId,\n\t\t\tValue::Uint64(*self.avatar_id.read().unwrap()),\n\t\t)?;\n\n\t\tlet mut objects = tick.build_objects(1);\n\t\tlet mut attribs = objects.build_object(*self.avatar_id.read().unwrap());\n\t\tlet mut attribs = attribs.build_attributes(2);\n\t\tattribs.set(\n\t\t\tWellKnownAttribute::OwnerId as AttributeId,\n\t\t\tValue::Uint32(session.id()),\n\t\t)?;\n\t\tattribs.set(\n\t\t\tWellKnownAttribute::ClassId as AttributeId,\n\t\t\tValue::Uint32(2001),\n\t\t)?;\n\n\t\tfutures::executor::block_on(async {\n\t\t\tsession.ticks().send(tick)?;\n\t\t\tanyhow::Result::\u003c()\u003e::Ok(())\n\t\t})?;\n\n\t\tOk(session)\n\t}\n\n\tfn step(\u0026self, tick: TickBuilder, s: \u0026State) -\u003e anyhow::Result\u003cTickBuilder\u003e {\n\t\tlet mut tick = tick;\n\n\t\tlet mut objects = tick.build_objects(1);\n\t\tlet mut object = objects.build_object(*self.avatar_id.read().unwrap());\n\t\tlet mut attribs = object.build_attributes(3);\n\n\t\tattribs.set_vec3(\n\t\t\tWellKnownAttribute::Position as u16,\n\t\t\t(s.position.x, s.position.y, 0.0),\n\t\t)?;\n\n\t\tattribs.set_vec3(VELOCITY_ATTRIB, (s.velocity.x, s.velocity.y, 0.0))?;\n\n\t\tattribs.set_vec3(\n\t\t\tWellKnownAttribute::Rotation as u16,\n\t\t\t(s.rotation.x, s.rotation.y, s.rotation.z),\n\t\t)?;\n\n\t\tOk(tick)\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","devtools","charsim","src","controllers","mod.rs"],"content":"mod avatar;\nmod player;\n\npub use {avatar::AvatarController, player::PlayerController};\n\npub trait Controller: Send + Sync {\n\tfn setup(\n\t\t\u0026self,\n\t\tsession: quark_client_sdk::Session,\n\t) -\u003e anyhow::Result\u003cquark_client_sdk::Session\u003e {\n\t\tOk(session)\n\t}\n\n\tfn step(\n\t\t\u0026self,\n\t\ttick: quark_client_sdk::TickBuilder,\n\t\tstate: \u0026crate::movement::State,\n\t) -\u003e anyhow::Result\u003cquark_client_sdk::TickBuilder\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","devtools","charsim","src","controllers","player.rs"],"content":"use {\n\tsuper::Controller,\n\tcrate::movement::State,\n\tquark_client_sdk::TickBuilder,\n};\n\npub struct PlayerController;\n\nconst VELOCITY_ATTRIB: u16 = 18;\n\nimpl Controller for PlayerController {\n\tfn step(\n\t\t\u0026self,\n\t\ttick: TickBuilder,\n\t\tstate: \u0026State,\n\t) -\u003e anyhow::Result\u003cTickBuilder\u003e {\n\t\tlet mut tick = tick;\n\t\tlet mut player = tick.build_player();\n\t\tlet mut player_builder = player.build_attributes(3);\n\t\tplayer_builder.set_vec3(\n\t\t\tquark_client_sdk::WellKnownAttribute::Position as u16,\n\t\t\t(state.position.x, state.position.y, 0.0),\n\t\t)?;\n\n\t\tplayer_builder\n\t\t\t.set_vec3(VELOCITY_ATTRIB, (state.velocity.x, state.velocity.y, 0.0))?;\n\n\t\tplayer_builder.set_vec3(\n\t\t\tquark_client_sdk::WellKnownAttribute::Rotation as u16,\n\t\t\t(state.rotation.x, state.rotation.y, state.rotation.z),\n\t\t)?;\n\n\t\tOk(tick)\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","devtools","charsim","src","main.rs"],"content":"//! This tool is used to simulate the movement of characters in a 2D space.\n//!\n//! It is used in stress tests to simulate the movement of semi-realistic\n//! characters in a 2D space and the network connectivity patterns a typical\n//! game client would exhibit.\n\nuse {\n\tcrate::{\n\t\tconnection::Connection,\n\t\tcontrollers::Controller,\n\t\tmovement::{ClusterMovement, MovementGenerator},\n\t},\n\tclap::{Parser, ValueEnum},\n\tfutures::{stream::FuturesUnordered, StreamExt},\n\tmetrics_cloudwatch::Resolution,\n\trand::{random, rngs::StdRng, seq::SliceRandom, Rng, SeedableRng},\n\tstd::time::Duration,\n\ttokio::{task::JoinHandle, time::interval},\n};\n\nmod connection;\nmod controllers;\nmod map;\nmod movement;\n\n#[derive(Debug, Clone, ValueEnum)]\nenum Character {\n\tPlayer,\n\tAvatar,\n}\n\n#[derive(Debug, Clone, ValueEnum)]\nenum Movement {\n\tCluster,\n\tRandom,\n}\n\n#[derive(Debug, Parser)]\nstruct Opts {\n\t/// The address of the server to connect to.\n\t#[clap(default_value = \"127.0.0.1\")]\n\tpub server: String,\n\n\t/// The number of characters to simulate.\n\t#[clap(short, long, default_value = \"1\")]\n\tpub count: usize,\n\n\t/// Selectes the mode of the character to simulate.\n\t#[clap(long, value_enum, default_value = \"player\")]\n\tpub character: Character,\n\n\t/// Selects the movement pattern of the character.\n\t#[clap(long, value_enum, default_value = \"cluster\")]\n\tpub movement: Movement,\n\n\t/// Number of regions to that group players.\n\t/// Characters will be evenly distributed across these regions.\n\t/// A character will never leave its region and will only move within its\n\t/// bounds.\n\t#[clap(short, long, default_value = \"1\")]\n\tpub regions: usize,\n\n\t/// Number of updates per second to send to the server.\n\t#[clap(short, long, default_value = \"10\")]\n\tpub frequency: f32,\n\n\t/// Width of the map.\n\t#[clap(long, default_value = \"0.0\")]\n\tpub map_x_min: f32,\n\n\t/// Width of the map.\n\t#[clap(long, default_value = \"1000000.0\")]\n\tpub map_x_max: f32,\n\n\t/// Height of the map.\n\t#[clap(long, default_value = \"0.0\")]\n\tpub map_y_min: f32,\n\n\t/// Height of the map.\n\t#[clap(long, default_value = \"1000000.0\")]\n\tpub map_y_max: f32,\n\n\t/// The namespace to use for CloudWatch metrics.\n\t#[clap(long, default_value = \"quark-stress-client\")]\n\tpub cloudwatch_namespace: String,\n}\n\n#[tokio::main]\nasync fn main() -\u003e anyhow::Result\u003c()\u003e {\n\tlet opts = Opts::parse();\n\tprintln!(\"Character simulator started with: {opts:#?}\");\n\n\tlet regions = map::generate_regions(\n\t\topts.map_x_min..opts.map_x_max,\n\t\topts.map_y_min..opts.map_y_max,\n\t\topts.regions,\n\t);\n\n\tprintln!(\"Regions: {regions:#?}\");\n\n\tmetrics_cloudwatch::Builder::new()\n\t\t.await\n\t\t.send_interval_secs(5)\n\t\t.storage_resolution(Resolution::Second)\n\t\t.cloudwatch_namespace(opts.cloudwatch_namespace.clone())\n\t\t.init_thread(metrics::set_boxed_recorder)?;\n\n\tlet mut rng = StdRng::from_seed(random());\n\tlet mut sessions = FuturesUnordered::\u003cJoinHandle\u003canyhow::Result\u003c()\u003e\u003e\u003e::new();\n\n\tfor _ in 0..opts.count {\n\t\tlet movement: Box\u003cdyn MovementGenerator\u003e = match opts.movement {\n\t\t\tMovement::Cluster =\u003e Box::new(ClusterMovement::new(\n\t\t\t\tregions.choose(\u0026mut rand::thread_rng()).unwrap().clone(),\n\t\t\t\trng.gen_range(300.0..750.0),\n\t\t\t)),\n\t\t\tMovement::Random =\u003e Box::new(movement::RandomMovement),\n\t\t};\n\n\t\tlet controller: Box\u003cdyn Controller\u003e = match opts.character {\n\t\t\tCharacter::Player =\u003e Box::new(controllers::PlayerController),\n\t\t\tCharacter::Avatar =\u003e Box::new(controllers::AvatarController::new()),\n\t\t};\n\n\t\tlet server = opts.server.clone();\n\t\tlet frequency = opts.frequency;\n\n\t\tsessions.push(tokio::spawn(async move {\n\t\t\tlet mut session = Connection::new(server, movement, controller).await?;\n\t\t\tlet mut interval = interval(Duration::from_secs_f32(1.0 / frequency));\n\n\t\t\tloop {\n\t\t\t\tinterval.tick().await;\n\t\t\t\tsession.step().await?;\n\t\t\t}\n\t\t}));\n\t}\n\n\twhile let Some(result) = sessions.next().await {\n\t\tif let Err(e) = result? {\n\t\t\teprintln!(\"Error: {e}\");\n\t\t}\n\t}\n\n\tOk(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","devtools","charsim","src","map.rs"],"content":"use {\n\tglam::Vec2,\n\trand::{thread_rng, Rng},\n\tstd::ops::Range,\n};\n\n/// Represents a path that a character can follow.\n#[derive(Debug, Clone)]\npub struct Path {\n\tpub start: Vec2,\n\tpub end: Vec2,\n}\n\n#[derive(Debug, Clone)]\npub struct Region {\n\tpub centroid: Vec2,\n\tpub radius: f32,\n}\n\n/// Represents a single region of space that a character can move in.\nimpl Region {\n\t// Check if the point is within the radius of the region.\n\tpub fn contains(\u0026self, point: Vec2) -\u003e bool {\n\t\tself.centroid.distance(point) \u003c self.radius\n\t}\n\n\t/// Returns a random point within the region.\n\tpub fn random_point(\u0026self) -\u003e Vec2 {\n\t\tlet theta = rand::random::\u003cf32\u003e() * std::f32::consts::PI * 2.0;\n\t\tlet radius = rand::random::\u003cf32\u003e() * self.radius;\n\t\tVec2::new(\n\t\t\tself.centroid.x + radius * theta.cos(),\n\t\t\tself.centroid.y + radius * theta.sin(),\n\t\t)\n\t}\n\n\tpub fn random_path(\u0026self) -\u003e Path {\n\t\tPath {\n\t\t\tstart: self.random_point(),\n\t\t\tend: self.random_point(),\n\t\t}\n\t}\n\n\tpub fn overlaps(\u0026self, other: \u0026Region) -\u003e bool {\n\t\tself.centroid.distance(other.centroid) \u003c self.radius + other.radius\n\t}\n}\n\npub fn generate_regions(\n\twidth: Range\u003cf32\u003e,\n\theight: Range\u003cf32\u003e,\n\tcount: usize,\n) -\u003e Vec\u003cRegion\u003e {\n\tlet x_len = width.end - width.start;\n\tlet y_len = height.end - height.start;\n\tlet cell_size = x_len.min(y_len) / count as f32;\n\tlet region_radius = cell_size / 2.0;\n\n\tlet mut regions = Vec::\u003cRegion\u003e::with_capacity(count);\n\n\twhile regions.len() \u003c count {\n\t\tlet cell_x = thread_rng().gen_range(\n\t\t\twidth.start..(width.end - region_radius), //\n\t\t);\n\t\tlet cell_y = thread_rng().gen_range(\n\t\t\theight.start..(height.end - region_radius), //\n\t\t);\n\n\t\tlet centroid = Vec2::new(cell_x, cell_y);\n\t\tlet radius = thread_rng().gen_range(cell_size / 10.0..cell_size / 2.0);\n\n\t\tlet proposal = Region { centroid, radius };\n\t\tif regions.iter().all(|r| !r.overlaps(\u0026proposal)) {\n\t\t\tregions.push(proposal);\n\t\t}\n\t}\n\n\tregions\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","devtools","charsim","src","movement","cluster.rs"],"content":"use {\n\tsuper::{MovementGenerator, State},\n\tcrate::map::{Path, Region},\n\tglam::{Vec2, Vec3},\n\tstd::time::Instant,\n};\n\n#[derive(Debug, Clone)]\npub struct ClusterMovement {\n\tregion: Region,\n\tpath: Path,\n\tspeed: f32,\n\tstate: State,\n\tlast_update: Instant,\n}\n\nimpl ClusterMovement {\n\tpub fn new(region: Region, speed: f32) -\u003e Self {\n\t\tlet path = region.random_path();\n\t\tlet state = State {\n\t\t\tposition: path.start,\n\t\t\trotation: rotation(path.start, path.end),\n\t\t\tvelocity: Vec2::new(0.0, 0.0),\n\t\t};\n\t\tlet last_update = Instant::now();\n\n\t\tSelf {\n\t\t\tregion,\n\t\t\tpath,\n\t\t\tspeed,\n\t\t\tstate,\n\t\t\tlast_update,\n\t\t}\n\t}\n\n\t/// Check if the character has reached the end of the path\n\t/// If the character has reached the end of the path, generate a new path\n\tpub fn reached_end(\u0026self, dt: f32) -\u003e bool {\n\t\tlet distance = self.state.position.distance(self.path.end);\n\t\tlet within_region = self.region.contains(self.state.position);\n\t\t!within_region || distance \u003c self.speed * dt\n\t}\n}\n\n/// yields a new state for the character along\n/// the path it is following. When it reaches a the end of the path\n/// it will generate a new random path.\nimpl Iterator for ClusterMovement {\n\ttype Item = State;\n\n\tfn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n\t\tlet dt = self.last_update.elapsed().as_secs_f32();\n\n\t\tif self.reached_end(dt) {\n\t\t\tlet next_path = Path {\n\t\t\t\tstart: self.state.position,\n\t\t\t\tend: self.region.random_point(),\n\t\t\t};\n\n\t\t\tself.path = next_path;\n\t\t}\n\n\t\tlet direction = (self.path.end - self.state.position).normalize();\n\t\tself.state.rotation = rotation(self.state.position, self.path.end);\n\t\tself.state.velocity = direction * self.speed;\n\t\tself.state.position += self.state.velocity * dt;\n\t\tself.last_update = Instant::now();\n\n\t\tSome(self.state.clone())\n\t}\n}\n\nfn rotation(from: Vec2, to: Vec2) -\u003e Vec3 {\n\tlet direction = (to - from).normalize();\n\tlet yaw = direction.y.atan2(direction.x) * 180.0 / std::f32::consts::PI;\n\tlet pitch = 0.0;\n\tlet roll = 0.0;\n\n\tVec3::new(pitch, yaw, roll)\n}\n\nimpl MovementGenerator for ClusterMovement {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","devtools","charsim","src","movement","mod.rs"],"content":"use glam::{Vec2, Vec3};\n\nmod cluster;\nmod random;\n\npub use {cluster::ClusterMovement, random::RandomMovement};\n\n#[derive(Debug, Clone)]\npub struct State {\n\tpub position: Vec2,\n\tpub rotation: Vec3,\n\tpub velocity: Vec2,\n}\n\npub trait MovementGenerator: Iterator\u003cItem = State\u003e + Send + Sync {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","devtools","charsim","src","movement","random.rs"],"content":"use super::{MovementGenerator, State};\n\n#[derive(Debug, Clone)]\npub struct RandomMovement;\n\nimpl Iterator for RandomMovement {\n\ttype Item = State;\n\n\tfn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n\t\ttodo!()\n\t}\n}\n\nimpl MovementGenerator for RandomMovement {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","devtools","peek","src","main.rs"],"content":"//! This devtool is used to peek at the state of the server in a given location.\n//!\n//! Call this tool with the address of the server and x,y coordinates and it\n//! will print out all relevant players and objects and all their properties\n//! to the command line.\n//!\n//! Use this tool to debug objects state on the server and very property\n//! propagation.\n\nuse {\n\tquark_client_sdk::{Relevance, Session, WellKnownAttribute},\n\tstd::env::args,\n};\n\n#[tokio::main]\nasync fn main() -\u003e anyhow::Result\u003c()\u003e {\n\tlet (server_addr, x, y) = match (args().nth(1), args().nth(2), args().nth(3))\n\t{\n\t\t(Some(addr), Some(x), Some(y)) =\u003e {\n\t\t\t(addr, x.parse::\u003cf32\u003e().unwrap(), y.parse::\u003cf32\u003e().unwrap())\n\t\t}\n\t\t_ =\u003e {\n\t\t\teprintln!(\n\t\t\t\t\"Usage: {} \u003cserver-addr\u003e \u003clocation-x\u003e \u003clocation-y\u003e\",\n\t\t\t\targs().next().unwrap()\n\t\t\t);\n\t\t\treturn Ok(());\n\t\t}\n\t};\n\n\tlet mut session = Session::start(\u0026server_addr, \u0026[]).await?;\n\n\tlet mut tick = session.ticks().build();\n\ttick.set_interest_radius(Relevance::max());\n\tlet mut player = tick.build_player();\n\tlet mut player_builder = player.build_attributes(1);\n\tplayer_builder.set_vec3(WellKnownAttribute::Position as u16, (x, y, 0.0))?;\n\tsession.ticks().send(tick)?;\n\n\tlet response = session.ticks().receive().await?;\n\n\tprintln!(\"{} players: \", response.players()?.count());\n\tfor player in response.players()? {\n\t\tprintln!(\"\\tplayer: {}\", player.id());\n\t\tfor attrib in player.attribs() {\n\t\t\tprintln!(\"\\t\\t{:?}:\\t {:?}\", attrib.key, attrib.value);\n\t\t}\n\t}\n\n\tprintln!(\"{} objects: \", response.objects()?.count());\n\tfor object in response.objects()? {\n\t\tprintln!(\"\\tobject: {}\", object.id());\n\t\tfor attrib in object.attribs() {\n\t\t\tprintln!(\"\\t\\t{: \u003e6}:\\t {:?}\", attrib.key, attrib.value);\n\t\t}\n\t}\n\n\tOk(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","devtools","stress","src","main.rs"],"content":"use {\n\tquark_client_sdk::{PlayerId, Session},\n\tstd::{\n\t\tcollections::HashMap,\n\t\tsync::{Arc, RwLock},\n\t},\n};\n\nmod test_case1;\nmod test_case10;\nmod test_case11;\nmod test_case12;\nmod test_case13;\nmod test_case14;\nmod test_case2;\nmod test_case20;\nmod test_case3;\nmod test_case4;\nmod test_case5;\nmod test_case6;\nmod test_case7;\nmod test_case9;\n\nuse {\n\tclap::Parser,\n\ttest_case1::test_case1,\n\ttest_case10::test_case10,\n\ttest_case11::test_case11,\n\ttest_case12::test_case12,\n\ttest_case2::test_case2,\n\ttest_case20::test_case20,\n\ttest_case3::test_case3,\n\ttest_case4::test_case4,\n\ttest_case5::test_case5,\n\ttest_case6::test_case6,\n\ttest_case7::test_case7,\n\ttest_case9::test_case9,\n\tthiserror::Error,\n\ttokio::task::JoinSet,\n};\n\n#[derive(Debug, Parser, Clone)]\npub struct Settings {\n\t#[clap(long, short, value_parser, num_args = 1.., value_delimiter = ' ')]\n\tserver_addr: Vec\u003cString\u003e,\n\n\t#[clap(long, short = 'c', default_value = \"1\")]\n\tplayer_count: usize,\n\n\t#[clap(long, short = 'f', default_value = \"1\")]\n\ttick_frequency: f32,\n\n\t#[clap(long, short, default_value = \"10\")]\n\tobject_count: u32,\n\n\t#[clap(long, short, default_value = \"1\")]\n\ttest_case: u32,\n\n\t#[clap(long, default_value = \"0.0\")]\n\trange_min: f32,\n\n\t#[clap(long, default_value = \"1000000.0\")]\n\trange_max: f32,\n\n\t#[clap(long, default_value = \"3.0\")]\n\tspeed_min: f32,\n\n\t#[clap(long, default_value = \"10.0\")]\n\tspeed_max: f32,\n\n\t#[clap(long, default_value = \"0.5\")]\n\tdelta_pos_x: f32,\n\n\t#[clap(long, default_value = \"0.5\")]\n\tdelta_pos_y: f32,\n\n\t#[clap(long, default_value = \"0.5\")]\n\tdelta_pos_z: f32,\n\n\t#[clap(long, default_value = \"0\")]\n\trun_period: u32,\n\n\t#[clap(long, default_value = \"-1\")]\n\trun_break: i32,\n\n\t#[clap(long, default_value = \"0\")]\n\trun_loop: u32,\n\n\t#[clap(long, short, default_value = \"0.2\")]\n\tinterest_radius: f32,\n\n\t#[clap(long, default_value = \"2000\")] // [ms]\n\ttimeout: u32,\n\n\t#[clap(long, default_value = \"1500\")] // [ms]\n\tdisconnect_timeout: u64,\n\n\t#[clap(short, long, default_value = \"0\")]\n\tverbose: u32,\n\n\t#[clap(long, default_value = \"false\")]\n\tpub enable_tls: bool,\n\n\t#[clap(long, default_value = \"\")]\n\tpub listener_mode: String,\n\n\t#[clap(long, default_value = \"\")]\n\tpub sender_mode: String,\n\n\t#[clap(long)]\n\tpub metrics_namespace: Option\u003cString\u003e,\n\n\t#[clap(long, default_value = \"0.0.0.0:7070\")]\n\theartbeat_listen_addr: String,\n\n\t#[clap(long, default_value = \"5\")]\n\tpub heartbeat_period: u32,\n\n\t#[clap(long, default_value = \"0.1\")]\n\tpub heartbeat_tolerance: f32,\n\n\t#[clap(long, default_value = \"10\")]\n\tpub heartbeat_timeout: u64,\n\n\t#[clap(long, short = 'r', default_value = \"1000\")]\n\trelevance_distance: f32,\n}\n\n#[derive(Debug, Error)]\npub enum TestError {\n\t#[error(\"player state does not match to any existing player\")]\n\tPlayerStatePositionMismatch,\n}\n\npub enum PlayerAttribute {\n\tTimestamp = 20,\n\tIsAlive = 21,\n\tHealth = 22,\n\tVelocity = 23,\n\tSpeed = 24,\n\tMana = 25,\n\tStrength = 26,\n\tCurrency = 27,\n\tWealth = 28,\n\tAppearance = 29,\n\tDamage = 30,\n\tArmor = 31,\n\tRelevancePoint2D = 32,\n\tRelevancePoint3D = 33,\n\tPositionHealth = 34,\n\tPositionDamage = 35,\n}\n\npub type Rotation = (f32, f32, f32);\npub type Position = (f32, f32, f32);\npub type SlotId = u32;\n\n#[derive(Default, Debug, Clone, Copy, PartialEq)]\npub struct PlayerState {\n\trotation: Rotation,\n\tposition: Position,\n}\n\n#[tokio::main]\nasync fn main() -\u003e anyhow::Result\u003c()\u003e {\n\tlet settings = Settings::parse();\n\tlet mut workers = JoinSet::new();\n\tlet states = Arc::new(RwLock::new(HashMap::\u003cPlayerId, PlayerState\u003e::new()));\n\n\t// make sure we can have enough file descriptors\n\t#[cfg(not(windows))]\n\trlimit::setrlimit(rlimit::Resource::NOFILE, 65535, 65535)?;\n\n\tprintln!(\n\t\t\"stress test is running with scenario {0}\",\n\t\tsettings.test_case\n\t);\n\n\tif let Some(ref metrics_namespace) = settings.metrics_namespace {\n\t\tmetrics_cloudwatch::Builder::new()\n\t\t\t.await\n\t\t\t.send_interval_secs(5)\n\t\t\t.storage_resolution(metrics_cloudwatch::Resolution::Second)\n\t\t\t.cloudwatch_namespace(metrics_namespace.clone())\n\t\t\t.init_thread(metrics::set_boxed_recorder)?;\n\t}\n\n\tfor idx in 0..settings.player_count {\n\t\tmatch settings.test_case {\n\t\t\t1 =\u003e workers.spawn(test_case1(\n\t\t\t\tidx as SlotId,\n\t\t\t\tsettings.clone(),\n\t\t\t\tstates.clone(),\n\t\t\t)),\n\t\t\t2 =\u003e workers.spawn(test_case2(idx, settings.clone(), states.clone())),\n\t\t\t3 =\u003e workers.spawn(test_case3(\n\t\t\t\tidx as SlotId,\n\t\t\t\tsettings.clone(),\n\t\t\t\tstates.clone(),\n\t\t\t)),\n\t\t\t4 =\u003e workers.spawn(test_case4(\n\t\t\t\tidx as SlotId,\n\t\t\t\tsettings.clone(),\n\t\t\t\tstates.clone(),\n\t\t\t)),\n\t\t\t5 =\u003e workers.spawn(test_case5(\n\t\t\t\tidx as SlotId,\n\t\t\t\tsettings.clone(),\n\t\t\t\tstates.clone(),\n\t\t\t)),\n\t\t\t6 =\u003e workers.spawn(test_case6(\n\t\t\t\tidx as SlotId,\n\t\t\t\tsettings.clone(),\n\t\t\t\tstates.clone(),\n\t\t\t)),\n\t\t\t7 =\u003e workers.spawn(test_case7(\n\t\t\t\tidx as SlotId,\n\t\t\t\tsettings.clone(),\n\t\t\t\tstates.clone(),\n\t\t\t)),\n\t\t\t9 =\u003e workers.spawn(test_case9(\n\t\t\t\tidx as SlotId,\n\t\t\t\tsettings.clone(),\n\t\t\t\tstates.clone(),\n\t\t\t)),\n\t\t\t10 =\u003e workers.spawn(test_case10(\n\t\t\t\tidx as SlotId,\n\t\t\t\tsettings.clone(),\n\t\t\t\tstates.clone(),\n\t\t\t)),\n\t\t\t11 =\u003e workers.spawn(test_case11(\n\t\t\t\tidx as SlotId,\n\t\t\t\tsettings.clone(),\n\t\t\t\tstates.clone(),\n\t\t\t)),\n\t\t\t12 =\u003e workers.spawn(test_case12(\n\t\t\t\tidx as SlotId,\n\t\t\t\tsettings.clone(),\n\t\t\t\tstates.clone(),\n\t\t\t)),\n\t\t\t13 =\u003e workers.spawn(test_case13::test_case13(\n\t\t\t\tidx as SlotId,\n\t\t\t\tsettings.clone(),\n\t\t\t\tstates.clone(),\n\t\t\t)),\n\t\t\t// Only one client will be spawned for test case 14\n\t\t\t14 =\u003e {\n\t\t\t\tworkers.spawn(test_case14::test_case14(\n\t\t\t\t\tidx as SlotId,\n\t\t\t\t\tsettings.clone(),\n\t\t\t\t\tstates.clone(),\n\t\t\t\t));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t20 =\u003e workers.spawn(test_case20(settings.clone())),\n\t\t\tc =\u003e unimplemented!(\"test case {c} not implemented\"),\n\t\t};\n\t}\n\n\t// error counter which is used for counting threads which report error\n\t// this variable is used for making decision about returned test status\n\tlet mut error_counter = 0u32;\n\twhile let Some(task) = workers.join_next().await {\n\t\tmatch task {\n\t\t\tOk(task) =\u003e match task {\n\t\t\t\tOk(_) =\u003e {}\n\t\t\t\tErr(e) =\u003e {\n\t\t\t\t\tprintln!(\"{:?}\", e);\n\t\t\t\t\terror_counter += 1;\n\t\t\t\t\tworkers.abort_all();\n\t\t\t\t}\n\t\t\t},\n\t\t\tErr(_) =\u003e {\n\t\t\t\terror_counter += 1;\n\t\t\t\tworkers.abort_all();\n\t\t\t}\n\t\t}\n\t}\n\n\tif error_counter \u003e 0 {\n\t\tErr(anyhow::anyhow!(\"test case has been terminated with error\"))\n\t} else {\n\t\tprintln!(\"completed successfully\");\n\t\tOk(())\n\t}\n}\n\npub async fn create_session(\n\tserver_addr: \u0026str,\n\tauth: \u0026[u8],\n) -\u003e anyhow::Result\u003cSession\u003e {\n\tloop {\n\t\tmatch Session::start(server_addr, auth).await {\n\t\t\tOk(session) =\u003e return Ok(session),\n\t\t\tErr(e) =\u003e {\n\t\t\t\teprintln!(\"Failed to start session: {}\", e);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","devtools","stress","src","test_case1.rs"],"content":"use {\n\tcrate::{create_session, PlayerAttribute, PlayerState, Settings, SlotId},\n\tmetrics::histogram,\n\tquark_client_sdk::{\n\t\tAttributeId,\n\t\tOutboundEvent,\n\t\tPlayerId,\n\t\tRecipient,\n\t\tRelevance,\n\t\tValue,\n\t\tWellKnownAttribute,\n\t},\n\trand::Rng,\n\tstd::{\n\t\tcollections::{hash_map::Entry, HashMap},\n\t\tsync::{\n\t\t\tatomic::{AtomicUsize, Ordering},\n\t\t\tArc,\n\t\t\tRwLock,\n\t\t},\n\t\ttime::{Duration, SystemTime, UNIX_EPOCH},\n\t},\n};\n\nstatic mut CONNECTIONS_COUNT: AtomicUsize = AtomicUsize::new(0);\n\n/// ### Test Case 1: Player Movement Simulation (Random point)\n///\n/// Description:\n/// This scenario involves sending configurable player data to the server\n/// without waiting for or processing a response. It simulates player movement\n/// based on the Randomly point to point.\n\npub async fn test_case1(\n\tindex: SlotId,\n\tsettings: Settings,\n\tstates: Arc\u003cRwLock\u003cHashMap\u003cPlayerId, PlayerState\u003e\u003e\u003e,\n) -\u003e anyhow::Result\u003c()\u003e {\n\tlet _ = states;\n\tlet auth: \u0026[u8] = \u0026[];\n\tlet server_index = index % settings.server_addr.len() as u32;\n\tlet mut session =\n\t\tcreate_session(\u0026settings.server_addr[server_index as usize], auth).await?;\n\tlet wait_time =\n\t\tDuration::from_millis((1000.0f32 / settings.tick_frequency) as u64);\n\n\tlet mut counter = 0;\n\tunsafe { CONNECTIONS_COUNT.fetch_add(1, Ordering::Relaxed) };\n\n\tif settings.verbose \u003e 0 {\n\t\tprintln!(\n\t\t\t\"[server #{}, connection #{}] -\u003e session id: {}\",\n\t\t\tsettings.server_addr[server_index as usize],\n\t\t\tunsafe { CONNECTIONS_COUNT.load(Ordering::Relaxed) },\n\t\t\tsession.id(),\n\t\t);\n\t}\n\n\tloop {\n\t\ttokio::time::sleep(wait_time).await;\n\n\t\tcounter += 1;\n\n\t\tlet relevance = match counter % 5 == 0 {\n\t\t\ttrue =\u003e Relevance::new(settings.interest_radius),\n\t\t\tfalse =\u003e Relevance::new(0.60),\n\t\t};\n\n\t\tlet mut tick = session.ticks().build();\n\t\ttick.set_interest_radius(relevance);\n\t\tlet current_timestamp = current_microseconds_since_epoch()?;\n\n\t\ttick\n\t\t\t.build_player()\n\t\t\t.build_attributes(2)\n\t\t\t.set_vec3(\n\t\t\t\tWellKnownAttribute::Position as AttributeId,\n\t\t\t\t(\n\t\t\t\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max),\n\t\t\t\t),\n\t\t\t)\n\t\t\t.unwrap()\n\t\t\t.set_uint64(PlayerAttribute::Timestamp as AttributeId, current_timestamp)\n\t\t\t.unwrap();\n\n\t\t// scoped objects\n\t\t{\n\t\t\tlet mut objects = tick.build_objects(2);\n\n\t\t\tobjects\n\t\t\t\t.build_object(session.derive_global_id(1))\n\t\t\t\t.build_attributes(2)\n\t\t\t\t.set_vec3(\n\t\t\t\t\tWellKnownAttribute::Position as AttributeId,\n\t\t\t\t\t(\n\t\t\t\t\t\trand::thread_rng()\n\t\t\t\t\t\t\t.gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\t\trand::thread_rng()\n\t\t\t\t\t\t\t.gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\t\trand::thread_rng()\n\t\t\t\t\t\t\t.gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t\t.unwrap()\n\t\t\t\t.set_vec3(\n\t\t\t\t\tWellKnownAttribute::Rotation as AttributeId,\n\t\t\t\t\t(\n\t\t\t\t\t\trand::thread_rng()\n\t\t\t\t\t\t\t.gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\t\trand::thread_rng()\n\t\t\t\t\t\t\t.gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\t\trand::thread_rng()\n\t\t\t\t\t\t\t.gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t\t.unwrap();\n\n\t\t\tobjects\n\t\t\t\t.build_object(session.derive_global_id(2))\n\t\t\t\t.build_attributes(2)\n\t\t\t\t.set_vec3(\n\t\t\t\t\tWellKnownAttribute::Position as AttributeId,\n\t\t\t\t\t(\n\t\t\t\t\t\trand::thread_rng()\n\t\t\t\t\t\t\t.gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\t\trand::thread_rng()\n\t\t\t\t\t\t\t.gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\t\trand::thread_rng()\n\t\t\t\t\t\t\t.gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t\t.unwrap()\n\t\t\t\t.set_vec3(\n\t\t\t\t\tWellKnownAttribute::Rotation as AttributeId,\n\t\t\t\t\t(\n\t\t\t\t\t\trand::thread_rng()\n\t\t\t\t\t\t\t.gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\t\trand::thread_rng()\n\t\t\t\t\t\t\t.gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\t\trand::thread_rng()\n\t\t\t\t\t\t\t.gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t\t.unwrap();\n\t\t}\n\n\t\t// scoped events\n\t\t{\n\t\t\tlet mut events = tick.build_events(2);\n\n\t\t\tevents.push_event(\u0026OutboundEvent {\n\t\t\t\tclass: 20002,\n\t\t\t\tpayload: rand::thread_rng().gen::\u003c[u8; 32]\u003e()[..].try_into().unwrap(),\n\t\t\t\trecipient: Recipient::default(),\n\t\t\t});\n\n\t\t\tevents.push_event(\u0026OutboundEvent {\n\t\t\t\tclass: 20003,\n\t\t\t\tpayload: rand::thread_rng().gen::\u003c[u8; 32]\u003e()[..].try_into().unwrap(),\n\t\t\t\trecipient: Recipient::default(),\n\t\t\t});\n\t\t}\n\n\t\tlet start = std::time::Instant::now();\n\t\tsession.ticks().send(tick)?;\n\t\tlet response = session.ticks().receive().await?;\n\t\tlet elapsed = start.elapsed();\n\t\tlet msg_rcv_timestamp = current_microseconds_since_epoch()?;\n\t\tlet players = response.players()?;\n\t\tlet mut player_time: HashMap\u003cu32, (u64, u64)\u003e = HashMap::new();\n\n\t\tfor player in players {\n\t\t\tlet player_server = player.id() % settings.server_addr.len() as u32;\n\t\t\tlet attribs = player.attribs();\n\t\t\tfor attrib in attribs {\n\t\t\t\tif attrib.key == PlayerAttribute::Timestamp as AttributeId {\n\t\t\t\t\tlet value = attrib.value.clone();\n\t\t\t\t\tlet msg_duration = match value {\n\t\t\t\t\t\tValue::Uint64(send_timestamp) =\u003e msg_rcv_timestamp - send_timestamp,\n\t\t\t\t\t\t_ =\u003e {\n\t\t\t\t\t\t\t// illegal type here\n\t\t\t\t\t\t\tpanic!(\"unexpected message variant\");\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tmatch player_time.entry(player_server) {\n\t\t\t\t\t\tEntry::Occupied(mut entry) =\u003e {\n\t\t\t\t\t\t\tlet (total, count) = entry.get_mut();\n\t\t\t\t\t\t\t*total += msg_duration;\n\t\t\t\t\t\t\t*count += 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tEntry::Vacant(entry) =\u003e {\n\t\t\t\t\t\t\tentry.insert((msg_duration, 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet players_count = response.players()?.count();\n\t\tlet objects_count = response.objects()?.count();\n\n\t\thistogram!(\n\t\t\t\"round_trip_latency\", elapsed.as_micros() as f64,\n\t\t\t\"@unit\" =\u003e metrics_cloudwatch::Unit::Microseconds\n\t\t);\n\t\thistogram!(\n\t\t\t\"relevant_players_count\", players_count as f64,\n\t\t\t\"@unit\" =\u003e metrics_cloudwatch::Unit::Count\n\t\t);\n\t\thistogram!(\n\t\t\t\"relevant_objects_count\", objects_count as f64,\n\t\t\t\"@unit\" =\u003e metrics_cloudwatch::Unit::Count\n\t\t);\n\n\t\tlet connections_count =\n\t\t\tunsafe { CONNECTIONS_COUNT.load(Ordering::Relaxed) } as f64;\n\t\thistogram!(\n\t\t\t\"connections_count\", connections_count,\n\t\t\t\"@unit\" =\u003e metrics_cloudwatch::Unit::Count\n\t\t);\n\n\t\tfor server_id in player_time.keys() {\n\t\t\tlet avarage_rtt =\n\t\t\t\t(player_time[server_id].0 / player_time[server_id].1) as f64;\n\t\t\tlet histogram_name =\n\t\t\t\tformat!(\"round_trip_latency_from_{}_to_{}\", server_id, server_index);\n\t\t\trecord_histogram(\n\t\t\t\thistogram_name,\n\t\t\t\tavarage_rtt,\n\t\t\t\tmetrics_cloudwatch::Unit::Microseconds,\n\t\t\t)\n\t\t}\n\n\t\tif counter % 100 == 0 {\n\t\t\tprintln!(\"rtt: {}\", humantime::format_duration(elapsed));\n\t\t\tprintln!(\"relevant players: {}\", response.players()?.count());\n\t\t\tprintln!(\"relevant objects: {}\", response.objects()?.count());\n\t\t}\n\t}\n}\n\nfn record_histogram(name: String, value: f64, unit: metrics_cloudwatch::Unit) {\n\thistogram!(name, value, \"@unit\" =\u003e unit);\n}\n\nfn current_microseconds_since_epoch() -\u003e Result\u003cu64, std::time::SystemTimeError\u003e\n{\n\tlet time_associated: SystemTime = SystemTime::now();\n\tlet duration_since_epoch = time_associated.duration_since(UNIX_EPOCH)?;\n\tlet since_epoch = duration_since_epoch.as_micros() as u64;\n\tOk(since_epoch)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","devtools","stress","src","test_case10.rs"],"content":"use {\n\tcrate::{PlayerState, Settings, SlotId},\n\tarrayvec::ArrayVec,\n\tquark_client_sdk::{\n\t\tprotocol::events::SystemEvents,\n\t\tAttributeId,\n\t\tOutboundEvent,\n\t\tPlayerId,\n\t\tRecipient,\n\t\tRelevance,\n\t\tWellKnownAttribute,\n\t},\n\trand::Rng,\n\tstd::{\n\t\tcollections::{HashMap, HashSet},\n\t\tsync::{\n\t\t\tatomic::{AtomicUsize, Ordering},\n\t\t\tArc,\n\t\t\tRwLock,\n\t\t},\n\t\ttime::{Duration, Instant},\n\t},\n};\n\nstatic mut CONNECTIONS_COUNT: AtomicUsize = AtomicUsize::new(0);\n\n/// ### Test Case 10: Player System Event Simulation (ForgetPlayers Event)\n///\n/// Description:\n/// This message is sent by a player who, after receiving updates about another\n/// player, is no longer keeping track of that player in its local state.\n/// The purpose of this event is to signal that the entire state of the\n/// forgotten player will need to be resent the next time it becomes relevant to\n/// the sender.\n///\n/// https://app.clickup.com/t/8693nkg62\n\npub async fn test_case10(\n\tindex: SlotId,\n\tsettings: Settings,\n\tstates: Arc\u003cRwLock\u003cHashMap\u003cPlayerId, PlayerState\u003e\u003e\u003e,\n) -\u003e anyhow::Result\u003c()\u003e {\n\tlet _ = states;\n\tlet auth: \u0026[u8] = \u0026[];\n\tlet server_index = index % settings.server_addr.len() as u32;\n\tlet mut session =\n\t\tcrate::create_session(\u0026settings.server_addr[0], auth).await?;\n\tlet wait_time =\n\t\tDuration::from_millis((1000.0f32 / settings.tick_frequency) as u64);\n\n\tlet mut counter = 0;\n\tunsafe { CONNECTIONS_COUNT.fetch_add(1, Ordering::Relaxed) };\n\n\tif settings.verbose \u003e 0 {\n\t\tprintln!(\n\t\t\t\"[server #{}, connection #{}] -\u003e session id: {}\",\n\t\t\tsettings.server_addr[server_index as usize],\n\t\t\tunsafe { CONNECTIONS_COUNT.load(Ordering::Relaxed) },\n\t\t\tsession.id(),\n\t\t);\n\t}\n\n\tlet mut forget_players: HashMap\u003cPlayerId, bool\u003e = HashMap::new();\n\tlet mut prev_recive_players: HashSet\u003cPlayerId\u003e = HashSet::new();\n\tlet player_name = format!(\"Player_{}\", session.id());\n\tlet start_time = Instant::now();\n\n\tlet mut start_point = get_random_waypoint(settings.clone());\n\tlet mut end_point = get_random_waypoint(settings.clone());\n\tlet mut current_point = start_point;\n\tlet mut speed = get_speed(settings.clone());\n\tlet mut last_update = Instant::now();\n\tlet mut loop_count = 0;\n\n\tloop {\n\t\ttokio::time::sleep(wait_time).await;\n\n\t\tlet mut tick = session.ticks().build();\n\t\ttick.set_interest_radius(Relevance::new(settings.interest_radius));\n\n\t\tif counter == 0 {\n\t\t\ttick\n\t\t\t\t.build_player()\n\t\t\t\t.build_attributes(1)\n\t\t\t\t.set_string(\n\t\t\t\t\tWellKnownAttribute::DisplayName as AttributeId,\n\t\t\t\t\t\u0026player_name,\n\t\t\t\t)\n\t\t\t\t.unwrap();\n\t\t} else {\n\t\t\tlet current = Instant::now();\n\t\t\tlet elapsed = current.duration_since(last_update);\n\t\t\tlast_update = current;\n\t\t\tlet state =\n\t\t\t\tplayer_step(start_point, end_point, current_point, speed, elapsed);\n\n\t\t\tlet dist_1 = (((current_point.0 - end_point.0)\n\t\t\t\t* (current_point.0 - end_point.0))\n\t\t\t\t+ ((current_point.1 - end_point.1) * (current_point.1 - end_point.1))\n\t\t\t\t+ ((current_point.2 - end_point.2) * (current_point.2 - end_point.2)))\n\t\t\t\t.sqrt();\n\n\t\t\tlet dist_2 = (((state.position.0 - end_point.0)\n\t\t\t\t* (state.position.0 - end_point.0))\n\t\t\t\t+ ((state.position.1 - end_point.1)\n\t\t\t\t\t* (state.position.1 - end_point.1))\n\t\t\t\t+ ((state.position.2 - end_point.2)\n\t\t\t\t\t* (state.position.2 - end_point.2)))\n\t\t\t\t.sqrt();\n\n\t\t\tif dist_1 \u003c dist_2 || dist_2 \u003c= speed * elapsed.as_millis() as f32 / 100.0\n\t\t\t{\n\t\t\t\tstart_point = end_point;\n\t\t\t\tend_point = get_random_waypoint(settings.clone());\n\t\t\t\tspeed = get_speed(settings.clone());\n\t\t\t}\n\t\t\tcurrent_point = state.position;\n\n\t\t\ttick\n\t\t\t\t.build_player()\n\t\t\t\t.build_attributes(2)\n\t\t\t\t.set_vec3(WellKnownAttribute::Position as AttributeId, state.position)\n\t\t\t\t.unwrap()\n\t\t\t\t.set_vec3(WellKnownAttribute::Rotation as AttributeId, state.rotation)\n\t\t\t\t.unwrap();\n\t\t}\n\n\t\t// scoped objects\n\t\t{\n\t\t\ttick.build_objects(0);\n\t\t}\n\n\t\t// scoped events\n\t\t{\n\t\t\tlet not_received_ids: Vec\u003cu32\u003e = forget_players\n\t\t\t\t.clone()\n\t\t\t\t.into_iter()\n\t\t\t\t.filter(|\u0026(_, value)| !value)\n\t\t\t\t.map(|(player_id, _)| player_id)\n\t\t\t\t.take(64)\n\t\t\t\t.collect();\n\n\t\t\tfor player_id in not_received_ids.iter() {\n\t\t\t\tforget_players.entry(*player_id).and_modify(|v| *v = true);\n\t\t\t}\n\n\t\t\tlet byte_buffer: Vec\u003cu8\u003e = not_received_ids\n\t\t\t\t.iter()\n\t\t\t\t.flat_map(|\u0026player_id| player_id.to_le_bytes().to_vec())\n\t\t\t\t.collect();\n\t\t\tlet mut payload: ArrayVec\u003cu8, 256\u003e = ArrayVec::new();\n\t\t\tpayload.extend(byte_buffer.into_iter().cycle().take(256));\n\t\t\tlet mut events = tick.build_events(2);\n\n\t\t\tevents.push_event(\u0026OutboundEvent {\n\t\t\t\tclass: SystemEvents::ForgetPlayers as u16,\n\t\t\t\tpayload,\n\t\t\t\trecipient: Recipient::Radius(settings.interest_radius.into()),\n\t\t\t});\n\n\t\t\tif settings.verbose \u003e 0 {\n\t\t\t\tprintln!(\n\t\t\t\t\t\"ForgetPlayers Event send  by session id: {}, Forget Players: {:?}\",\n\t\t\t\t\tsession.id(),\n\t\t\t\t\tnot_received_ids\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tcounter += 1;\n\n\t\tsession.ticks().send(tick)?;\n\n\t\tlet response = session.ticks().receive().await?;\n\t\tlet players = response.players()?;\n\n\t\tlet mut recv_players: HashSet\u003cPlayerId\u003e = HashSet::new();\n\t\tfor player in players {\n\t\t\tif forget_players.contains_key(\u0026player.id()) {\n\t\t\t\tif *forget_players.get(\u0026player.id()).unwrap()\n\t\t\t\t\t\u0026\u0026 player.attribs().count() \u003c 2\n\t\t\t\t{\n\t\t\t\t\treturn Err(anyhow::anyhow!(\n\t\t\t\t\t\t\"Entire state were not recieved for the player {}\",\n\t\t\t\t\t\tplayer.id()\n\t\t\t\t\t));\n\t\t\t\t}\n\t\t\t\tforget_players.remove(\u0026player.id());\n\t\t\t}\n\t\t\trecv_players.insert(player.id());\n\t\t}\n\n\t\tlet not_received: Vec\u003cPlayerId\u003e = prev_recive_players\n\t\t\t.clone()\n\t\t\t.into_iter()\n\t\t\t.filter(|\u0026player_id| !recv_players.contains(\u0026player_id))\n\t\t\t.collect();\n\t\tfor player_id in not_received {\n\t\t\tforget_players.insert(player_id, false);\n\t\t}\n\t\tprev_recive_players.clear();\n\t\tprev_recive_players = recv_players;\n\n\t\tloop_count += 1;\n\n\t\tif (settings.run_period \u003e 0\n\t\t\t\u0026\u0026 start_time.elapsed().as_secs() \u003e settings.run_period.into())\n\t\t\t|| (settings.run_loop \u003e 1 \u0026\u0026 settings.run_loop \u003e loop_count)\n\t\t{\n\t\t\tdrop(session);\n\t\t\tbreak;\n\t\t}\n\t}\n\tOk(())\n}\n\nfn player_step(\n\tstart: (f32, f32, f32),\n\tend: (f32, f32, f32),\n\tcurrent: (f32, f32, f32),\n\tspeed: f32,\n\telapse: Duration,\n) -\u003e PlayerState {\n\tlet coefficient = elapse.as_millis() as f32 / 100.0;\n\n\tlet diff = (end.0 - start.0, end.1 - start.1, end.2 - start.2);\n\n\tlet yaw_degrees = f32::atan2(diff.1, diff.0);\n\tlet pitch_degree =\n\t\tf32::atan2(diff.2, (diff.0 * diff.0 + diff.1 * diff.1).sqrt());\n\n\tlet delta = (\n\t\tspeed * f32::cos(yaw_degrees) * coefficient,\n\t\tspeed * f32::sin(yaw_degrees) * coefficient,\n\t\tspeed * f32::tan(pitch_degree) * coefficient,\n\t);\n\n\tlet next = (\n\t\t(current.0 - end.0),\n\t\t(current.1 - -end.1),\n\t\t(current.2 - -end.2),\n\t);\n\n\tlet rotation = (\n\t\tf32::atan2(delta.1, delta.2).to_degrees(),\n\t\tf32::atan2(delta.2, delta.0).to_degrees(),\n\t\tf32::atan2(delta.0, delta.1).to_degrees(),\n\t);\n\n\tPlayerState {\n\t\tposition: next,\n\t\trotation,\n\t}\n}\n\nfn get_random_waypoint(settings: Settings) -\u003e (f32, f32, f32) {\n\tlet mut rng = rand::thread_rng();\n\t(\n\t\trng.gen_range(settings.range_min..settings.range_max),\n\t\trng.gen_range(settings.range_min..settings.range_max),\n\t\trng.gen_range(settings.range_min..settings.range_max),\n\t)\n}\n\nfn get_speed(settings: Settings) -\u003e f32 {\n\tlet mut rng = rand::thread_rng();\n\n\trng.gen_range(settings.range_min..settings.range_max)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","devtools","stress","src","test_case11.rs"],"content":"use {\n\tcrate::{create_session, PlayerState, Settings, SlotId},\n\tquark_client_sdk::{AttributeId, PlayerId, WellKnownAttribute},\n\trand::Rng,\n\tstd::{\n\t\tcollections::{HashMap, HashSet},\n\t\tsync::{\n\t\t\tatomic::{AtomicUsize, Ordering},\n\t\t\tArc,\n\t\t\tRwLock,\n\t\t},\n\t\ttime::{Duration, Instant},\n\t},\n};\n\nstatic mut CONNECTIONS_COUNT: AtomicUsize = AtomicUsize::new(0);\n\n/// ### Test Case 11: players groups membership\n///\n/// Description:\n/// Scenario is designed to communicate with any number of players and each of\n/// the player is set so far away that they are not relevant to each other.\n/// Those players are connected and immidiately subscribe to a common relevancy\n/// group in the server, which in this case is group id 1. Each session runs for\n/// a 20 seconds interval ensuring that it has gotten enought time to received\n/// all the players.\n///\n/// To run this test with 100 sessions run the folllowing\n/// commnad cargo run --example stress -- -c 100 -f 1 -r 80000--test-case 11\n/// --verbose 1 --server-addr 127.0.0.1:5670\n\npub async fn test_case11(\n\tindex: SlotId,\n\tsettings: Settings,\n\tstates: Arc\u003cRwLock\u003cHashMap\u003cPlayerId, PlayerState\u003e\u003e\u003e,\n) -\u003e anyhow::Result\u003c()\u003e {\n\tlet auth: \u0026[u8] = \u0026[];\n\tlet mut session = create_session(\u0026settings.server_addr[0], auth).await?;\n\tlet wait_time =\n\t\tDuration::from_millis((1000.0f32 / settings.tick_frequency) as u64);\n\n\tlet position = (\n\t\tindex as f32 * settings.relevance_distance,\n\t\tindex as f32 * settings.relevance_distance,\n\t\tindex as f32 * settings.relevance_distance,\n\t);\n\n\tlet rotation = (\n\t\trand::thread_rng().gen_range((0.)..360.),\n\t\trand::thread_rng().gen_range((0.)..360.),\n\t\trand::thread_rng().gen_range((0.)..360.),\n\t);\n\n\tlet state = PlayerState { rotation, position };\n\n\tstates\n\t\t.write()\n\t\t.expect(\"error\")\n\t\t.entry(session.id())\n\t\t.or_insert(state);\n\n\tunsafe { CONNECTIONS_COUNT.fetch_add(1, Ordering::Relaxed) };\n\n\tif settings.verbose \u003e 0 {\n\t\tprintln!(\n\t\t\t\"connection #{} -\u003e session id: {}\",\n\t\t\tunsafe { CONNECTIONS_COUNT.load(Ordering::Relaxed) },\n\t\t\tsession.id(),\n\t\t);\n\t}\n\n\tlet mut received_players = HashSet::new();\n\tlet run_interval = Duration::from_secs(20_u64);\n\tlet relevance_check_interval = Duration::from_millis(2000_u64);\n\tlet time = Instant::now();\n\n\tloop {\n\t\ttokio::time::sleep(wait_time).await;\n\n\t\twhile time.elapsed() \u003c relevance_check_interval {\n\t\t\tlet mut tick = session.ticks().build();\n\n\t\t\ttick\n\t\t\t\t.build_player()\n\t\t\t\t.build_attributes(2)\n\t\t\t\t.set_vec3(WellKnownAttribute::Position as AttributeId, position)\n\t\t\t\t.unwrap()\n\t\t\t\t.set_vec3(WellKnownAttribute::Rotation as AttributeId, rotation)\n\t\t\t\t.unwrap();\n\n\t\t\tsession.ticks().send(tick)?;\n\n\t\t\tlet response = session.ticks().receive().await?;\n\n\t\t\tif response.players()?.count() \u003e 0 {\n\t\t\t\treturn Err(anyhow::anyhow!(\n\t\t\t\t\t\"Relevance check failed, players are still relevant to session\n\t\t\t\t\t #{index}\"\n\t\t\t\t));\n\t\t\t}\n\t\t}\n\n\t\tlet mut tick = session.ticks().build();\n\n\t\ttick\n\t\t\t.build_player()\n\t\t\t.build_attributes(3)\n\t\t\t.set_vec3(WellKnownAttribute::Position as AttributeId, position)\n\t\t\t.unwrap()\n\t\t\t.set_vec3(WellKnownAttribute::Rotation as AttributeId, rotation)\n\t\t\t.unwrap()\n\t\t\t.set_uint16(WellKnownAttribute::GroupId as AttributeId, 1)\n\t\t\t.unwrap();\n\n\t\tsession.ticks().send(tick)?;\n\n\t\tlet response = session.ticks().receive().await?;\n\n\t\tfor player in response.players()? {\n\t\t\treceived_players.insert(player.id());\n\t\t}\n\t\tmatch time.elapsed() \u003e= run_interval {\n\t\t\ttrue =\u003e break,\n\t\t\tfalse =\u003e {}\n\t\t}\n\t}\n\n\tlet server_state = states.read().unwrap().clone();\n\tlet server_population = server_state.keys().count();\n\n\tif received_players.len() != server_population {\n\t\treturn Err(anyhow::anyhow!(\n\t\t\t\"Correct number of players not received by session #{index}\"\n\t\t));\n\t}\n\n\tfor player_id in received_players.iter() {\n\t\tmatch server_state.contains_key(player_id) {\n\t\t\tfalse =\u003e {\n\t\t\t\treturn Err(anyhow::anyhow!(\n\t\t\t\t\t\"Specefic player with id {player_id} recieved by session #{index}\n\t\t\t\t\t does not exist in the server\"\n\t\t\t\t))\n\t\t\t}\n\t\t\ttrue =\u003e todo!(),\n\t\t}\n\t}\n\n\tOk(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","devtools","stress","src","test_case12.rs"],"content":"use {\n\tcrate::{PlayerAttribute, PlayerState, Settings, SlotId},\n\tquark_client_sdk::{\n\t\tAttributeId,\n\t\tPlayerId,\n\t\tRelevance,\n\t\tValue,\n\t\tWellKnownAttribute,\n\t},\n\trand::Rng,\n\tstd::{\n\t\tcollections::HashMap,\n\t\tsync::{\n\t\t\tatomic::{AtomicUsize, Ordering},\n\t\t\tArc,\n\t\t\tRwLock,\n\t\t},\n\t\ttime::{Duration, Instant, SystemTime, UNIX_EPOCH},\n\t},\n};\n\nstatic mut CONNECTIONS_COUNT: AtomicUsize = AtomicUsize::new(0);\n\n/// ### Test Case 12: Testing all types available in attribute\n///\n/// Quark allows for set of types which can be used in attribute:\n///     Bool(bool), IsAlive\n///     Vec2((f32, f32)), Velocity\n///     Vec3((f32, f32, f32)), Position\n///     Uint8(u8), Mana\n///     Uint16(u16), Currency\n///     Uint32(u32), Strength\n///     Uint64(u64), Timestamp\n///     Int8(i8), GroupId\n///     Int16(i16), Speed\n///     Int32(i32), Armor\n///     Int64(i64), Scale\n///     Float32(f32), Wealth\n///     Float64(f64), Damage\n///     String(ArrayString\u003cMAX_SEQUENCE_LENGTH\u003e), DisplayName\n///     Bytes(ArrayVec\u003cu8, MAX_SEQUENCE_LENGTH\u003e), Appearance\n///\n/// https://app.clickup.com/t/8693y354e\n\npub async fn test_case12(\n\tindex: SlotId,\n\tsettings: Settings,\n\tstates: Arc\u003cRwLock\u003cHashMap\u003cPlayerId, PlayerState\u003e\u003e\u003e,\n) -\u003e anyhow::Result\u003c()\u003e {\n\tlet _ = states;\n\tlet auth: \u0026[u8] = \u0026[];\n\tlet server_index = index % settings.server_addr.len() as u32;\n\tlet mut session =\n\t\tcrate::create_session(\u0026settings.server_addr[0], auth).await?;\n\tlet wait_time =\n\t\tDuration::from_millis((1000.0f32 / settings.tick_frequency) as u64);\n\n\tlet mut counter = 0;\n\tunsafe { CONNECTIONS_COUNT.fetch_add(1, Ordering::Relaxed) };\n\n\tif settings.verbose \u003e 0 {\n\t\tprintln!(\n\t\t\t\"[server #{}, connection #{}] -\u003e session id: {}\",\n\t\t\tsettings.server_addr[server_index as usize],\n\t\t\tunsafe { CONNECTIONS_COUNT.load(Ordering::Relaxed) },\n\t\t\tsession.id(),\n\t\t);\n\t}\n\n\tlet mut loop_count = 0;\n\tlet start_time = Instant::now();\n\tlet player_name = format!(\"Player_{}\", session.id());\n\tlet byte_array = [1; 10];\n\n\tloop {\n\t\ttokio::time::sleep(wait_time).await;\n\n\t\tcounter += 1;\n\n\t\tlet relevance = match counter % 5 == 0 {\n\t\t\ttrue =\u003e Relevance::new(settings.interest_radius),\n\t\t\tfalse =\u003e Relevance::new(0.60),\n\t\t};\n\n\t\tlet mut tick = session.ticks().build();\n\t\ttick.set_interest_radius(relevance);\n\t\tlet current_timestamp = current_microseconds_since_epoch()?;\n\n\t\ttick\n\t\t\t.build_player()\n\t\t\t.build_attributes(19)\n\t\t\t.set_bool(PlayerAttribute::IsAlive as AttributeId, true)\n\t\t\t.unwrap()\n\t\t\t.set_vec2(\n\t\t\t\tPlayerAttribute::Velocity as AttributeId,\n\t\t\t\t(\n\t\t\t\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max),\n\t\t\t\t),\n\t\t\t)\n\t\t\t.unwrap()\n\t\t\t.set_vec3(\n\t\t\t\tWellKnownAttribute::Position as AttributeId,\n\t\t\t\t(\n\t\t\t\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max),\n\t\t\t\t),\n\t\t\t)\n\t\t\t.unwrap()\n\t\t\t.set_uint8(\n\t\t\t\tPlayerAttribute::Mana as AttributeId,\n\t\t\t\trand::thread_rng().gen_range(u8::MIN..u8::MAX),\n\t\t\t)\n\t\t\t.unwrap()\n\t\t\t.set_uint16(\n\t\t\t\tPlayerAttribute::Currency as AttributeId,\n\t\t\t\trand::thread_rng().gen_range(u16::MIN..u16::MAX),\n\t\t\t)\n\t\t\t.unwrap()\n\t\t\t.set_uint32(\n\t\t\t\tPlayerAttribute::Strength as AttributeId,\n\t\t\t\trand::thread_rng().gen_range(u32::MIN..u32::MAX),\n\t\t\t)\n\t\t\t.unwrap()\n\t\t\t.set_uint64(PlayerAttribute::Timestamp as AttributeId, current_timestamp)\n\t\t\t.unwrap()\n\t\t\t.set_int8(\n\t\t\t\tWellKnownAttribute::GroupId as AttributeId,\n\t\t\t\trand::thread_rng().gen_range(i8::MIN..i8::MAX),\n\t\t\t)\n\t\t\t.unwrap()\n\t\t\t.set_int16(\n\t\t\t\tPlayerAttribute::Speed as AttributeId,\n\t\t\t\trand::thread_rng().gen_range(i16::MIN..i16::MAX),\n\t\t\t)\n\t\t\t.unwrap()\n\t\t\t.set_int32(\n\t\t\t\tPlayerAttribute::Armor as AttributeId,\n\t\t\t\trand::thread_rng().gen_range(i32::MIN..i32::MAX),\n\t\t\t)\n\t\t\t.unwrap()\n\t\t\t.set_int64(\n\t\t\t\tWellKnownAttribute::Scale as AttributeId,\n\t\t\t\trand::thread_rng().gen_range(i64::MIN..i64::MAX),\n\t\t\t)\n\t\t\t.unwrap()\n\t\t\t.set_float32(\n\t\t\t\tPlayerAttribute::Wealth as AttributeId,\n\t\t\t\trand::thread_rng().gen_range(-1000.0..1000.0),\n\t\t\t)\n\t\t\t.unwrap()\n\t\t\t.set_float64(\n\t\t\t\tPlayerAttribute::Damage as AttributeId,\n\t\t\t\trand::thread_rng().gen_range(-1000.0..1000.0),\n\t\t\t)\n\t\t\t.unwrap()\n\t\t\t.set_string(WellKnownAttribute::DisplayName as AttributeId, \u0026player_name)\n\t\t\t.unwrap()\n\t\t\t.set_bytes(PlayerAttribute::Appearance as AttributeId, \u0026byte_array)\n\t\t\t.unwrap()\n\t\t\t.set_vec2d(\n\t\t\t\tPlayerAttribute::RelevancePoint2D as AttributeId,\n\t\t\t\t(\n\t\t\t\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max)\n\t\t\t\t\t\tas f64,\n\t\t\t\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max)\n\t\t\t\t\t\tas f64,\n\t\t\t\t),\n\t\t\t)\n\t\t\t.unwrap()\n\t\t\t.set_vec3d(\n\t\t\t\tPlayerAttribute::RelevancePoint3D as AttributeId,\n\t\t\t\t(\n\t\t\t\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max)\n\t\t\t\t\t\tas f64,\n\t\t\t\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max)\n\t\t\t\t\t\tas f64,\n\t\t\t\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max)\n\t\t\t\t\t\tas f64,\n\t\t\t\t),\n\t\t\t)\n\t\t\t.unwrap()\n\t\t\t.set_vec4(\n\t\t\t\tPlayerAttribute::PositionHealth as AttributeId,\n\t\t\t\t(\n\t\t\t\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\trand::thread_rng().gen_range(0.0..100.0),\n\t\t\t\t),\n\t\t\t)\n\t\t\t.unwrap()\n\t\t\t.set_vec4d(\n\t\t\t\tPlayerAttribute::PositionDamage as AttributeId,\n\t\t\t\t(\n\t\t\t\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max)\n\t\t\t\t\t\tas f64,\n\t\t\t\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max)\n\t\t\t\t\t\tas f64,\n\t\t\t\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max)\n\t\t\t\t\t\tas f64,\n\t\t\t\t\trand::thread_rng().gen_range(0.0..100.0) as f64,\n\t\t\t\t),\n\t\t\t)\n\t\t\t.unwrap();\n\n\t\tsession.ticks().send(tick)?;\n\t\tlet response = session.ticks().receive().await?;\n\t\tlet players = response.players()?;\n\n\t\tfor player in players {\n\t\t\tlet attribs = player.attribs();\n\t\t\tlet mut attribute_count = 0;\n\t\t\tfor attrib in attribs {\n\t\t\t\tlet attrib_key: u16 = attrib.key;\n\t\t\t\tlet value = attrib.value.clone();\n\t\t\t\tattribute_count += 1;\n\t\t\t\tmatch value {\n\t\t\t\t\tValue::Bool(_val) =\u003e {\n\t\t\t\t\t\tif attrib_key != PlayerAttribute::IsAlive as AttributeId {\n\t\t\t\t\t\t\treturn Err(anyhow::anyhow!(\n\t\t\t\t\t\t\t\t\"Error: Player attribute type mismatch. Expected Bool.\"\n\t\t\t\t\t\t\t));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tValue::Vec2((_x, _y)) =\u003e {\n\t\t\t\t\t\tif attrib_key != PlayerAttribute::Velocity as AttributeId {\n\t\t\t\t\t\t\treturn Err(anyhow::anyhow!(\n\t\t\t\t\t\t\t\t\"Error: Player attribute type mismatch. Expected Vec2.\"\n\t\t\t\t\t\t\t));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tValue::Vec3((_x, _y, _z)) =\u003e {\n\t\t\t\t\t\tif attrib_key != WellKnownAttribute::Position as AttributeId {\n\t\t\t\t\t\t\treturn Err(anyhow::anyhow!(\n\t\t\t\t\t\t\t\t\"Error: Player attribute type mismatch. Expected Vec3.\"\n\t\t\t\t\t\t\t));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tValue::Uint8(_val) =\u003e {\n\t\t\t\t\t\tif attrib_key != PlayerAttribute::Mana as AttributeId {\n\t\t\t\t\t\t\treturn Err(anyhow::anyhow!(\n\t\t\t\t\t\t\t\t\"Error: Player attribute type mismatch. Expected Uint8.\"\n\t\t\t\t\t\t\t));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tValue::Uint16(_val) =\u003e {\n\t\t\t\t\t\tif attrib_key != PlayerAttribute::Currency as AttributeId {\n\t\t\t\t\t\t\treturn Err(anyhow::anyhow!(\n\t\t\t\t\t\t\t\t\"Error: Player attribute type mismatch. Expected Unit16.\"\n\t\t\t\t\t\t\t));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tValue::Uint32(_val) =\u003e {\n\t\t\t\t\t\tif attrib_key != PlayerAttribute::Strength as AttributeId {\n\t\t\t\t\t\t\treturn Err(anyhow::anyhow!(\n\t\t\t\t\t\t\t\t\"Error: Player attribute type mismatch. Expected Unit32.\"\n\t\t\t\t\t\t\t));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tValue::Uint64(_val) =\u003e {\n\t\t\t\t\t\tif attrib_key != PlayerAttribute::Timestamp as AttributeId {\n\t\t\t\t\t\t\treturn Err(anyhow::anyhow!(\n\t\t\t\t\t\t\t\t\"Error: Player attribute type mismatch. Expected Unit64.\"\n\t\t\t\t\t\t\t));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tValue::Int8(_val) =\u003e {\n\t\t\t\t\t\tif attrib_key != WellKnownAttribute::GroupId as AttributeId {\n\t\t\t\t\t\t\treturn Err(anyhow::anyhow!(\n\t\t\t\t\t\t\t\t\"Error: Player attribute type mismatch. Expected int8.\"\n\t\t\t\t\t\t\t));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tValue::Int16(_val) =\u003e {\n\t\t\t\t\t\tif attrib_key != PlayerAttribute::Speed as AttributeId {\n\t\t\t\t\t\t\treturn Err(anyhow::anyhow!(\n\t\t\t\t\t\t\t\t\"Error: Player attribute type mismatch. Expected Int16.\"\n\t\t\t\t\t\t\t));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tValue::Int32(_val) =\u003e {\n\t\t\t\t\t\tif attrib_key != PlayerAttribute::Armor as AttributeId {\n\t\t\t\t\t\t\treturn Err(anyhow::anyhow!(\n\t\t\t\t\t\t\t\t\"Error: Player attribute type mismatch. Expected Int32.\"\n\t\t\t\t\t\t\t));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tValue::Int64(_val) =\u003e {\n\t\t\t\t\t\tif attrib_key != WellKnownAttribute::Scale as AttributeId {\n\t\t\t\t\t\t\treturn Err(anyhow::anyhow!(\n\t\t\t\t\t\t\t\t\"Error: Player attribute type mismatch. Expected int64.\"\n\t\t\t\t\t\t\t));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tValue::Float32(_val) =\u003e {\n\t\t\t\t\t\tif attrib_key != PlayerAttribute::Wealth as AttributeId {\n\t\t\t\t\t\t\treturn Err(anyhow::anyhow!(\n\t\t\t\t\t\t\t\t\"Error: Player attribute type mismatch. Expected Float32.\"\n\t\t\t\t\t\t\t));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tValue::Float64(_val) =\u003e {\n\t\t\t\t\t\tif attrib_key != PlayerAttribute::Damage as AttributeId {\n\t\t\t\t\t\t\treturn Err(anyhow::anyhow!(\n\t\t\t\t\t\t\t\t\"Error: Player attribute type mismatch. Expected Float64.\"\n\t\t\t\t\t\t\t));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tValue::String(_val) =\u003e {\n\t\t\t\t\t\tif attrib_key != WellKnownAttribute::DisplayName as AttributeId {\n\t\t\t\t\t\t\treturn Err(anyhow::anyhow!(\n\t\t\t\t\t\t\t\t\"Error: Player attribute type mismatch. Expected String.\"\n\t\t\t\t\t\t\t));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tValue::Bytes(_val) =\u003e {\n\t\t\t\t\t\tif attrib_key != PlayerAttribute::Appearance as AttributeId {\n\t\t\t\t\t\t\treturn Err(anyhow::anyhow!(\n\t\t\t\t\t\t\t\t\"Error: Player attribute type mismatch. Expected Byte array.\"\n\t\t\t\t\t\t\t));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tValue::Vec2d(_val) =\u003e {\n\t\t\t\t\t\tif attrib_key != PlayerAttribute::RelevancePoint2D as AttributeId {\n\t\t\t\t\t\t\treturn Err(anyhow::anyhow!(\n\t\t\t\t\t\t\t\t\"Error: Player attribute type mismatch. Expected Vec2d.\"\n\t\t\t\t\t\t\t));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tValue::Vec3d(_val) =\u003e {\n\t\t\t\t\t\tif attrib_key != PlayerAttribute::RelevancePoint3D as AttributeId {\n\t\t\t\t\t\t\treturn Err(anyhow::anyhow!(\n\t\t\t\t\t\t\t\t\"Error: Player attribute type mismatch. Expected Vec3d.\"\n\t\t\t\t\t\t\t));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tValue::Vec4(_val) =\u003e {\n\t\t\t\t\t\tif attrib_key != PlayerAttribute::PositionHealth as AttributeId {\n\t\t\t\t\t\t\treturn Err(anyhow::anyhow!(\n\t\t\t\t\t\t\t\t\"Error: Player attribute type mismatch. Expected Vec4.\"\n\t\t\t\t\t\t\t));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tValue::Vec4d(_val) =\u003e {\n\t\t\t\t\t\tif attrib_key != PlayerAttribute::PositionDamage as AttributeId {\n\t\t\t\t\t\t\treturn Err(anyhow::anyhow!(\n\t\t\t\t\t\t\t\t\"Error: Player attribute type mismatch. Expected Vec4d.\"\n\t\t\t\t\t\t\t));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t_ =\u003e {\n\t\t\t\t\t\t// illegal type here\n\t\t\t\t\t\tpanic!(\"unexpected message variant\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif settings.verbose \u003e 0 {\n\t\t\t\t\tprintln!(\"Recieved player attrib count : {}\", attribute_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tloop_count += 1;\n\n\t\tif (settings.run_period \u003e 0\n\t\t\t\u0026\u0026 start_time.elapsed().as_secs() \u003e settings.run_period.into())\n\t\t\t|| (settings.run_loop \u003e 1 \u0026\u0026 settings.run_loop \u003e loop_count)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\tOk(())\n}\n\nfn current_microseconds_since_epoch() -\u003e Result\u003cu64, std::time::SystemTimeError\u003e\n{\n\tlet time_associated: SystemTime = SystemTime::now();\n\tlet duration_since_epoch = time_associated.duration_since(UNIX_EPOCH)?;\n\tlet since_epoch = duration_since_epoch.as_micros() as u64;\n\tOk(since_epoch)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","devtools","stress","src","test_case13.rs"],"content":"use {\n\tcrate::{PlayerState, Settings, SlotId},\n\tmetrics::histogram,\n\tquark_client_sdk::{\n\t\tAttributeId,\n\t\tPlayerId,\n\t\tRelevance,\n\t\tSession,\n\t\tWellKnownAttribute,\n\t},\n\trand::Rng,\n\tstd::{\n\t\tcollections::HashMap,\n\t\tsync::{\n\t\t\tatomic::{AtomicUsize, Ordering},\n\t\t\tArc,\n\t\t\tRwLock,\n\t\t},\n\t\ttime::{Duration, Instant},\n\t},\n};\n\nstatic mut CONNECTIONS_COUNT: AtomicUsize = AtomicUsize::new(0);\n\npub async fn set_player_position(\n\tsession: \u0026mut Session,\n\tsettings: Settings,\n\tx: f32,\n\ty: f32,\n\tz: f32,\n) -\u003e Result\u003c(), quark_client_sdk::Error\u003e {\n\tif settings.verbose \u003e 1 {\n\t\tprintln!(\"Player:{} New Position:{}, {}, {}\", session.id(), x, y, z);\n\t}\n\tlet mut tick = session.ticks().build();\n\ttick.set_interest_radius(Relevance::new(settings.interest_radius));\n\ttick\n\t\t.build_player()\n\t\t.build_attributes(2)\n\t\t.set_vec3(WellKnownAttribute::Position as AttributeId, (x, y, z))\n\t\t.unwrap();\n\n\tsession.ticks().send(tick)\n}\n\npub fn check_response(\n\tresponse: quark_client_sdk::TickReader,\n\tid: PlayerId,\n\tx: f32,\n\ty: f32,\n\tz: f32,\n) -\u003e bool {\n\tfor player in response.players().unwrap() {\n\t\tif player.id() != id {\n\t\t\tcontinue;\n\t\t}\n\t\tlet attribs = player.attribs();\n\t\tfor attrib in attribs.into_iter() {\n\t\t\tif attrib.key != WellKnownAttribute::Position as AttributeId {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmatch attrib.value {\n\t\t\t\tquark_client_sdk::Value::Vec3(vec3) =\u003e {\n\t\t\t\t\tif vec3.0 == x \u0026\u0026 vec3.1 == y \u0026\u0026 vec3.2 == z {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_ =\u003e continue,\n\t\t\t}\n\t\t}\n\t}\n\tfalse\n}\n\n/// ### Test Case 13: Measure update latency between two players connected\n///                   to two different servers in same cluster/region\n/// Description:\n/// This program creates two sessions, one with --server-addr[0] and another\n/// with --server-addr[1]. Session 1 and Session 2 players set their initial\n/// positions nearby to each other so that are in each other's relevance radius.\n/// Session 1 then sends a position update to --server-addr[0]. Session 2\n/// continuously pings --server-addr[1] to get any pending updates. If it\n/// receives any update on Player 1, it mataches against the local variable set\n/// by Player - 1 for its position. If the tick update matches the local\n/// variable storing Player 1 position, Player 2 successfully ends one iteration\n/// of testing measuring the time taken to receive update from the server.\n///\n/// Optional Arguments:\n/// --timeout: Specify the timeout after which Player 2 will stop listening for\n///                the update from server and will continue to next iteration\n/// E.g.:\n///  cargo run --example stress -- --server-addr 10.10.20.11 10.10.20.12 -c 1 -f\n/// 1 -t 13\n\npub async fn test_case13(\n\t_index: SlotId,\n\tsettings: Settings,\n\tstates: Arc\u003cRwLock\u003cHashMap\u003cPlayerId, PlayerState\u003e\u003e\u003e,\n) -\u003e anyhow::Result\u003c()\u003e {\n\tlet _ = states;\n\tlet auth: \u0026[u8] = \u0026[];\n\tlet mut sent_time: Instant;\n\tlet mut recv_time: Duration;\n\n\tif settings.server_addr.len() \u003c 2 {\n\t\treturn Err(anyhow::Error::msg(\n\t\t\t\"Minimum two server addresses are required\",\n\t\t));\n\t}\n\n\tlet mut session1 =\n\t\tcrate::create_session(\u0026settings.server_addr[0], auth).await?;\n\n\tlet mut session2 =\n\t\tcrate::create_session(\u0026settings.server_addr[1], auth).await?;\n\n\tlet wait_time: Duration =\n\t\tDuration::from_millis((1000.0f32 / settings.tick_frequency) as u64);\n\n\tunsafe { CONNECTIONS_COUNT.fetch_add(2, Ordering::Relaxed) };\n\n\tprintln!(\n\t\t\"server: {} -\u003e session id: {} [UPDATE SENDER]\",\n\t\tsettings.server_addr[0],\n\t\tsession1.id(),\n\t);\n\tprintln!(\n\t\t\"server: {} -\u003e session id: {} [UPDATE RECEIVER]\",\n\t\tsettings.server_addr[1],\n\t\tsession2.id(),\n\t);\n\tprintln!(\n\t\t\"RECEIVER will wait for {} ms (--timeout) to get the update from server.\",\n\t\tsettings.timeout\n\t);\n\n\tlet pos_x =\n\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max);\n\tlet pos_y =\n\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max);\n\tlet pos_z =\n\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max);\n\n\t// Player-1 set position\n\tset_player_position(\u0026mut session1, settings.clone(), pos_x, pos_y, pos_z)\n\t\t.await?;\n\tlet _response = session1.ticks().receive().await?;\n\t// parse_response(response, session1.id());\n\n\t// Player-2 set position\n\tset_player_position(\n\t\t\u0026mut session2,\n\t\tsettings.clone(),\n\t\tpos_x + 0.1,\n\t\tpos_y + 0.1,\n\t\tpos_z + 0.1,\n\t)\n\t.await?;\n\tlet _response = session2.ticks().receive().await?;\n\t// parse_response(response, session2.id());\n\n\tif settings.verbose \u003e 0 {\n\t\tprintln!(\"\\nStarting test\");\n\t}\n\n\tloop {\n\t\ttokio::time::sleep(wait_time).await;\n\n\t\tif settings.verbose \u003e 0 {\n\t\t\tprintln!();\n\t\t}\n\n\t\tlet send_x: f32;\n\t\tlet send_y: f32;\n\t\tlet send_z: f32;\n\t\t// Player - 1 sends update\n\t\t{\n\t\t\tlet offset: f32 = rand::thread_rng().gen_range(0.0..1.0);\n\t\t\tsend_x = pos_x + offset;\n\t\t\tsend_y = pos_y + offset;\n\t\t\tsend_z = pos_z + offset;\n\t\t\tset_player_position(\n\t\t\t\t\u0026mut session1,\n\t\t\t\tsettings.clone(),\n\t\t\t\tsend_x,\n\t\t\t\tsend_y,\n\t\t\t\tsend_z,\n\t\t\t)\n\t\t\t.await?;\n\t\t\tsent_time = Instant::now();\n\t\t\t// Do not wait for response\n\t\t}\n\n\t\t// PLayer - 2 waits for the update\n\t\tloop {\n\t\t\tset_player_position(\n\t\t\t\t\u0026mut session2,\n\t\t\t\tsettings.clone(),\n\t\t\t\tpos_x + 0.3,\n\t\t\t\tpos_y + 0.3,\n\t\t\t\tpos_z + 0.3,\n\t\t\t)\n\t\t\t.await?;\n\n\t\t\tlet response = session2.ticks().receive().await?;\n\n\t\t\trecv_time = sent_time.elapsed();\n\n\t\t\t// Cross check if position update of player 1 sent by server is\n\t\t\t// same as the one player - 1 set by itself.\n\t\t\tif check_response(response, session1.id(), send_x, send_y, send_z) {\n\t\t\t\tif settings.verbose \u003e 0 {\n\t\t\t\t\tprintln!(\"Time taken: {} microsec\", recv_time.as_micros());\n\t\t\t\t}\n\t\t\t\thistogram!(\n\t\t\t\t\t\"player_update_latency\", recv_time.as_micros() as f64,\n\t\t\t\t\t\"@unit\" =\u003e metrics_cloudwatch::Unit::Microseconds\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// If update is not received till 20ms, timeout and start new iteration\n\t\t\tif sent_time.elapsed().as_millis() \u003e settings.timeout as u128\n\t\t\t\t\u0026\u0026 settings.verbose \u003e 0\n\t\t\t{\n\t\t\t\tprintln!(\"Timeout: {}\", sent_time.elapsed().as_micros());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// Check the left out response\n\t\tlet _response = session1.ticks().receive().await?;\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","devtools","stress","src","test_case14.rs"],"content":"use {\n\tcrate::{PlayerState, Settings, SlotId},\n\tmetrics::histogram,\n\tquark_client_sdk::{\n\t\tAttributeId,\n\t\tPlayerId,\n\t\tRelevance,\n\t\tSession,\n\t\tWellKnownAttribute,\n\t},\n\trand::Rng,\n\tstd::{\n\t\tcollections::HashMap,\n\t\tio::Read,\n\t\tsync::{\n\t\t\tatomic::{AtomicUsize, Ordering},\n\t\t\tArc,\n\t\t\tRwLock,\n\t\t},\n\t\ttime::{Duration, Instant},\n\t},\n\ttokio::net::UdpSocket,\n};\n\nstatic mut CONNECTIONS_COUNT: AtomicUsize = AtomicUsize::new(0);\n\npub async fn set_player_position(\n\tsession: \u0026mut Session,\n\tsettings: Settings,\n\tx: f32,\n\ty: f32,\n\tz: f32,\n) -\u003e Result\u003c(), quark_client_sdk::Error\u003e {\n\tif settings.verbose \u003e 1 {\n\t\tprintln!(\"Player:{} New Position:{}, {}, {}\", session.id(), x, y, z);\n\t}\n\tlet mut tick = session.ticks().build();\n\ttick.set_interest_radius(Relevance::new(settings.interest_radius));\n\ttick\n\t\t.build_player()\n\t\t.build_attributes(2)\n\t\t.set_vec3(WellKnownAttribute::Position as AttributeId, (x, y, z))\n\t\t.unwrap();\n\n\tsession.ticks().send(tick)\n}\npub fn _parse_response(response: quark_client_sdk::TickReader, id: PlayerId) {\n\tprintln!(\"Player:{} got reponse\", id);\n\tfor player in response.players().expect(\"msg\") {\n\t\tprintln!(\"\\tPlayer: {}\", player.id());\n\n\t\tlet attribs = player.attribs();\n\t\tprintln!(\"\\tAttributes Len: {}\", attribs.len());\n\t\tfor attrib in attribs {\n\t\t\tprintln!(\"\\t\\tAttribute: {}, {:?}\", attrib.key, attrib.value);\n\t\t}\n\t}\n}\n\npub fn check_response(\n\tresponse: quark_client_sdk::TickReader,\n\tid: PlayerId,\n\tx: f32,\n\ty: f32,\n\tz: f32,\n) -\u003e bool {\n\tfor player in response.players().unwrap() {\n\t\tif player.id() != id {\n\t\t\tcontinue;\n\t\t}\n\t\tlet attribs = player.attribs();\n\t\tfor attrib in attribs.into_iter() {\n\t\t\tif attrib.key != WellKnownAttribute::Position as AttributeId {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmatch attrib.value {\n\t\t\t\tquark_client_sdk::Value::Vec3(vec3) =\u003e {\n\t\t\t\t\t// println!(\"\\t\\tx:{} y:{} z:{}\", vec3.0, vec3.1, vec3.2);\n\t\t\t\t\tif vec3.0 == x \u0026\u0026 vec3.1 == y \u0026\u0026 vec3.2 == z {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_ =\u003e continue,\n\t\t\t}\n\t\t}\n\t}\n\tfalse\n}\n\nfn print_buffer(buffer: \u0026Vec\u003cu8\u003e, msg: \u0026str) {\n\tprintln!(\"{}\", msg);\n\tfor b in buffer.bytes() {\n\t\tprint!(\"{} \", b.expect(\"msg\"));\n\t}\n\tprintln!();\n}\n\n#[derive(Clone, Copy, Debug)]\nenum MsgType {\n\tPlayerId,\n\tRttMeasurement,\n\tRttMeasurementDone,\n\tStartTest,\n\tTestPosition,\n}\n\nstruct Msg {\n\tmsg_type: MsgType,\n\tplayer_id: PlayerId,\n\tpos_x: f32,\n\tpos_y: f32,\n\tpos_z: f32,\n}\n\n/// ### Test Case 14: Measure update latency between two players connected\n///                   to two different servers in different clusters/regions\n/// E.g. Topology:\n///    Client-EU ----------- Client-US\n///         |                    |\n///         |                    |\n///         |                    |\n///     Server-EU             Server-US\n///         |                    |\n///         |                    |\n///         |                    |\n///     Forwarder-EU -------- Forwarder-US\n///\n///     Forwarder-EU \u0026 Forwarder-US  and  Client-EU \u0026 Client-US, should be able\n/// to     communicate directly for this test to work.\n///\n/// Description:\n/// This program is divided into two parts. One client will run in listener mode\n/// and other in sender mode. Taking scenario where Client-EU runs in \"listener\"\n/// mode Client-US runs in \"sender\" mode.\n/// In sender mode, the Client-US will change its player's positions randomly\n/// and send them via tick update to Server-US. In listener mode, Client-EU will\n/// try to get the tick updates from Server-EU and check the time taken for\n/// getting Client-US player's position update.\n///\n/// Before starting the test, Sender and Listener exchange following messages,\n/// directly peer to peer: MsgType::PlayerId - Listener(Client-EU) will send\n/// this msg to Sender(Client-US) with its  PlayerId. Client-US will repond with\n/// same msg, having its PlayerID. Without this exchange, the test will not\n/// proceed. MsgType::RttMeasurement - Client-EU will send this msg multiple\n/// times to Client-US and Client-US will reply with same msg. Client-EU will\n/// check the time between send and recv of the msg to measure RTT between two\n/// clients. MsgType::RttMeasurementDone - Client-EU will send this msg when\n/// RTT measurement is complemented.  Client-US will not respond anything to\n/// this. MsgType::StartTest - Client-EU will send this msg to Client-US to\n/// start the test. Client-US will then randomly sets its position via tick\n/// update.     MsgType::TestPosition - Once Client-US sets its position\n/// randomly, Client-US will send this msg to Client-EU with its new position\n/// coordinates. Client-EU on receiving tis msg, will start pinging Server-EU\n/// for tick updates. When the Client-US's position update is received by\n/// Client-EU, it will cross check it with coordinates send by Client-US. If\n/// they match, then update is received successfully.\n///\n/// Time taken for update to reach from US to EU :\n/// (Avg direct RTT between Client-US and Client-EU)/2 +\n/// (Difference between Time at which MsgType::TestPosition is recvd and Time at\n/// which player's update is recvd from server)\n///\n/// Since actual timing is started when Client-US sends (Tick update \u0026\n/// MsgType::TestPosition simulataneously), but the RTT/2 time is needed for\n/// MsgType::TestPosition to reach Client-EU. Hence RTT/2 is added to the time\n/// for Client-EU to start listening for update and time at which update is\n/// received from Server-EU.\n///\n/// Required Argument:\n/// ---listener-mode \u003cIP_OF_SENDER_CLIENT\u003e : This client will run in listener\n/// mode. Mention the IP of another client running in sender mode.\n///\n/// --sender-mode \u003cIP_OF_LISTENER_CLIENT\u003e : This client will run in sender mode.\n/// Mention the IP of another client running in listener mode.\n/// E.g.\n/// Client-EU :\n///   cargo run --example stress -- --server-addr 10.10.20.11 -c 1 -f 1 -t 14\n/// --listener-mode 20.20.20.21\n///\n/// Client-US :\n///   cargo run --example stress -- --server-addr 20.20.20.11  -c 1 -f 1 -t 14\n/// --sender-mode 10.10.20.21\n\npub async fn test_case14(\n\t_index: SlotId,\n\tsettings: Settings,\n\tstates: Arc\u003cRwLock\u003cHashMap\u003cPlayerId, PlayerState\u003e\u003e\u003e,\n) -\u003e anyhow::Result\u003c()\u003e {\n\tlet _ = states;\n\tlet auth: \u0026[u8] = \u0026[];\n\tlet mut rtt_count: u32 = 0;\n\tlet mut rtt_sum: f32 = 0.0;\n\tlet rtt_avg: f32;\n\tlet mut sent_time: Instant;\n\tlet mut recv_time: Duration;\n\tlet is_listener: bool;\n\tlet addr: String;\n\tlet mut session1 =\n\t\tcrate::create_session(\u0026settings.server_addr[0], auth).await?;\n\n\tunsafe { CONNECTIONS_COUNT.fetch_add(1, Ordering::Relaxed) };\n\n\tprintln!(\n\t\t\"server: {} -\u003e session id: {}\",\n\t\tsettings.server_addr[0],\n\t\tsession1.id(),\n\t);\n\n\tif !settings.listener_mode.is_empty() {\n\t\tis_listener = true;\n\t\taddr = format!(\"{}:8888\", settings.listener_mode);\n\t} else if !settings.sender_mode.is_empty() {\n\t\tis_listener = false;\n\t\taddr = format!(\"{}:8888\", settings.sender_mode);\n\t} else {\n\t\tprintln!(\"Atleast one argument required --listener-mode / --sender-mode\");\n\t\tstd::process::exit(1);\n\t}\n\n\tlet socket = UdpSocket::bind(\"0.0.0.0:8888\").await?;\n\n\tif is_listener {\n\t\tprintln!(\"Listener Mode. Sender Addr: {}\", addr);\n\t\tlet mut sender_x: f32;\n\t\tlet mut sender_y: f32;\n\t\tlet mut sender_z: f32;\n\t\tlet mut send_buffer: Vec\u003cu8\u003e = vec![];\n\t\tlet mut recv_buffer: Vec\u003cu8\u003e = vec![];\n\n\t\tsend_buffer.resize(256, 0);\n\n\t\tlet send_msg = Msg {\n\t\t\tmsg_type: MsgType::PlayerId,\n\t\t\tplayer_id: session1.id(),\n\t\t\tpos_x: 0.0,\n\t\t\tpos_y: 0.0,\n\t\t\tpos_z: 0.0,\n\t\t};\n\n\t\tunsafe {\n\t\t\t*(send_buffer.as_mut_ptr() as *mut Msg) = send_msg;\n\t\t}\n\n\t\t//\n\t\tloop {\n\t\t\twhile socket.try_recv_buf_from(\u0026mut recv_buffer).is_err() {\n\t\t\t\tif settings.verbose \u003e 1 {\n\t\t\t\t\tprint_buffer(\u0026send_buffer, \"Sending Msg:\");\n\t\t\t\t}\n\t\t\t\tlet _ = socket.send_to(\u0026send_buffer, \u0026addr).await;\n\t\t\t\trecv_buffer.clear();\n\t\t\t\ttokio::time::sleep(Duration::from_secs(1)).await;\n\t\t\t}\n\n\t\t\tif settings.verbose \u003e 1 {\n\t\t\t\tprint_buffer(\u0026recv_buffer, \"Recvd Msg:\");\n\t\t\t}\n\n\t\t\tlet msg = unsafe { \u0026mut *(recv_buffer.as_ptr() as *mut Msg) };\n\n\t\t\tmatch msg.msg_type {\n\t\t\t\tMsgType::PlayerId =\u003e {\n\t\t\t\t\tif settings.verbose \u003e 0 {\n\t\t\t\t\t\tprintln!(\"Received Msg Type: PlayerId\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t_ =\u003e continue,\n\t\t\t}\n\t\t}\n\t\tlet recv_msg = unsafe { \u0026mut *(recv_buffer.as_ptr() as *mut Msg) };\n\n\t\tlet sender_id: PlayerId = recv_msg.player_id;\n\t\tsender_x = recv_msg.pos_x;\n\t\tsender_y = recv_msg.pos_y;\n\t\tsender_z = recv_msg.pos_z;\n\n\t\tif settings.verbose \u003e 0 {\n\t\t\tprintln!(\n\t\t\t\t\"\\tSender details: Id:{} X:{} Y:{} Z:{}\",\n\t\t\t\tsender_id, sender_x, sender_y, sender_z\n\t\t\t);\n\t\t}\n\n\t\tlet listener_x: f32 = sender_x + 0.2;\n\t\tlet listener_y: f32 = sender_y + 0.2;\n\t\tlet listener_z: f32 = sender_z + 0.2;\n\n\t\tset_player_position(\n\t\t\t\u0026mut session1,\n\t\t\tsettings.clone(),\n\t\t\tlistener_x,\n\t\t\tlistener_y,\n\t\t\tlistener_z,\n\t\t)\n\t\t.await?;\n\t\tlet _response = session1.ticks().receive().await?;\n\n\t\t// STAGE: Measure Avg RTT\n\t\tlet send_msg = Msg {\n\t\t\tmsg_type: MsgType::RttMeasurement,\n\t\t\tplayer_id: session1.id(),\n\t\t\tpos_x: 0.0,\n\t\t\tpos_y: 0.0,\n\t\t\tpos_z: 0.0,\n\t\t};\n\t\tunsafe {\n\t\t\t*(send_buffer.as_mut_ptr() as *mut Msg) = send_msg;\n\t\t}\n\t\tloop {\n\t\t\tlet start = Instant::now();\n\t\t\tsocket.send_to(\u0026send_buffer, \u0026addr).await?;\n\t\t\tlet _ = socket.recv(\u0026mut recv_buffer).await?;\n\t\t\tlet end = start.elapsed();\n\t\t\tlet recv_msg = unsafe { \u0026mut *(recv_buffer.as_ptr() as *mut Msg) };\n\t\t\tmatch recv_msg.msg_type {\n\t\t\t\tMsgType::RttMeasurement =\u003e {\n\t\t\t\t\trtt_sum += end.as_micros() as f32;\n\t\t\t\t\trtt_count += 1;\n\t\t\t\t\tif settings.verbose \u003e 0 {\n\t\t\t\t\t\tif end.as_micros() \u003e 1000 {\n\t\t\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\t\t\"Listener to Sender to Listener Time: {} ms\",\n\t\t\t\t\t\t\t\tend.as_millis()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\t\t\"Listener to Sender to Listener Time: {} micro sec\",\n\t\t\t\t\t\t\t\tend.as_micros()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif rtt_count == 20 {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tMsgType::PlayerId =\u003e todo!(),\n\t\t\t\tMsgType::RttMeasurementDone =\u003e todo!(),\n\t\t\t\tMsgType::StartTest =\u003e todo!(),\n\t\t\t\tMsgType::TestPosition =\u003e todo!(),\n\t\t\t}\n\t\t}\n\t\trtt_avg = rtt_sum / (rtt_count as f32);\n\t\tlet sender_to_listener_time: f32 = rtt_avg / 2.0;\n\t\tprintln!(\n\t\t\t\"Avg Direct Sender - Listener Time: {} micro sec\",\n\t\t\tsender_to_listener_time\n\t\t);\n\n\t\t// STAGE: RTT Measurement Done\n\t\tlet send_msg = Msg {\n\t\t\tmsg_type: MsgType::RttMeasurementDone,\n\t\t\tplayer_id: session1.id(),\n\t\t\tpos_x: 0.0,\n\t\t\tpos_y: 0.0,\n\t\t\tpos_z: 0.0,\n\t\t};\n\t\tunsafe {\n\t\t\t*(send_buffer.as_mut_ptr() as *mut Msg) = send_msg;\n\t\t}\n\t\tsocket.send_to(\u0026send_buffer, \u0026addr).await?;\n\n\t\t// STAGE: Start Test\n\t\tloop {\n\t\t\tlet send_msg = Msg {\n\t\t\t\tmsg_type: MsgType::StartTest,\n\t\t\t\tplayer_id: session1.id(),\n\t\t\t\tpos_x: 0.0,\n\t\t\t\tpos_y: 0.0,\n\t\t\t\tpos_z: 0.0,\n\t\t\t};\n\t\t\tunsafe {\n\t\t\t\t*(send_buffer.as_mut_ptr() as *mut Msg) = send_msg;\n\t\t\t}\n\t\t\tsent_time = Instant::now();\n\t\t\tsocket.send_to(\u0026send_buffer, \u0026addr).await?;\n\n\t\t\tsocket.recv(\u0026mut recv_buffer).await?;\n\t\t\tif settings.verbose \u003e 1 {\n\t\t\t\tprint_buffer(\u0026recv_buffer, \"Recvd Msg:\");\n\t\t\t}\n\n\t\t\tlet msg = unsafe { \u0026mut *(recv_buffer.as_ptr() as *mut Msg) };\n\n\t\t\tmatch msg.msg_type {\n\t\t\t\tMsgType::TestPosition =\u003e {\n\t\t\t\t\tif settings.verbose \u003e 0 {\n\t\t\t\t\t\tprintln!(\"Received Msg Type: TestPosition\");\n\t\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\t\"\\t Sender Position : {}, {}, {}\",\n\t\t\t\t\t\t\tmsg.pos_x, msg.pos_y, msg.pos_z\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tsender_x = msg.pos_x;\n\t\t\t\t\tsender_y = msg.pos_y;\n\t\t\t\t\tsender_z = msg.pos_z;\n\t\t\t\t}\n\t\t\t\t_ =\u003e continue,\n\t\t\t}\n\t\t\tlet mut iter: u32 = 0;\n\t\t\tloop {\n\t\t\t\titer += 1;\n\t\t\t\tset_player_position(\n\t\t\t\t\t\u0026mut session1,\n\t\t\t\t\tsettings.clone(),\n\t\t\t\t\tlistener_x,\n\t\t\t\t\tlistener_y,\n\t\t\t\t\tlistener_z,\n\t\t\t\t)\n\t\t\t\t.await?;\n\t\t\t\tlet response = session1.ticks().receive().await?;\n\t\t\t\trecv_time = sent_time.elapsed();\n\n\t\t\t\tif check_response(response, sender_id, sender_x, sender_y, sender_z) {\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"RTT Measured: {} - {}  = {} microsec in querying server {} times\",\n\t\t\t\t\t\t(recv_time.as_micros() as u64),\n\t\t\t\t\t\t(sender_to_listener_time as u64),\n\t\t\t\t\t\t(recv_time.as_micros() as u64) - (sender_to_listener_time as u64),\n\t\t\t\t\t\titer\n\t\t\t\t\t);\n\t\t\t\t\thistogram!(\n\t\t\t\t\t\t\"player_update_latency\",\n\t\t\t\t\t\t(recv_time.as_micros() as f64) - (sender_to_listener_time as f64),\n\t\t\t\t\t\t\"@unit\" =\u003e metrics_cloudwatch::Unit::Microseconds\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (recv_time.as_micros() as u64 - sender_to_listener_time as u64)\n\t\t\t\t\t\u003e (sender_to_listener_time as u64 * 4)\n\t\t\t\t{\n\t\t\t\t\tprintln!(\"Timed out. Update missed.\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tprintln!(\"Sender Mode. Listener Addr: {}\", addr);\n\t\tlet pos_x =\n\t\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max);\n\t\tlet pos_y =\n\t\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max);\n\t\tlet pos_z =\n\t\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max);\n\t\tlet mut send_buffer: Vec\u003cu8\u003e = vec![];\n\t\tlet mut recv_buffer: Vec\u003cu8\u003e = vec![];\n\n\t\tsend_buffer.resize(256, 0);\n\n\t\tloop {\n\t\t\tif socket.recv(\u0026mut recv_buffer).await.is_err() {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet recv_msg = unsafe { \u0026mut *(recv_buffer.as_ptr() as *mut Msg) };\n\t\t\tmatch recv_msg.msg_type {\n\t\t\t\tMsgType::PlayerId =\u003e {\n\t\t\t\t\tif settings.verbose \u003e 0 {\n\t\t\t\t\t\tprintln!(\"Recived Msg Type: PlayerId\");\n\t\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\t\"\\t Id:{} X:{} Y:{} Z:{}\",\n\t\t\t\t\t\t\trecv_msg.player_id,\n\t\t\t\t\t\t\trecv_msg.pos_x,\n\t\t\t\t\t\t\trecv_msg.pos_y,\n\t\t\t\t\t\t\trecv_msg.pos_z\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet send_msg = Msg {\n\t\t\t\t\t\tmsg_type: MsgType::PlayerId,\n\t\t\t\t\t\tplayer_id: session1.id(),\n\t\t\t\t\t\tpos_x,\n\t\t\t\t\t\tpos_y,\n\t\t\t\t\t\tpos_z,\n\t\t\t\t\t};\n\t\t\t\t\tunsafe {\n\t\t\t\t\t\t*(send_buffer.as_mut_ptr() as *mut Msg) = send_msg;\n\t\t\t\t\t}\n\t\t\t\t\tif settings.verbose \u003e 1 {\n\t\t\t\t\t\tfor b in send_buffer.bytes() {\n\t\t\t\t\t\t\tprint!(\"{} \", b.expect(\"msg\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprintln!();\n\t\t\t\t\t}\n\t\t\t\t\tlet _ = socket.send_to(\u0026send_buffer, \u0026addr).await;\n\t\t\t\t}\n\t\t\t\tMsgType::RttMeasurement =\u003e {\n\t\t\t\t\tif settings.verbose \u003e 0 {\n\t\t\t\t\t\tprintln!(\"Recived Msg Type: RttMeasurement\");\n\t\t\t\t\t}\n\t\t\t\t\tunsafe {\n\t\t\t\t\t\t(*(send_buffer.as_mut_ptr() as *mut Msg)).msg_type =\n\t\t\t\t\t\t\tMsgType::RttMeasurement;\n\t\t\t\t\t}\n\t\t\t\t\tlet _ = socket.send_to(\u0026send_buffer, \u0026addr).await;\n\t\t\t\t}\n\t\t\t\tMsgType::RttMeasurementDone =\u003e {\n\t\t\t\t\tif settings.verbose \u003e 0 {\n\t\t\t\t\t\tprintln!(\"Recived Msg Type: RttMeasurementDone\");\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tMsgType::StartTest =\u003e {\n\t\t\t\t\tif settings.verbose \u003e 0 {\n\t\t\t\t\t\tprintln!(\"Recived Msg Type: StartTest\");\n\t\t\t\t\t}\n\t\t\t\t\tlet offset: f32 = rand::thread_rng().gen_range(0.0..1.0);\n\t\t\t\t\tset_player_position(\n\t\t\t\t\t\t\u0026mut session1,\n\t\t\t\t\t\tsettings.clone(),\n\t\t\t\t\t\tpos_x + offset,\n\t\t\t\t\t\tpos_y + offset,\n\t\t\t\t\t\tpos_z + offset,\n\t\t\t\t\t)\n\t\t\t\t\t.await?;\n\t\t\t\t\tlet send_msg = Msg {\n\t\t\t\t\t\tmsg_type: MsgType::TestPosition,\n\t\t\t\t\t\tplayer_id: session1.id(),\n\t\t\t\t\t\tpos_x: pos_x + offset,\n\t\t\t\t\t\tpos_y: pos_y + offset,\n\t\t\t\t\t\tpos_z: pos_z + offset,\n\t\t\t\t\t};\n\t\t\t\t\tunsafe {\n\t\t\t\t\t\t*(send_buffer.as_mut_ptr() as *mut Msg) = send_msg;\n\t\t\t\t\t}\n\t\t\t\t\tlet _ = socket.send_to(\u0026send_buffer, \u0026addr).await;\n\t\t\t\t}\n\t\t\t\tMsgType::TestPosition =\u003e {\n\t\t\t\t\tif settings.verbose \u003e 0 {\n\t\t\t\t\t\tprintln!(\"Recived Invalid Msg Type: TestPosition\");\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","devtools","stress","src","test_case2.rs"],"content":"use {\n\tcrate::{create_session, PlayerState, Settings},\n\tquark_client_sdk::{\n\t\tAttributeId,\n\t\tPlayerId,\n\t\tRelevance,\n\t\tSession,\n\t\tWellKnownAttribute,\n\t},\n\trand::Rng,\n\tstd::{\n\t\tcollections::HashMap,\n\t\tsync::{\n\t\t\tatomic::{AtomicUsize, Ordering},\n\t\t\tArc,\n\t\t\tRwLock,\n\t\t},\n\t\ttime::{Duration, Instant},\n\t},\n};\n\nstatic mut CONNECTIONS_COUNT: AtomicUsize = AtomicUsize::new(0);\n\n/// ### Test Case 2: Player Session Resume Simulation\n///\n/// Description:\n/// This Scenario is implemented to send configurable player data to the server.\n/// After a specified period, each player session re-establishes a new\n/// connection to the server. This scenario tests the server's resume feature.\n\npub async fn test_case2(\n\t_index: usize,\n\tsettings: Settings,\n\tstates: Arc\u003cRwLock\u003cHashMap\u003cPlayerId, PlayerState\u003e\u003e\u003e,\n) -\u003e anyhow::Result\u003c()\u003e {\n\tlet _ = states;\n\tlet auth: \u0026[u8] = \u0026[];\n\tlet mut session = create_session(\u0026settings.server_addr[0], auth).await?;\n\tlet last_reconnect = Instant::now();\n\tlet reconnect_every = Duration::from_secs(settings.run_period as u64);\n\tlet wait_time =\n\t\tDuration::from_millis((1000.0f32 / settings.tick_frequency) as u64);\n\tlet mut resume_token = session.resume_token().to_vec();\n\tlet connection_id;\n\tunsafe { connection_id = CONNECTIONS_COUNT.fetch_add(1, Ordering::Relaxed) };\n\n\tif settings.verbose \u003e 0 {\n\t\tprintln!(\n\t\t\t\"connection #{} -\u003e session id: {}\",\n\t\t\tconnection_id,\n\t\t\tsession.id(),\n\t\t);\n\t}\n\n\tloop {\n\t\t'inner: loop {\n\t\t\ttokio::time::sleep(wait_time).await;\n\n\t\t\tlet mut tick = session.ticks().build();\n\t\t\ttick.set_interest_radius(Relevance::new(settings.interest_radius));\n\n\t\t\ttick\n\t\t\t\t.build_player()\n\t\t\t\t.build_attributes(1)\n\t\t\t\t.set_vec3(\n\t\t\t\t\tWellKnownAttribute::Position as AttributeId,\n\t\t\t\t\t(\n\t\t\t\t\t\trand::thread_rng()\n\t\t\t\t\t\t\t.gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\t\trand::thread_rng()\n\t\t\t\t\t\t\t.gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\t\trand::thread_rng()\n\t\t\t\t\t\t\t.gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t\t.unwrap();\n\n\t\t\tsession.ticks().send(tick).unwrap();\n\n\t\t\tif last_reconnect.elapsed() \u003e reconnect_every {\n\t\t\t\tdrop(session);\n\t\t\t\tbreak 'inner;\n\t\t\t}\n\t\t}\n\n\t\tsession = Session::resume(\u0026settings.server_addr[0], \u0026resume_token).await?;\n\t\tresume_token = session.resume_token().to_vec();\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","devtools","stress","src","test_case20.rs"],"content":"use {\n\tcrate::Settings,\n\tmetrics::histogram,\n\tstd::{\n\t\tcollections::HashMap,\n\t\tnet::SocketAddr,\n\t\tstr,\n\t\ttime::{Duration, Instant},\n\t},\n\ttokio::{net::UdpSocket, time::timeout},\n};\n\n/// ### Test Case 20: Functional heartbeat message test\n///\n/// Description:\n/// This test is to verify the heartbeart message in quark.\n/// Purpose of this test is to verify Quark server heartbeat\n/// message sends within given period and to verify the source\n/// of the heartbeat message.\n///\n/// https://app.clickup.com/t/8693nkg62\n\npub async fn test_case20(settings: Settings) -\u003e anyhow::Result\u003c()\u003e {\n\tlet socket = UdpSocket::bind(\u0026settings.heartbeat_listen_addr)\n\t\t.await\n\t\t.expect(\"Failed to bind UDP socket\");\n\tlet mut timeout_duration = Duration::from_secs(settings.heartbeat_timeout);\n\n\tlet start_time = Instant::now();\n\tlet mut test_first_msg_received = false;\n\tlet mut loop_count = 0;\n\tlet period_frm_millis = settings.heartbeat_period * 1000;\n\tlet time_duration = period_frm_millis as f32\n\t\t+ period_frm_millis as f32 * settings.heartbeat_tolerance;\n\tlet heartbeat_period = time_duration as u64;\n\n\tlet mut heartbeat_source_time_map: HashMap\u003cSocketAddr, (Instant, bool)\u003e =\n\t\tHashMap::new();\n\n\tsettings\n\t\t.server_addr\n\t\t.iter()\n\t\t.filter_map(|s| s.parse::\u003cSocketAddr\u003e().ok())\n\t\t.for_each(|addr| {\n\t\t\theartbeat_source_time_map\n\t\t\t\t.entry(addr)\n\t\t\t\t.or_insert_with(|| (Instant::now(), false));\n\t\t});\n\n\tloop {\n\t\tlet mut buffer = [0; 1024];\n\t\tmatch timeout(timeout_duration, socket.recv_from(\u0026mut buffer)).await {\n\t\t\tOk(Ok((size, addr))) =\u003e {\n\t\t\t\tif let Some(\u0026(receive_time, socket_first_message_received)) =\n\t\t\t\t\theartbeat_source_time_map.get(\u0026addr)\n\t\t\t\t{\n\t\t\t\t\t// Process received data (heartbeat message)\n\t\t\t\t\tlet data = \u0026buffer[..size];\n\t\t\t\t\tlet message = str::from_utf8(data).unwrap();\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"Received UDP heartbeat message from {:?}: {:?}\",\n\t\t\t\t\t\taddr, message\n\t\t\t\t\t);\n\n\t\t\t\t\tif let Some(error) = heartbeat_source_time_map\n\t\t\t\t\t\t.clone()\n\t\t\t\t\t\t.iter()\n\t\t\t\t\t\t.find_map(|(scktaddr, (last_msg_time, first_msg_received))| {\n\t\t\t\t\t\t\tif *first_msg_received\n\t\t\t\t\t\t\t\t\u0026\u0026 last_msg_time.elapsed().as_millis() \u003e heartbeat_period.into()\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tSome(format!(\n\t\t\t\t\t\t\t\t\t\"Heartbeat message time out error:No subsequent message \\\n\t\t\t\t\t\t\t\t\t received within the expected time period from: {:?}\",\n\t\t\t\t\t\t\t\t\tscktaddr\n\t\t\t\t\t\t\t\t))\n\t\t\t\t\t\t\t} else if !*first_msg_received\n\t\t\t\t\t\t\t\t\u0026\u0026 last_msg_time.elapsed().as_secs()\n\t\t\t\t\t\t\t\t\t\u003e settings.heartbeat_timeout\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tSome(format!(\n\t\t\t\t\t\t\t\t\t\"Heartbeat message time out error:No any message received \\\n\t\t\t\t\t\t\t\t\t within the expected time period from: {:?}\",\n\t\t\t\t\t\t\t\t\tscktaddr\n\t\t\t\t\t\t\t\t))\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tNone\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}) {\n\t\t\t\t\t\treturn Err(anyhow::anyhow!(error));\n\t\t\t\t\t}\n\t\t\t\t\tif !test_first_msg_received {\n\t\t\t\t\t\ttimeout_duration = Duration::from_millis(heartbeat_period);\n\t\t\t\t\t\ttest_first_msg_received = true;\n\t\t\t\t\t}\n\t\t\t\t\tif socket_first_message_received {\n\t\t\t\t\t\tlet elapsed = receive_time.elapsed();\n\t\t\t\t\t\thistogram!(\n\t\t\t\t\t\t\t\"heartbeat_period_latency\", elapsed.as_micros() as f64,\n\t\t\t\t\t\t\t\"@unit\" =\u003e metrics_cloudwatch::Unit::Microseconds,\n\t\t\t\t\t\t\t\"instance_id\" =\u003e addr.to_string()\n\t\t\t\t\t\t);\n\t\t\t\t\t\theartbeat_source_time_map.entry(addr).and_modify(|value| {\n\t\t\t\t\t\t\tvalue.0 = Instant::now();\n\t\t\t\t\t\t\tvalue.1 = true\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\theartbeat_source_time_map.entry(addr).and_modify(|value| {\n\t\t\t\t\t\t\tvalue.0 = Instant::now();\n\t\t\t\t\t\t\tvalue.1 = true\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tloop_count += 1;\n\t\t\t\t\tif (settings.run_period \u003e 0\n\t\t\t\t\t\t\u0026\u0026 start_time.elapsed().as_secs() \u003e settings.run_period.into())\n\t\t\t\t\t\t|| (settings.run_loop \u003e 1 \u0026\u0026 settings.run_loop \u003e loop_count)\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tprintln!(\"Received heartbeat from unexpected source: {}\", addr);\n\t\t\t\t\treturn Err(anyhow::anyhow!(\"unexpected source\"));\n\t\t\t\t}\n\t\t\t}\n\t\t\tOk(Err(e)) =\u003e {\n\t\t\t\teprintln!(\"Error receiving UDP packet: {}\", e);\n\t\t\t\treturn Err(anyhow::anyhow!(\"Error receiving UDP packet\"));\n\t\t\t}\n\t\t\tErr(e) =\u003e {\n\t\t\t\teprintln!(\"ERROR timeout:{}\", e);\n\t\t\t\treturn Err(anyhow::anyhow!(\n\t\t\t\t\t\"Heartbeat message timeout error:No message received within the \\\n\t\t\t\t\t expected time period:{:?}\",\n\t\t\t\t\ttimeout_duration\n\t\t\t\t));\n\t\t\t}\n\t\t}\n\t}\n\tOk(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","devtools","stress","src","test_case3.rs"],"content":"use {\n\tcrate::{PlayerState, Settings, SlotId},\n\tquark_client_sdk::{\n\t\tAttributeId,\n\t\tPlayerId,\n\t\tRelevance,\n\t\tSession,\n\t\tValue,\n\t\tWellKnownAttribute,\n\t},\n\trand::Rng,\n\tstd::{\n\t\tcollections::HashMap,\n\t\tsync::{\n\t\t\tatomic::{AtomicUsize, Ordering},\n\t\t\tArc,\n\t\t\tRwLock,\n\t\t},\n\t\ttime::{Duration, Instant},\n\t},\n};\n\nstatic mut CONNECTIONS_COUNT: AtomicUsize = AtomicUsize::new(0);\n\n/// ### Test Case 3: Player Movement Simulation and Validate Responses\n///\n/// Description:\n/// Scenario is designed to send configurable player data to the server in a\n/// massive manner. The test verifies responses and waits for a specified time\n/// for correct data. If the correct data does not arrive within the specified\n/// timeout, an ERROR is reported.\n\npub async fn test_case3(\n\tindex: SlotId,\n\tsettings: Settings,\n\tstates: Arc\u003cRwLock\u003cHashMap\u003cPlayerId, PlayerState\u003e\u003e\u003e,\n) -\u003e anyhow::Result\u003c()\u003e {\n\tlet _ = index;\n\tlet auth: \u0026[u8] = \u0026[];\n\tlet mut session =\n\t\tcrate::create_session(\u0026settings.server_addr[0], auth).await?;\n\tlet mut last_reconnect = Instant::now();\n\tlet reconnect_every = Duration::from_secs(settings.run_period as u64);\n\tlet wait_time =\n\t\tDuration::from_millis((1000.0f32 / settings.tick_frequency) as u64);\n\tlet mut resume_token = session.resume_token().to_vec();\n\tlet mut counter = 0u32;\n\tlet mut last_error_ts = Instant::now();\n\tlet mut player_state_error_1: PlayerState = PlayerState::default();\n\tlet mut player_state_error_2: PlayerState = PlayerState::default();\n\n\tlet mut pos_x =\n\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max);\n\tlet mut pos_y =\n\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max);\n\tlet mut pos_z =\n\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max);\n\n\tlet mut rot_x =\n\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max);\n\tlet mut rot_y =\n\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max);\n\tlet mut rot_z =\n\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max);\n\n\tlet mut state = PlayerState {\n\t\trotation: (rot_x, rot_y, rot_z),\n\t\tposition: (pos_x, pos_y, pos_z),\n\t};\n\n\tstates\n\t\t.write()\n\t\t.expect(\"error\")\n\t\t.entry(session.id())\n\t\t.or_insert(state);\n\n\tlet mut result = 0u32;\n\tlet mut received_states = HashMap::new();\n\n\tunsafe { CONNECTIONS_COUNT.fetch_add(1, Ordering::Relaxed) };\n\n\tif settings.verbose \u003e 0 {\n\t\tprintln!(\n\t\t\t\"connection #{} -\u003e session id: {}\",\n\t\t\tunsafe { CONNECTIONS_COUNT.load(Ordering::Relaxed) },\n\t\t\tsession.id(),\n\t\t);\n\t}\n\n\tloop {\n\t\t'inner: loop {\n\t\t\ttokio::time::sleep(wait_time).await;\n\n\t\t\tlet mut tick = session.ticks().build();\n\t\t\ttick.set_interest_radius(Relevance::new(settings.interest_radius));\n\n\t\t\ttick\n\t\t\t\t.build_player()\n\t\t\t\t.build_attributes(2)\n\t\t\t\t.set_vec3(\n\t\t\t\t\tWellKnownAttribute::Position as AttributeId,\n\t\t\t\t\t(pos_x, pos_y, pos_z),\n\t\t\t\t)\n\t\t\t\t.unwrap()\n\t\t\t\t.set_vec3(\n\t\t\t\t\tWellKnownAttribute::Rotation as AttributeId,\n\t\t\t\t\t(rot_x, rot_y, rot_z),\n\t\t\t\t)\n\t\t\t\t.unwrap();\n\n\t\t\tsession.ticks().send(tick)?;\n\n\t\t\tlet update = session.ticks().receive().await?;\n\n\t\t\tlet mut temp = 0u32;\n\n\t\t\tfor player in update.players()? {\n\t\t\t\tif settings.verbose \u003e 0 {\n\t\t\t\t\tprintln!(\"  Player: {}\", player.id());\n\t\t\t\t}\n\t\t\t\tlet mut state = PlayerState::default();\n\t\t\t\t// this flag is used for detecting if position and rotation were\n\t\t\t\t// received during single update\n\t\t\t\tlet mut flag_pos = false;\n\t\t\t\tlet mut flag_rot = false;\n\n\t\t\t\tfor attrib in player.attribs() {\n\t\t\t\t\tif settings.verbose \u003e 0 {\n\t\t\t\t\t\tprintln!(\"    {:?}: {:?}\", attrib.key, attrib.value);\n\t\t\t\t\t}\n\n\t\t\t\t\tif attrib.key == WellKnownAttribute::Position as AttributeId {\n\t\t\t\t\t\tlet value = attrib.value.clone();\n\n\t\t\t\t\t\tmatch value {\n\t\t\t\t\t\t\tValue::Vec2((x, y)) =\u003e {\n\t\t\t\t\t\t\t\tstate.position = (x, y, 0f32);\n\t\t\t\t\t\t\t\tflag_pos = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tValue::Vec3((x, y, z)) =\u003e {\n\t\t\t\t\t\t\t\tstate.position = (x, y, z);\n\t\t\t\t\t\t\t\tflag_pos = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_ =\u003e {\n\t\t\t\t\t\t\t\t// illegal type here\n\t\t\t\t\t\t\t\tpanic!(\"unexpected message variant\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif settings.verbose \u003e 0 {\n\t\t\t\t\t\t\tprintln!(\"player position {:?}\", value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif attrib.key == WellKnownAttribute::Rotation as AttributeId {\n\t\t\t\t\t\tlet value = attrib.value;\n\n\t\t\t\t\t\tmatch value {\n\t\t\t\t\t\t\tValue::Vec2((rot_x, rot_y)) =\u003e {\n\t\t\t\t\t\t\t\tstate.rotation = (rot_x, rot_y, 0f32);\n\t\t\t\t\t\t\t\tflag_rot = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tValue::Vec3((rot_x, rot_y, rot_z)) =\u003e {\n\t\t\t\t\t\t\t\tstate.rotation = (rot_x, rot_y, rot_z);\n\t\t\t\t\t\t\t\tflag_rot = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_ =\u003e {\n\t\t\t\t\t\t\t\t// illegal type here\n\t\t\t\t\t\t\t\tpanic!(\"unexpected message variant\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif settings.verbose \u003e 0 {\n\t\t\t\t\t\t\tprintln!(\"player rotation {:?}\", value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// updating received records can be only done if position and rotation\n\t\t\t\t// have been received otherwise hashmap could be updated with 0\n\t\t\t\t// storing received data\n\t\t\t\treceived_states.entry(player.id()).and_modify(\n\t\t\t\t\t|player_state: \u0026mut PlayerState| {\n\t\t\t\t\t\tlet state = player_state;\n\t\t\t\t\t\tif flag_pos {\n\t\t\t\t\t\t\tstate.position = (pos_x, pos_y, pos_z);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif flag_rot {\n\t\t\t\t\t\t\tstate.rotation = (rot_x, rot_y, rot_z);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\t// verify\n\t\t\t\tlet (tmp, st1, st2) =\n\t\t\t\t\tvicinity_verifier(\u0026received_states, states.clone());\n\t\t\t\tif tmp \u003e 0 {\n\t\t\t\t\ttemp += tmp;\n\t\t\t\t\tplayer_state_error_1 = st1;\n\t\t\t\t\tplayer_state_error_2 = st2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif temp == 0 {\n\t\t\t\tresult = 0;\n\t\t\t\tif settings.verbose \u003e 0 {\n\t\t\t\t\tprintln!(\"======= PASS ======\");\n\t\t\t\t}\n\n\t\t\t\tif settings.run_period \u003e 0 \u0026\u0026 last_reconnect.elapsed() \u003e reconnect_every\n\t\t\t\t{\n\t\t\t\t\tdrop(session);\n\t\t\t\t\tbreak 'inner;\n\t\t\t\t}\n\n\t\t\t\t// generating new player state data\n\t\t\t\tpos_x =\n\t\t\t\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max);\n\t\t\t\tpos_y =\n\t\t\t\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max);\n\t\t\t\tpos_z =\n\t\t\t\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max);\n\n\t\t\t\trot_x =\n\t\t\t\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max);\n\t\t\t\trot_y =\n\t\t\t\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max);\n\t\t\t\trot_z =\n\t\t\t\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max);\n\n\t\t\t\tstate = PlayerState {\n\t\t\t\t\trotation: (rot_x, rot_y, rot_z),\n\t\t\t\t\tposition: (pos_x, pos_y, pos_z),\n\t\t\t\t};\n\n\t\t\t\tstates\n\t\t\t\t\t.write()\n\t\t\t\t\t.expect(\"error\")\n\t\t\t\t\t.entry(session.id())\n\t\t\t\t\t.or_insert(state);\n\t\t\t} else {\n\t\t\t\tif temp \u003e result {\n\t\t\t\t\tif result == 0 {\n\t\t\t\t\t\tlast_error_ts = Instant::now();\n\t\t\t\t\t}\n\t\t\t\t\tresult = temp;\n\t\t\t\t}\n\n\t\t\t\t// checking if timeout reached\n\t\t\t\tif settings.verbose \u003e 0 {\n\t\t\t\t\tprintln!(\"player state data mismatch\");\n\t\t\t\t}\n\n\t\t\t\tlet error_period = last_error_ts.elapsed().as_millis();\n\t\t\t\tif error_period \u003e settings.timeout as u128 {\n\t\t\t\t\t// break this thread and report error because player state data\n\t\t\t\t\t// mismatch too long\n\t\t\t\t\tlet id = session.id();\n\t\t\t\t\tprintln!(\"ERROR timeout: {error_period}\");\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"player state received:   id:{id} - {:?}\",\n\t\t\t\t\t\tplayer_state_error_1\n\t\t\t\t\t);\n\t\t\t\t\tprintln!(\"player state registered: {:?}\", player_state_error_2);\n\n\t\t\t\t\treturn Err(anyhow::anyhow!(\"player state data are mismatch\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcounter += 1;\n\n\t\t// checking, if procedure of connecting/disconnecting is enabled\n\t\tif settings.run_loop \u003e 0 \u0026\u0026 counter \u003e= settings.run_loop {\n\t\t\tbreak;\n\t\t}\n\n\t\tsession = Session::resume(\u0026settings.server_addr[0], \u0026resume_token).await?;\n\t\tresume_token = session.resume_token().to_vec();\n\t\tlast_reconnect = Instant::now();\n\t\tprintln!(\"resume\");\n\t}\n\tOk(())\n}\n\nfn vicinity_verifier(\n\treceived: \u0026HashMap\u003cPlayerId, PlayerState\u003e,\n\tstates: Arc\u003cRwLock\u003cHashMap\u003cPlayerId, PlayerState\u003e\u003e\u003e,\n) -\u003e (u32, PlayerState, PlayerState) {\n\tlet mut counter = 0u32;\n\tlet mut state_1 = PlayerState::default();\n\tlet mut state_2 = PlayerState::default();\n\n\tfor (id, rcv) in received {\n\t\tmatch states.read().expect(\"no data found\").get(id) {\n\t\t\tNone =\u003e {\n\t\t\t\tcounter += 1;\n\t\t\t}\n\t\t\tSome(value) =\u003e {\n\t\t\t\tif value != rcv {\n\t\t\t\t\tcounter += 1;\n\t\t\t\t\tstate_1 = *rcv;\n\t\t\t\t\tstate_2 = *value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t(counter, state_1, state_2)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","devtools","stress","src","test_case4.rs"],"content":"use {\n\tcrate::{PlayerState, Settings, SlotId},\n\tquark_client_sdk::{AttributeId, PlayerId, Relevance, WellKnownAttribute},\n\trand::Rng,\n\tstd::{\n\t\tcollections::HashMap,\n\t\tsync::{\n\t\t\tatomic::{AtomicUsize, Ordering},\n\t\t\tArc,\n\t\t\tRwLock,\n\t\t},\n\t\ttime::{Duration, Instant},\n\t},\n};\n\nstatic mut CONNECTIONS_COUNT: AtomicUsize = AtomicUsize::new(0);\n\n/// ### Test Case 4: Player Session Connect/Disconnect Simulation\n///\n/// Description:\n/// Scenario which serves as a stress test for connecting and disconnecting from\n/// the server. This script initiates multiple client instances, establishing\n/// connections with the server. Once connected, the client instances repeatedly\n/// disconnect after a specified period of time and then reconnect to the server\n/// in a continuous loop.\n///\n/// https://app.clickup.com/t/8693f5z5a\n///\n/// Important Commands:\n/// --disconnect-timeout : Specified player connection time in milliseconds\n\npub async fn test_case4(\n\tindex: SlotId,\n\tsettings: Settings,\n\tstates: Arc\u003cRwLock\u003cHashMap\u003cPlayerId, PlayerState\u003e\u003e\u003e,\n) -\u003e anyhow::Result\u003c()\u003e {\n\tlet mut last_connect = Instant::now();\n\tlet start_time = Instant::now();\n\tlet disconnect_every = Duration::from_millis(settings.disconnect_timeout);\n\tlet wait_time: Duration =\n\t\tDuration::from_millis((1000.0f32 / settings.tick_frequency) as u64);\n\tlet auth: \u0026[u8] = \u0026[];\n\tlet mut state;\n\tlet mut loop_count = 0;\n\tlet server_index = index % settings.server_addr.len() as u32;\n\n\t'outer: loop {\n\t\ttokio::time::sleep(wait_time).await;\n\t\tlet mut session =\n\t\t\tcrate::create_session(\u0026settings.server_addr[0], auth).await?;\n\n\t\tstate = get_player_state(settings.clone());\n\t\tunsafe { CONNECTIONS_COUNT.fetch_add(1, Ordering::Relaxed) };\n\t\tif settings.verbose \u003e 0 {\n\t\t\tprintln!(\n\t\t\t\t\"[server #{}, connection #{}] -\u003e session id: {}\",\n\t\t\t\tsettings.server_addr[server_index as usize],\n\t\t\t\tunsafe { CONNECTIONS_COUNT.load(Ordering::Relaxed) },\n\t\t\t\tsession.id(),\n\t\t\t);\n\t\t}\n\n\t\t'inner: loop {\n\t\t\tlet mut tick = session.ticks().build();\n\t\t\ttick.set_interest_radius(Relevance::new(settings.interest_radius));\n\n\t\t\ttick\n\t\t\t\t.build_player()\n\t\t\t\t.build_attributes(1)\n\t\t\t\t.set_vec3(WellKnownAttribute::Position as AttributeId, state.position)\n\t\t\t\t.unwrap();\n\n\t\t\tsession.ticks().send(tick)?;\n\n\t\t\tlet _response = session.ticks().receive().await?;\n\t\t\tloop_count += 1;\n\t\t\tif last_connect.elapsed() \u003e disconnect_every {\n\t\t\t\tprintln!(\"close session id: {}\", session.id(),);\n\t\t\t\tif let Ok(mut states) = states.write() {\n\t\t\t\t\tstates.insert(session.id(), state);\n\t\t\t\t} else {\n\t\t\t\t\teprintln!(\"Failed to acquire write lock on player_states\");\n\t\t\t\t}\n\t\t\t\tdrop(session);\n\t\t\t\tlast_connect = Instant::now();\n\n\t\t\t\tif (settings.run_period \u003e 0\n\t\t\t\t\t\u0026\u0026 start_time.elapsed().as_secs() \u003e settings.run_period.into())\n\t\t\t\t\t|| (settings.run_loop \u003e 1 \u0026\u0026 settings.run_loop \u003e loop_count)\n\t\t\t\t{\n\t\t\t\t\tif states.read().unwrap().len() == 0 {\n\t\t\t\t\t\treturn Err(anyhow::anyhow!(\n\t\t\t\t\t\t\t\"Disconnected player details are not available\"\n\t\t\t\t\t\t));\n\t\t\t\t\t}\n\t\t\t\t\tbreak 'outer;\n\t\t\t\t}\n\t\t\t\tbreak 'inner;\n\t\t\t}\n\t\t}\n\t}\n\tOk(())\n}\n\nfn get_player_state(settings: Settings) -\u003e PlayerState {\n\tlet pos_x =\n\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max);\n\tlet pos_y =\n\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max);\n\tlet pos_z =\n\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max);\n\n\tlet rot_x = rand::thread_rng().gen_range(settings.range_min..360.0);\n\tlet rot_y = rand::thread_rng().gen_range(settings.range_min..360.0);\n\tlet rot_z = rand::thread_rng().gen_range(settings.range_min..360.0);\n\n\tPlayerState {\n\t\trotation: (rot_x, rot_y, rot_z),\n\t\tposition: (pos_x, pos_y, pos_z),\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","devtools","stress","src","test_case5.rs"],"content":"use {\n\tcrate::{PlayerAttribute, PlayerState, Settings, SlotId},\n\tmetrics::histogram,\n\tquark_client_sdk::{\n\t\tAttributeId,\n\t\tPlayerId,\n\t\tRelevance,\n\t\tValue,\n\t\tWellKnownAttribute,\n\t},\n\trand::Rng,\n\tstd::{\n\t\tcollections::HashMap,\n\t\tsync::{\n\t\t\tatomic::{AtomicUsize, Ordering},\n\t\t\tArc,\n\t\t\tRwLock,\n\t\t},\n\t\ttime::{Duration, Instant, SystemTime, UNIX_EPOCH},\n\t},\n};\n\nstatic mut CONNECTIONS_COUNT: AtomicUsize = AtomicUsize::new(0);\n\n#[derive(Clone, Copy)]\nstruct Waypoint {\n\tx: f32,\n\ty: f32,\n\tz: f32,\n}\n\n/// ### Test Case 5: Player Movement Simulation (Random Waypoint Model)\n///\n/// Description:\n/// Scenario entails dispatching customizable player data to the server without\n/// the necessity of awaiting or processing a response. Additionally, it will\n/// emulate the movement of players following the Random Waypoint model.\n///\n/// https://app.clickup.com/t/8693khrxt\n///\n/// Important Commands:\n/// --speed_min: Specified player minimum speed\n/// --speed_max: Specified player maximum speed\n\npub async fn test_case5(\n\tindex: SlotId,\n\tsettings: Settings,\n\tstates: Arc\u003cRwLock\u003cHashMap\u003cPlayerId, PlayerState\u003e\u003e\u003e,\n) -\u003e anyhow::Result\u003c()\u003e {\n\tlet _ = states;\n\tlet auth: \u0026[u8] = \u0026[];\n\tlet server_index = index % settings.server_addr.len() as u32;\n\tlet mut session =\n\t\tcrate::create_session(\u0026settings.server_addr[0], auth).await?;\n\n\t// println!(\"{:#?}\", session.id());\n\tlet wait_time =\n\t\tDuration::from_millis((1000.0f32 / settings.tick_frequency) as u64);\n\n\tunsafe { CONNECTIONS_COUNT.fetch_add(1, Ordering::Relaxed) };\n\n\tif settings.verbose \u003e 0 {\n\t\tprintln!(\n\t\t\t\"[server #{}, connection #{}] -\u003e session id: {}\",\n\t\t\tsettings.server_addr[server_index as usize],\n\t\t\tunsafe { CONNECTIONS_COUNT.load(Ordering::Relaxed) },\n\t\t\tsession.id(),\n\t\t);\n\t}\n\n\tlet mut start_point = get_random_waypoint(settings.clone());\n\tlet mut end_point = get_random_waypoint(settings.clone());\n\tlet mut current_point = start_point;\n\tlet mut speed = get_speed(settings.clone());\n\tlet mut last_connect = Instant::now();\n\tlet start_time = Instant::now();\n\tlet mut loop_count = 0;\n\n\tloop {\n\t\ttokio::time::sleep(wait_time).await;\n\t\tlet cloned_settings = settings.clone();\n\n\t\tlet current = Instant::now();\n\t\tlet elapsed = current.duration_since(last_connect);\n\t\tlast_connect = current;\n\n\t\tlet (next, rotation) =\n\t\t\tplayer_step(start_point, end_point, current_point, speed, elapsed);\n\t\tlet current_timestamp = current_microseconds_since_epoch()?;\n\t\tlet dist_1 = (((current_point.x - end_point.x)\n\t\t\t* (current_point.x - end_point.x))\n\t\t\t+ ((current_point.y - end_point.y) * (current_point.y - end_point.y))\n\t\t\t+ ((current_point.z - end_point.z) * (current_point.z - end_point.z)))\n\t\t\t.sqrt();\n\n\t\tlet dist_2 = (((next.x - end_point.x) * (next.x - end_point.x))\n\t\t\t+ ((next.y - end_point.y) * (next.y - end_point.y))\n\t\t\t+ ((next.z - end_point.z) * (next.z - end_point.z)))\n\t\t\t.sqrt();\n\n\t\tif dist_1 \u003c dist_2 || dist_2 \u003c= speed * elapsed.as_millis() as f32 / 100.0 {\n\t\t\tstart_point = end_point;\n\t\t\tend_point = get_random_waypoint(cloned_settings.clone());\n\t\t\tspeed = get_speed(cloned_settings.clone());\n\t\t}\n\n\t\tcurrent_point = next;\n\n\t\tlet mut tick = session.ticks().build();\n\t\ttick.set_interest_radius(Relevance::new(settings.interest_radius));\n\t\ttick\n\t\t\t.build_player()\n\t\t\t.build_attributes(3)\n\t\t\t.set_vec3(\n\t\t\t\tWellKnownAttribute::Position as AttributeId,\n\t\t\t\t(next.x, next.y, next.z),\n\t\t\t)\n\t\t\t.unwrap()\n\t\t\t.set_vec3(\n\t\t\t\tWellKnownAttribute::Rotation as AttributeId,\n\t\t\t\t(rotation.x, rotation.y, rotation.z),\n\t\t\t)\n\t\t\t.unwrap()\n\t\t\t.set_uint64(PlayerAttribute::Timestamp as AttributeId, current_timestamp)\n\t\t\t.unwrap();\n\n\t\tsession.ticks().send(tick)?;\n\n\t\tlet response = session.ticks().receive().await?;\n\t\tlet msg_rcv_timestamp = current_microseconds_since_epoch()?;\n\t\tlet players = response.players()?;\n\t\tlet mut player_time: HashMap\u003cu32, (u64, u64)\u003e = HashMap::new();\n\n\t\tfor player in players {\n\t\t\tlet player_server = player.id() % settings.server_addr.len() as u32;\n\t\t\tlet attribs = player.attribs();\n\t\t\tfor attrib in attribs {\n\t\t\t\tif attrib.key == PlayerAttribute::Timestamp as AttributeId {\n\t\t\t\t\tlet value = attrib.value.clone();\n\t\t\t\t\tlet msg_duration = match value {\n\t\t\t\t\t\tValue::Uint64(send_timestamp) =\u003e msg_rcv_timestamp - send_timestamp,\n\t\t\t\t\t\t_ =\u003e {\n\t\t\t\t\t\t\t// illegal type here\n\t\t\t\t\t\t\tpanic!(\"unexpected message variant\");\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tmatch player_time.entry(player_server) {\n\t\t\t\t\t\tstd::collections::hash_map::Entry::Occupied(mut entry) =\u003e {\n\t\t\t\t\t\t\tlet (total, count) = entry.get();\n\t\t\t\t\t\t\tentry.insert((total + msg_duration, count + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstd::collections::hash_map::Entry::Vacant(entry) =\u003e {\n\t\t\t\t\t\t\tentry.insert((msg_duration, 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor server_id in player_time.keys() {\n\t\t\tlet avarage_rtt =\n\t\t\t\t(player_time[server_id].0 / player_time[server_id].1) as f64;\n\t\t\tlet histogram_name =\n\t\t\t\tformat!(\"round_trip_latency_from_{}_to_{}\", server_id, server_index);\n\t\t\trecord_histogram(\n\t\t\t\thistogram_name,\n\t\t\t\tavarage_rtt,\n\t\t\t\tmetrics_cloudwatch::Unit::Microseconds,\n\t\t\t)\n\t\t}\n\n\t\tloop_count += 1;\n\t\tif (settings.run_period \u003e 0\n\t\t\t\u0026\u0026 start_time.elapsed().as_secs() \u003e settings.run_period.into())\n\t\t\t|| (settings.run_loop \u003e 1 \u0026\u0026 settings.run_loop \u003e loop_count)\n\t\t{\n\t\t\tdrop(session);\n\t\t\tbreak;\n\t\t}\n\t}\n\tOk(())\n}\n\nfn player_step(\n\tstart: Waypoint,\n\tend: Waypoint,\n\tcurrent: Waypoint,\n\tspeed: f32,\n\telapse: Duration,\n) -\u003e (Waypoint, Waypoint) {\n\tlet coefficient = elapse.as_millis() as f32 / 100.0;\n\n\tlet diff = Waypoint {\n\t\tx: end.x - start.x,\n\t\ty: end.y - start.y,\n\t\tz: end.z - start.z,\n\t};\n\n\tlet yaw_degrees = f32::atan2(diff.y, diff.x);\n\tlet pitch_degree =\n\t\tf32::atan2(diff.z, (diff.x * diff.x + diff.y * diff.y).sqrt());\n\n\tlet delta = Waypoint {\n\t\tx: speed * f32::cos(yaw_degrees) * coefficient,\n\t\ty: speed * f32::sin(yaw_degrees) * coefficient,\n\t\tz: speed * f32::tan(pitch_degree) * coefficient,\n\t};\n\n\tlet next = Waypoint {\n\t\tx: (current.x - end.x),\n\t\ty: (current.y - -end.y),\n\t\tz: (current.z - -end.z),\n\t};\n\n\tlet rotation = Waypoint {\n\t\tx: f32::atan2(delta.y, delta.z).to_degrees(),\n\t\ty: f32::atan2(delta.z, delta.x).to_degrees(),\n\t\tz: f32::atan2(delta.x, delta.y).to_degrees(),\n\t};\n\n\t(next, rotation)\n}\n\nfn get_random_waypoint(settings: Settings) -\u003e Waypoint {\n\tlet mut rng = rand::thread_rng();\n\tWaypoint {\n\t\tx: rng.gen_range(settings.range_min..settings.range_max),\n\t\ty: rng.gen_range(settings.range_min..settings.range_max),\n\t\tz: rng.gen_range(settings.range_min..settings.range_max),\n\t}\n}\n\nfn get_speed(settings: Settings) -\u003e f32 {\n\tlet mut rng = rand::thread_rng();\n\n\trng.gen_range(settings.speed_min..settings.speed_max)\n}\n\nfn current_microseconds_since_epoch() -\u003e Result\u003cu64, std::time::SystemTimeError\u003e\n{\n\tlet time_associated: SystemTime = SystemTime::now();\n\tlet duration_since_epoch = time_associated.duration_since(UNIX_EPOCH)?;\n\tlet since_epoch = duration_since_epoch.as_micros() as u64;\n\tOk(since_epoch)\n}\n\nfn record_histogram(name: String, value: f64, unit: metrics_cloudwatch::Unit) {\n\thistogram!(name, value, \"@unit\" =\u003e unit);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","devtools","stress","src","test_case6.rs"],"content":"use {\n\tcrate::{PlayerState, Settings, SlotId},\n\tarrayvec::ArrayVec,\n\tquark_client_sdk::{\n\t\tAttributeId,\n\t\tEntityId,\n\t\tOutboundEvent,\n\t\tPlayerId,\n\t\tRecipient,\n\t\tRelevance,\n\t\tWellKnownAttribute,\n\t},\n\trand::Rng,\n\tstd::{\n\t\tcollections::HashMap,\n\t\tsync::{\n\t\t\tatomic::{AtomicUsize, Ordering},\n\t\t\tArc,\n\t\t\tRwLock,\n\t\t},\n\t\ttime::{Duration, Instant},\n\t},\n};\n\nstatic mut CONNECTIONS_COUNT: AtomicUsize = AtomicUsize::new(0);\n\n/// ### Test Case 6: Player Custom Event Simulation\n///\n/// Description:\n/// Scenario is designed to send custom events to the server in a massive\n/// manner. The test verifies the responses and waits for a specified time to\n/// receive the correct event data. If the correct data does not arrive, an\n/// ERROR is reported.\n///\n/// https://app.clickup.com/t/8693khrxt\n\npub async fn test_case6(\n\tindex: SlotId,\n\tsettings: Settings,\n\tstates: Arc\u003cRwLock\u003cHashMap\u003cPlayerId, PlayerState\u003e\u003e\u003e,\n) -\u003e anyhow::Result\u003c()\u003e {\n\tlet _ = states;\n\tlet auth: \u0026[u8] = \u0026[];\n\tlet wait_time =\n\t\tDuration::from_millis((1000.0f32 / settings.tick_frequency) as u64);\n\tlet server_index = index % settings.server_addr.len() as u32;\n\tlet mut session =\n\t\tcrate::create_session(\u0026settings.server_addr[0], auth).await?;\n\tlet mut counter = 0;\n\tunsafe { CONNECTIONS_COUNT.fetch_add(1, Ordering::Relaxed) };\n\tlet start_time = Instant::now();\n\tlet mut loop_count = 0;\n\n\tif settings.verbose \u003e 0 {\n\t\tprintln!(\n\t\t\t\"[server #{}, connection #{}] -\u003e session id: {}\",\n\t\t\tsettings.server_addr[server_index as usize],\n\t\t\tunsafe { CONNECTIONS_COUNT.load(Ordering::Relaxed) },\n\t\t\tsession.id(),\n\t\t);\n\t}\n\n\tloop {\n\t\ttokio::time::sleep(wait_time).await;\n\n\t\tlet relevance = match counter % 5 == 0 {\n\t\t\ttrue =\u003e Relevance::new(0.60),\n\t\t\tfalse =\u003e Relevance::new(settings.interest_radius),\n\t\t};\n\n\t\tlet mut tick = session.ticks().build();\n\t\ttick.set_interest_radius(relevance);\n\n\t\ttick\n\t\t\t.build_player()\n\t\t\t.build_attributes(1)\n\t\t\t.set_vec3(\n\t\t\t\tWellKnownAttribute::Position as AttributeId,\n\t\t\t\t(\n\t\t\t\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max),\n\t\t\t\t),\n\t\t\t)\n\t\t\t.unwrap();\n\n\t\t// scoped objects\n\t\t{\n\t\t\tlet mut objects = tick.build_objects(2);\n\n\t\t\tobjects\n\t\t\t\t.build_object(session.derive_global_id(1))\n\t\t\t\t.build_attributes(2)\n\t\t\t\t.set_vec3(\n\t\t\t\t\tWellKnownAttribute::Position as AttributeId,\n\t\t\t\t\t(\n\t\t\t\t\t\trand::thread_rng()\n\t\t\t\t\t\t\t.gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\t\trand::thread_rng()\n\t\t\t\t\t\t\t.gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\t\trand::thread_rng()\n\t\t\t\t\t\t\t.gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t\t.unwrap()\n\t\t\t\t.set_vec3(\n\t\t\t\t\tWellKnownAttribute::Rotation as AttributeId,\n\t\t\t\t\t(\n\t\t\t\t\t\trand::thread_rng()\n\t\t\t\t\t\t\t.gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\t\trand::thread_rng()\n\t\t\t\t\t\t\t.gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\t\trand::thread_rng()\n\t\t\t\t\t\t\t.gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t\t.unwrap();\n\n\t\t\tobjects\n\t\t\t\t.build_object(session.derive_global_id(2))\n\t\t\t\t.build_attributes(2)\n\t\t\t\t.set_vec3(\n\t\t\t\t\tWellKnownAttribute::Position as AttributeId,\n\t\t\t\t\t(\n\t\t\t\t\t\trand::thread_rng()\n\t\t\t\t\t\t\t.gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\t\trand::thread_rng()\n\t\t\t\t\t\t\t.gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\t\trand::thread_rng()\n\t\t\t\t\t\t\t.gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t\t.unwrap()\n\t\t\t\t.set_vec3(\n\t\t\t\t\tWellKnownAttribute::Rotation as AttributeId,\n\t\t\t\t\t(\n\t\t\t\t\t\trand::thread_rng()\n\t\t\t\t\t\t\t.gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\t\trand::thread_rng()\n\t\t\t\t\t\t\t.gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\t\trand::thread_rng()\n\t\t\t\t\t\t\t.gen_range(settings.range_min..settings.range_max),\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t\t.unwrap();\n\t\t}\n\n\t\t// scoped events\n\t\t{\n\t\t\tlet mut events = tick.build_events(2);\n\t\t\t// Convert session ID to a 32-byte array\n\t\t\tlet payload: ArrayVec\u003cu8, 256\u003e =\n\t\t\t\tsession.id().to_le_bytes().into_iter().collect();\n\n\t\t\tevents.push_event(\u0026OutboundEvent {\n\t\t\t\tclass: 20002,\n\t\t\t\tpayload,\n\t\t\t\trecipient: Recipient::Radius(relevance),\n\t\t\t});\n\t\t}\n\n\t\tsession.ticks().send(tick)?;\n\t\tlet response = session.ticks().receive().await?;\n\n\t\tlet events = response.events()?;\n\n\t\tfor event in events {\n\t\t\tlet payload = event.payload();\n\t\t\tlet sender = event.sender();\n\t\t\tlet class = event.class();\n\t\t\tlet payload_u32 =\n\t\t\t\tu32::from_le_bytes([payload[0], payload[1], payload[2], payload[3]]);\n\n\t\t\tif EntityId::Player(payload_u32) != sender || class != 20002 {\n\t\t\t\treturn Err(anyhow::anyhow!(\n\t\t\t\t\t\"player event data are mismatch. (Event id: {class} Payload: \n\t\t\t\t\t{payload_u32} Session id: {sender})\"\n\t\t\t\t));\n\t\t\t}\n\t\t\tcounter += 1;\n\n\t\t\tif settings.verbose \u003e 0 {\n\t\t\t\tprintln!(\n\t\t\t\t\t\"Event id: {class} Payload: {payload_u32}  Session_id: {sender}\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tloop_count += 1;\n\t\tif (settings.run_period \u003e 0\n\t\t\t\u0026\u0026 start_time.elapsed().as_secs() \u003e settings.run_period.into())\n\t\t\t|| (settings.run_loop \u003e 1 \u0026\u0026 settings.run_loop \u003e loop_count)\n\t\t{\n\t\t\tif counter \u003c 1 {\n\t\t\t\treturn Err(anyhow::anyhow!(\n\t\t\t\t\t\"player event data not recived. (Session id: {})\",\n\t\t\t\t\tsession.id()\n\t\t\t\t));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tOk(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","devtools","stress","src","test_case7.rs"],"content":"use {\n\tcrate::{PlayerState, Settings, SlotId},\n\tarrayvec::ArrayVec,\n\tquark_client_sdk::{\n\t\tprotocol::events::SystemEvents,\n\t\tAttributeId,\n\t\tOutboundEvent,\n\t\tPlayerId,\n\t\tRecipient,\n\t\tRelevance,\n\t\tWellKnownAttribute,\n\t},\n\trand::Rng,\n\tstd::{\n\t\tcollections::{HashMap, HashSet},\n\t\tsync::{\n\t\t\tatomic::{AtomicUsize, Ordering},\n\t\t\tArc,\n\t\t\tRwLock,\n\t\t},\n\t\ttime::{Duration, Instant},\n\t},\n};\n\nstatic mut CONNECTIONS_COUNT: AtomicUsize = AtomicUsize::new(0);\n\n/// ### Test Case 7: Player Custom Event Simulation\n///\n/// Description:\n/// Scenario is designed to send custom events to the server in a massive\n/// manner. The test verifies the responses and waits for a specified time to\n/// receive the correct event data. If the correct data does not arrive, an\n/// ERROR is reported.\n///\n/// https://app.clickup.com/t/8693khrxt\n\npub async fn test_case7(\n\tindex: SlotId,\n\tsettings: Settings,\n\tstates: Arc\u003cRwLock\u003cHashMap\u003cPlayerId, PlayerState\u003e\u003e\u003e,\n) -\u003e anyhow::Result\u003c()\u003e {\n\tlet _ = states;\n\tlet auth: \u0026[u8] = \u0026[];\n\tlet server_index = index % settings.server_addr.len() as u32;\n\tlet mut session =\n\t\tcrate::create_session(\u0026settings.server_addr[0], auth).await?;\n\tlet wait_time =\n\t\tDuration::from_millis((1000.0f32 / settings.tick_frequency) as u64);\n\n\tlet mut counter = 0;\n\tunsafe { CONNECTIONS_COUNT.fetch_add(1, Ordering::Relaxed) };\n\tlet start_time = Instant::now();\n\tlet mut last_despawn = Instant::now();\n\tlet mut loop_count = 0;\n\n\tif settings.verbose \u003e 0 {\n\t\tprintln!(\n\t\t\t\"[server #{}, connection #{}] -\u003e session id: {}\",\n\t\t\tsettings.server_addr[server_index as usize],\n\t\t\tunsafe { CONNECTIONS_COUNT.load(Ordering::Relaxed) },\n\t\t\tsession.id(),\n\t\t);\n\t}\n\n\tlet mut obj_spawn_loop = true;\n\tlet mut object_id = 0u64;\n\tlet mut object_spawned_count = 1;\n\tlet mut object_event_send = false;\n\n\tlet pos_x =\n\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max);\n\tlet pos_y =\n\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max);\n\tlet pos_z =\n\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max);\n\n\tlet rot_x = rand::thread_rng().gen_range(settings.range_min..360.0);\n\tlet rot_y = rand::thread_rng().gen_range(settings.range_min..360.0);\n\tlet rot_z = rand::thread_rng().gen_range(settings.range_min..360.0);\n\n\tlet state = PlayerState {\n\t\trotation: (rot_x, rot_y, rot_z),\n\t\tposition: (pos_x, pos_y, pos_z),\n\t};\n\tloop {\n\t\ttokio::time::sleep(wait_time).await;\n\n\t\tlet mut tick = session.ticks().build();\n\t\ttick.set_interest_radius(Relevance::new(settings.interest_radius));\n\n\t\ttick\n\t\t\t.build_player()\n\t\t\t.build_attributes(2)\n\t\t\t.set_vec3(WellKnownAttribute::Position as AttributeId, state.position)\n\t\t\t.unwrap()\n\t\t\t.set_vec3(WellKnownAttribute::Rotation as AttributeId, state.rotation)\n\t\t\t.unwrap();\n\n\t\t// scoped objects\n\t\t{\n\t\t\tif last_despawn.elapsed().as_secs() \u003e 1 {\n\t\t\t\tlast_despawn = Instant::now();\n\t\t\t\tobj_spawn_loop = false;\n\t\t\t}\n\n\t\t\tif obj_spawn_loop {\n\t\t\t\tlet mut objects = tick.build_objects(1);\n\t\t\t\tobject_id = session.derive_global_id(object_spawned_count);\n\t\t\t\tobjects\n\t\t\t\t\t.build_object(object_id)\n\t\t\t\t\t.build_attributes(2)\n\t\t\t\t\t.set_vec3(\n\t\t\t\t\t\tWellKnownAttribute::Position as AttributeId,\n\t\t\t\t\t\t(pos_x + 0.5, pos_y + 0.5, pos_z + 0.5),\n\t\t\t\t\t)\n\t\t\t\t\t.unwrap()\n\t\t\t\t\t.set_vec3(WellKnownAttribute::Rotation as AttributeId, state.rotation)\n\t\t\t\t\t.unwrap();\n\t\t\t\tobject_event_send = false;\n\t\t\t} else if !object_event_send {\n\t\t\t\tlet mut events = tick.build_events(1);\n\t\t\t\t// Convert session ID to a 64-byte array\n\t\t\t\tlet payload: ArrayVec\u003cu8, 256\u003e =\n\t\t\t\t\tobject_id.to_le_bytes().into_iter().collect();\n\n\t\t\t\tevents.push_event(\u0026OutboundEvent {\n\t\t\t\t\tclass: SystemEvents::ObjectsDespawned as u16,\n\t\t\t\t\tpayload,\n\t\t\t\t\trecipient: Recipient::Radius(settings.interest_radius.into()),\n\t\t\t\t});\n\t\t\t\tobject_spawned_count += 1;\n\t\t\t\tobj_spawn_loop = true;\n\t\t\t\tobject_event_send = true;\n\t\t\t}\n\t\t}\n\n\t\tsession.ticks().send(tick)?;\n\n\t\t// scoped response\n\t\t{\n\t\t\tlet response = session.ticks().receive().await?;\n\t\t\tlet players = response.players()?;\n\t\t\tlet events = response.events()?;\n\t\t\tlet objects = response.objects()?;\n\n\t\t\tlet mut object_id_set: HashSet\u003cu64\u003e = HashSet::new();\n\n\t\t\tlet mut event_count = 0;\n\t\t\tfor event in events {\n\t\t\t\tlet payload = event.payload();\n\t\t\t\tlet sender = event.sender();\n\t\t\t\tlet class = event.class();\n\n\t\t\t\tif class == SystemEvents::ObjectsDespawned as u16 {\n\t\t\t\t\tevent_count += 1;\n\t\t\t\t\tif !payload.is_empty() {\n\t\t\t\t\t\tlet payload_u64 = u64::from_le_bytes([\n\t\t\t\t\t\t\tpayload[0], payload[1], payload[2], payload[3], payload[4],\n\t\t\t\t\t\t\tpayload[5], payload[6], payload[7],\n\t\t\t\t\t\t]);\n\t\t\t\t\t\tobject_id_set.insert(payload_u64);\n\n\t\t\t\t\t\tif settings.verbose \u003e 0 {\n\t\t\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\t\t\"Object ID: {} Event class: {}, Sender: {}\",\n\t\t\t\t\t\t\t\tpayload_u64, class, sender\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcounter += 1;\n\t\t\t}\n\n\t\t\tif event_count \u003e 0 {\n\t\t\t\tlet mut obj_count = 0;\n\t\t\t\tfor object in objects {\n\t\t\t\t\tobj_count += 1;\n\t\t\t\t\tif object_id_set.contains(\u0026object.id())\n\t\t\t\t\t\t\u0026\u0026 object.attribs().count() \u003e 0\n\t\t\t\t\t{\n\t\t\t\t\t\treturn Err(anyhow::anyhow!(\n\t\t\t\t\t\t\t\"Player received data for the despawned object. (Session ID: \n\t\t\t\t\t\t\t{}, Object ID: {})\",\n\t\t\t\t\t\t\tsession.id(),\n\t\t\t\t\t\t\tobject.id()\n\t\t\t\t\t\t));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif settings.verbose \u003e 0 {\n\t\t\t\t\tprintln!(\n\t\t\t\t\t\t\"Session ID: {} Object Count: {} Player Count: {}\",\n\t\t\t\t\t\tsession.id(),\n\t\t\t\t\t\tobj_count,\n\t\t\t\t\t\tplayers.count()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tloop_count += 1;\n\n\t\tif (settings.run_period \u003e 0\n\t\t\t\u0026\u0026 start_time.elapsed().as_secs() \u003e settings.run_period.into())\n\t\t\t|| (settings.run_loop \u003e 1 \u0026\u0026 settings.run_loop \u003e loop_count)\n\t\t{\n\t\t\tif counter \u003c 1 {\n\t\t\t\treturn Err(anyhow::anyhow!(\n\t\t\t\t\t\"player event data not recived. (Session id: {})\",\n\t\t\t\t\tsession.id()\n\t\t\t\t));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tOk(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","devtools","stress","src","test_case9.rs"],"content":"use {\n\tcrate::{PlayerState, Settings, SlotId},\n\tquark_client_sdk::{\n\t\tprotocol::events::SystemEvents,\n\t\tAttributeId,\n\t\tPlayerId,\n\t\tRelevance,\n\t\tWellKnownAttribute,\n\t},\n\trand::Rng,\n\tstd::{\n\t\tcollections::HashMap,\n\t\tsync::{\n\t\t\tatomic::{AtomicUsize, Ordering},\n\t\t\tArc,\n\t\t\tRwLock,\n\t\t},\n\t\ttime::{Duration, Instant},\n\t},\n};\n\nstatic mut CONNECTIONS_COUNT: AtomicUsize = AtomicUsize::new(0);\n\n/// ### Test Case 9: Player System Event Simulation (PlayerDisconnected Event)\n///\n/// Description:\n/// It is then sent to all other players who are aware of the disconnected\n/// player.\n///\n/// https://app.clickup.com/t/8693nkg62\n\npub async fn test_case9(\n\tindex: SlotId,\n\tsettings: Settings,\n\tstates: Arc\u003cRwLock\u003cHashMap\u003cPlayerId, PlayerState\u003e\u003e\u003e,\n) -\u003e anyhow::Result\u003c()\u003e {\n\tlet mut last_connect = Instant::now();\n\tlet start_time = Instant::now();\n\tlet disconnect_every = Duration::from_millis(1500);\n\tlet wait_time: Duration =\n\t\tDuration::from_millis((1000.0f32 / settings.tick_frequency) as u64);\n\tlet auth: \u0026[u8] = \u0026[];\n\tlet mut state;\n\tlet mut loop_count = 0;\n\tlet server_index = index % settings.server_addr.len() as u32;\n\n\t'outer: loop {\n\t\ttokio::time::sleep(wait_time).await;\n\t\tlet mut session =\n\t\t\tcrate::create_session(\u0026settings.server_addr[0], auth).await?;\n\t\tstate = get_player_state(settings.clone());\n\t\tunsafe { CONNECTIONS_COUNT.fetch_add(1, Ordering::Relaxed) };\n\t\tif settings.verbose \u003e 0 {\n\t\t\tprintln!(\n\t\t\t\t\"[server #{}, connection #{}] -\u003e session id: {}\",\n\t\t\t\tsettings.server_addr[server_index as usize],\n\t\t\t\tunsafe { CONNECTIONS_COUNT.load(Ordering::Relaxed) },\n\t\t\t\tsession.id(),\n\t\t\t);\n\t\t}\n\n\t\t'inner: loop {\n\t\t\tlet mut tick = session.ticks().build();\n\t\t\ttick.set_interest_radius(Relevance::new(settings.interest_radius));\n\n\t\t\ttick\n\t\t\t\t.build_player()\n\t\t\t\t.build_attributes(1)\n\t\t\t\t.set_vec3(WellKnownAttribute::Position as AttributeId, state.position)\n\t\t\t\t.unwrap();\n\n\t\t\tsession.ticks().send(tick)?;\n\n\t\t\t{\n\t\t\t\tlet response = session.ticks().receive().await?;\n\t\t\t\tlet _players = response.players()?;\n\t\t\t\tlet _objects = response.objects()?;\n\t\t\t\tlet events = response.events()?;\n\n\t\t\t\tlet mut disconnected: Vec\u003cu32\u003e = Vec::new();\n\t\t\t\tfor event in events {\n\t\t\t\t\tlet payload = event.payload();\n\t\t\t\t\tlet _sender = event.sender();\n\t\t\t\t\tlet class = event.class();\n\n\t\t\t\t\tif class == SystemEvents::PlayerDisconnected as u16 {\n\t\t\t\t\t\tlet num_players = payload.len() / 4;\n\n\t\t\t\t\t\tfor i in 0..num_players {\n\t\t\t\t\t\t\tlet start = i * 4;\n\t\t\t\t\t\t\tlet payload_u32 = u32::from_le_bytes([\n\t\t\t\t\t\t\t\tpayload[start],\n\t\t\t\t\t\t\t\tpayload[start + 1],\n\t\t\t\t\t\t\t\tpayload[start + 2],\n\t\t\t\t\t\t\t\tpayload[start + 3],\n\t\t\t\t\t\t\t]);\n\t\t\t\t\t\t\tdisconnected.push(payload_u32);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet read_lock = states.read().unwrap();\n\t\t\t\tfor player_id in disconnected {\n\t\t\t\t\tif !read_lock.contains_key(\u0026player_id) {\n\t\t\t\t\t\treturn Err(anyhow::anyhow!(\n\t\t\t\t\t\t\t\"Disconnected player data are mismatch {player_id}\"\n\t\t\t\t\t\t));\n\t\t\t\t\t}\n\n\t\t\t\t\tif settings.verbose \u003e 0 {\n\t\t\t\t\t\tprintln!(\"Disconnected player: {}\", player_id);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif last_connect.elapsed() \u003e disconnect_every {\n\t\t\t\tif let Ok(mut states) = states.write() {\n\t\t\t\t\tstates.insert(session.id(), state);\n\t\t\t\t} else {\n\t\t\t\t\teprintln!(\"Failed to acquire write lock on player_states\");\n\t\t\t\t}\n\t\t\t\tdrop(session);\n\t\t\t\tlast_connect = Instant::now();\n\n\t\t\t\tloop_count += 1;\n\n\t\t\t\tif (settings.run_period \u003e 0\n\t\t\t\t\t\u0026\u0026 start_time.elapsed().as_secs() \u003e settings.run_period.into())\n\t\t\t\t\t|| (settings.run_loop \u003e 1 \u0026\u0026 settings.run_loop \u003e loop_count)\n\t\t\t\t{\n\t\t\t\t\tbreak 'outer;\n\t\t\t\t}\n\t\t\t\tbreak 'inner;\n\t\t\t}\n\t\t}\n\t}\n\tOk(())\n}\n\nfn get_player_state(settings: Settings) -\u003e PlayerState {\n\tlet pos_x =\n\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max);\n\tlet pos_y =\n\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max);\n\tlet pos_z =\n\t\trand::thread_rng().gen_range(settings.range_min..settings.range_max);\n\n\tlet rot_x = rand::thread_rng().gen_range(settings.range_min..360.0);\n\tlet rot_y = rand::thread_rng().gen_range(settings.range_min..360.0);\n\tlet rot_z = rand::thread_rng().gen_range(settings.range_min..360.0);\n\n\tPlayerState {\n\t\trotation: (rot_x, rot_y, rot_z),\n\t\tposition: (pos_x, pos_y, pos_z),\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","admin","info.rs"],"content":"use {\n\tsuper::{AdminApiService, Format, ServerError},\n\taxum::{\n\t\textract::{Query, State},\n\t\tresponse::{IntoResponse, Response},\n\t\trouting::get,\n\t\tJson,\n\t\tRouter,\n\t},\n\tserde::Deserialize,\n\tserde_json::{json, Value},\n\tstd::sync::Arc,\n};\n\npub fn routes() -\u003e Router\u003cArc\u003cAdminApiService\u003e\u003e {\n\tRouter::new()\n\t\t.route(\"/status\", get(|| async { \"ok\" }))\n\t\t.route(\"/stats\", get(stats))\n\t\t.route(\"/profile\", get(profile))\n\t\t.route(\"/schema\", get(schema))\n}\n\npub async fn stats(State(state): State\u003cArc\u003cAdminApiService\u003e\u003e) -\u003e Json\u003cValue\u003e {\n\tlet players_count = state.global.players().len();\n\tlet objects_count = state.global.objects().len();\n\n\tJson(json!({\n\t\t\"players\": players_count,\n\t\t\"objects\": objects_count\n\t}))\n}\n\npub async fn profile(State(state): State\u003cArc\u003cAdminApiService\u003e\u003e) -\u003e Json\u003cValue\u003e {\n\tJson(serde_json::to_value(state.global.profile()).unwrap())\n}\n\n#[derive(Debug, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub struct SchemaQuery {\n\tformat: Format,\n}\npub async fn schema(\n\tState(state): State\u003cArc\u003cAdminApiService\u003e\u003e,\n\tparams: Option\u003cQuery\u003cSchemaQuery\u003e\u003e,\n) -\u003e Result\u003cResponse, ServerError\u003e {\n\tif state.global.opts().schema.is_some() {\n\t\tlet schema = state.global.schema();\n\t\tlet output = match params.map(|q| q.0.format) {\n\t\t\tSome(Format::Json) =\u003e serde_json::to_string_pretty(\u0026schema)?,\n\t\t\tSome(Format::Yaml) | None =\u003e serde_yaml::to_string(\u0026schema)?,\n\t\t};\n\t\tOk(output.into_response())\n\t} else {\n\t\tOk(\"default\".into_response())\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","admin","meta.rs"],"content":"use {\n\tsuper::{AdminApiService, ServerError},\n\tcrate::schema::Schema,\n\taxum::{\n\t\tresponse::{IntoResponse, Response},\n\t\trouting::get,\n\t\tRouter,\n\t},\n\tschemars::schema_for,\n\tstd::sync::Arc,\n};\n\npub fn routes() -\u003e Router\u003cArc\u003cAdminApiService\u003e\u003e {\n\tRouter::new().route(\"/schema\", get(schema))\n}\n\npub async fn schema() -\u003e Result\u003cResponse, ServerError\u003e {\n\tlet schema = schema_for!(Schema);\n\tOk(serde_json::to_string_pretty(\u0026schema)?.into_response())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","admin","mod.rs"],"content":"use {\n\tcrate::global::GlobalState,\n\taxum::{\n\t\thttp::StatusCode,\n\t\tresponse::{IntoResponse, Response},\n\t\tRouter,\n\t},\n\tserde::Deserialize,\n\tstd::{net::SocketAddr, sync::Arc},\n\ttokio::net::TcpListener,\n};\n\nmod info;\nmod meta;\nmod player;\n\npub struct AdminApiService {\n\tglobal: Arc\u003cGlobalState\u003e,\n}\n\nimpl AdminApiService {\n\tpub async fn start(\n\t\tendpoint: SocketAddr,\n\t\tglobal: Arc\u003cGlobalState\u003e,\n\t) -\u003e anyhow::Result\u003c()\u003e {\n\t\tlet state = Arc::new(Self { global });\n\t\tlet listener = TcpListener::bind(endpoint).await?;\n\n\t\tlet app = Router::new()\n\t\t\t.nest(\"/info\", info::routes())\n\t\t\t.nest(\"/player\", player::routes())\n\t\t\t.nest(\"/meta\", meta::routes())\n\t\t\t.with_state(state);\n\n\t\ttokio::spawn(async move {\n\t\t\taxum::serve(listener, app).await.unwrap();\n\t\t});\n\n\t\tOk(())\n\t}\n}\n\nstruct ServerError(anyhow::Error);\n\nimpl IntoResponse for ServerError {\n\tfn into_response(self) -\u003e Response {\n\t\t(\n\t\t\tStatusCode::INTERNAL_SERVER_ERROR,\n\t\t\tformat!(\"internal error: {}\", self.0),\n\t\t)\n\t\t\t.into_response()\n\t}\n}\n\nimpl\u003cE\u003e From\u003cE\u003e for ServerError\nwhere\n\tE: Into\u003canyhow::Error\u003e,\n{\n\tfn from(err: E) -\u003e Self {\n\t\tSelf(err.into())\n\t}\n}\n\n#[derive(Debug, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum Format {\n\tYaml,\n\tJson,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","admin","player.rs"],"content":"use {\n\tsuper::AdminApiService,\n\tcrate::{session::command::Command, state::player::PlayerId},\n\taxum::{\n\t\textract::{Path, State},\n\t\thttp::StatusCode,\n\t\trouting::{get, post},\n\t\tJson,\n\t\tRouter,\n\t},\n\tserde_json::{json, Value},\n\tstd::sync::Arc,\n};\n\npub fn routes() -\u003e Router\u003cArc\u003cAdminApiService\u003e\u003e {\n\tRouter::new()\n\t\t.route(\"/:id\", get(overview))\n\t\t.route(\"/:id/kick\", post(kick))\n}\n\npub async fn overview(\n\tPath(player_id): Path\u003cPlayerId\u003e,\n\tState(state): State\u003cArc\u003cAdminApiService\u003e\u003e,\n) -\u003e (StatusCode, Json\u003cValue\u003e) {\n\tif state.global.players().contains_key(\u0026player_id) {\n\t\t(\n\t\t\tStatusCode::OK,\n\t\t\tJson(json!({\n\t\t\t\t\"player_id\": player_id,\n\t\t\t})),\n\t\t)\n\t} else {\n\t\t(\n\t\t\tStatusCode::NOT_FOUND,\n\t\t\tJson(json!({\n\t\t\t\t\"error\": \"player not found\",\n\t\t\t})),\n\t\t)\n\t}\n}\n\npub async fn kick(\n\tPath(player_id): Path\u003cPlayerId\u003e,\n\tState(state): State\u003cArc\u003cAdminApiService\u003e\u003e,\n) -\u003e (StatusCode, Json\u003cValue\u003e) {\n\tif state.global.players().contains_key(\u0026player_id) {\n\t\tstate\n\t\t\t.global\n\t\t\t.commands()\n\t\t\t.send_to(\u0026player_id, Command::Terminate);\n\n\t\t(\n\t\t\tStatusCode::OK,\n\t\t\tJson(json!({\n\t\t\t\t\"status\": \"ok\"\n\t\t\t})),\n\t\t)\n\t} else {\n\t\t(\n\t\t\tStatusCode::NOT_FOUND,\n\t\t\tJson(json!({\n\t\t\t\t\"error\": \"player not found\",\n\t\t\t})),\n\t\t)\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","auth.rs"],"content":"use {\n\tcrate::state::{player::PlayerEntity, EntityId},\n\thmac::Hmac,\n\tjwt::VerifyWithKey,\n\trand::Rng,\n\tsha2::Sha256,\n\tstd::{\n\t\tcollections::BTreeMap,\n\t\tsync::atomic::{AtomicU32, Ordering},\n\t},\n};\n\n/// Configures the authentication settings for the server.\n#[derive(Debug)]\npub enum AuthenticationSettings {\n\t/// This variant is used when the server is running behind a proxy that\n\t/// handles the authentication. In this case the server will trust the proxy\n\t/// to provide the player id and the initial state of the player.\n\t///\n\t/// Players will not be able to connect to the server directly, they will\n\t/// have to connect to the proxy first.\n\t#[allow(dead_code)]\n\tProxy,\n\n\t/// This variant is used when no secret key was specified and the server\n\t/// is running in development mode. That means that all players will always\n\t/// be authenticated. If the authentication blob is empty, then the player\n\t/// will be assigned a new player id with random value. otherwise if the\n\t/// authentication blob is a 4-byte big endian integer, then that value will\n\t/// be used as the player id.\n\tDevelopmentServer { assigned_ids: AtomicU32 },\n\n\t/// This variant is used when a secret key was specified and the server is\n\t/// running in production mode. In this case the auth data is expected to be\n\t/// a valid JWT token signed with the secret key. The token is expected to\n\t/// contain a:\n\t/// - `pid`` claim that will be used as the player id (uint32).\n\t/// - `exp` claim that will be used to validate that the token is not\n\t///   expired, this value is expected to be a unix timestamp in UTC.\n\t/// - a list of key-value pairs that will be used to initialize the player\n\t///   state in form of JWT claims.  The format of the jwt claim is:\n\t///   \"key:type\": \"value\", where type is one of the following: string, bytes,\n\t///   uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32,\n\t///   float64, bool, vec2, vec3.\n\t///\n\t///   integer and float values are expressed in their string representation.\n\t///   vec2 and vec3 values are expressed as a comma separated list of floats.\n\t///   bytes values are base64 encoded.\n\t///   bool values are expressed as \"true\" or \"false\".\n\t///   string values are expressed as a quoted string.\n\tJwt { secret: Hmac\u003cSha256\u003e },\n}\n\nimpl Default for AuthenticationSettings {\n\tfn default() -\u003e Self {\n\t\tSelf::DevelopmentServer {\n\t\t\tassigned_ids: AtomicU32::new(1),\n\t\t}\n\t}\n}\n\nconst MAX_RANDOM_DEVELOPMENT_ASSIGNED_ID: u32 = 0x20000000; // 2^29 maximum random value for assignment of ids\nimpl AuthenticationSettings {\n\tpub fn development_server() -\u003e Self {\n\t\tSelf::DevelopmentServer {\n\t\t\tassigned_ids: AtomicU32::new(\n\t\t\t\trand::thread_rng().gen_range(0..=MAX_RANDOM_DEVELOPMENT_ASSIGNED_ID),\n\t\t\t),\n\t\t}\n\t}\n}\n\n/// This function is used to authenticate a player.\n///\n/// During handshake the player sends a bytestring to the server with opaque\n/// authentication data. In the infal implementation this function should\n/// validate that the auth data is valid and based on that return a player id\n/// and the initial state of the player.\n///\n/// In this placeholder implementation the player id is extracted from the first\n/// four bytes of the auth data in big endian, and the player state is empty.\npub fn authenticate(\n\tdata: \u0026[u8],\n\tsettings: \u0026AuthenticationSettings,\n) -\u003e anyhow::Result\u003cPlayerEntity\u003e {\n\tmatch settings {\n\t\tAuthenticationSettings::Proxy =\u003e {\n\t\t\tanyhow::bail!(\"Player must be authenticated by proxy\")\n\t\t}\n\t\tAuthenticationSettings::DevelopmentServer { assigned_ids } =\u003e {\n\t\t\tlet id = if data.len() == 4 {\n\t\t\t\tlet proposed = u32::from_be_bytes([data[0], data[1], data[2], data[3]]);\n\t\t\t\tif proposed == 0 {\n\t\t\t\t\tassigned_ids.fetch_add(1, Ordering::SeqCst)\n\t\t\t\t} else {\n\t\t\t\t\tproposed\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tassigned_ids.fetch_add(1, Ordering::SeqCst)\n\t\t\t};\n\t\t\tOk(PlayerEntity::new(EntityId::Player(id)))\n\t\t}\n\t\tAuthenticationSettings::Jwt { secret } =\u003e {\n\t\t\tlet jwt_str = std::str::from_utf8(data)?;\n\t\t\tauthenticate_with_jwt(jwt_str, secret)\n\t\t}\n\t}\n}\n\nfn authenticate_with_jwt(\n\ttoken: \u0026str,\n\tsecret: \u0026Hmac\u003cSha256\u003e,\n) -\u003e anyhow::Result\u003cPlayerEntity\u003e {\n\t// parse the JWT token and validate it\n\tlet mut claims: BTreeMap\u003cString, String\u003e = token.verify_with_key(secret)?;\n\n\tif claims.len() \u003e crate::state::entity::MAX_ATTRIBUTES {\n\t\tanyhow::bail!(\"Too many attributes in the auth token\");\n\t}\n\n\t// extract the player id from the claims\n\tlet pid: u32 = claims\n\t\t.remove(\"pid\")\n\t\t.ok_or_else(|| anyhow::anyhow!(\"missing pid attribute in auth token\"))?\n\t\t.parse()?;\n\n\t// TODO: extract the player state from the claims\n\tOk(PlayerEntity::new(EntityId::Player(pid)))\n}\n\n#[cfg(test)]\nmod tests {\n\tuse crate::state::EntityId;\n\n\t#[test]\n\tfn smoke_devmode() {\n\t\tlet settings = super::AuthenticationSettings::DevelopmentServer {\n\t\t\tassigned_ids: std::sync::atomic::AtomicU32::new(1),\n\t\t};\n\n\t\tlet state = super::authenticate(\u0026[], \u0026settings).unwrap();\n\t\tassert_eq!(*state.id(), EntityId::Player(1));\n\t\tassert_eq!(state, super::PlayerEntity::new(EntityId::Player(1)));\n\n\t\tlet state = super::authenticate(\u0026[], \u0026settings).unwrap();\n\t\tassert_eq!(*state.id(), EntityId::Player(2));\n\t\tassert_eq!(state, super::PlayerEntity::new(EntityId::Player(2)));\n\t}\n}\n","traces":[{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":118},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":118},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":236},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":236},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":232},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":464},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":214},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":19,"coverable":23},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","events","despawn.rs"],"content":"use {\n\tcrate::{\n\t\tsession::{self, Session},\n\t\tstate::{object::ObjectId, player::PlayerId},\n\t},\n\tquark_client_sdk::{\n\t\tprotocol::{events::SystemEvents, inbound::event},\n\t\tEntityId,\n\t\tEventClass,\n\t},\n\tstd::mem::size_of,\n\ttracing::trace,\n};\n\n/// Handles events sent by players when they want to despawn objects.\n/// Despawned objects are destructed, removed from global state and all players\n/// that are aware of the object are notified.\n///\n/// The logic of this function describes everything that needs to happen to\n/// properly clean up an object that is being deleted from the system.\npub fn objects(event: event::Reader\u003c'_\u003e, session: \u0026Session) {\n\tassert_eq!(\n\t\tevent.get_class(),\n\t\tSystemEvents::ObjectsDespawned as EventClass\n\t);\n\n\tlet global = \u0026session.global;\n\n\tlet Ok(payload) = event.get_payload() else {\n\t\ttrace!(\n\t\t\tsession = session.public_id,\n\t\t\t\"Invalid despawn event {} payload\",\n\t\t\tevent.get_class()\n\t\t);\n\t\treturn;\n\t};\n\n\tif payload.is_empty() || payload.len() % size_of::\u003cObjectId\u003e() != 0 {\n\t\ttrace!(\n\t\t\tsession = session.public_id,\n\t\t\t\"Invalid despawn event payload length {}\",\n\t\t\tpayload.len()\n\t\t);\n\t\treturn;\n\t}\n\n\tlet objects = payload\n\t\t.chunks_exact(size_of::\u003cObjectId\u003e())\n\t\t.map(|chunk| ObjectId::from_le_bytes(chunk[..].try_into().unwrap()))\n\t\t.collect::\u003cVec\u003c_\u003e\u003e();\n\n\ttrace!(\n\t\tsession = session.public_id,\n\t\t\"Despawning objects with ids: {objects:?}\"\n\t);\n\n\tfor object_id in objects {\n\t\tglobal.objects().despawn(session, object_id);\n\t}\n}\n\n/// Forgetting an object or player means that the server will clear the cache\n/// about what it thinks the client knows about the object or player. Next time\n/// the forgotten object or player becomes relevant, the server will send a full\n/// update about it and start tracking it again for the session.\npub fn forget_objects(\n\tevent: event::Reader\u003c'_\u003e,\n\tsession: \u0026mut session::Session,\n) {\n\tassert_eq!(event.get_class(), SystemEvents::ForgetObjects as EventClass);\n\n\tlet Ok(payload) = event.get_payload() else {\n\t\ttrace!(\n\t\t\tsession = session.public_id,\n\t\t\t\"Invalid forget event {} payload\",\n\t\t\tevent.get_class()\n\t\t);\n\t\treturn;\n\t};\n\n\tif payload.is_empty() || payload.len() % size_of::\u003cObjectId\u003e() != 0 {\n\t\ttrace!(\n\t\t\tsession = session.public_id,\n\t\t\t\"Invalid forget event payload length {}\",\n\t\t\tpayload.len()\n\t\t);\n\t\treturn;\n\t}\n\n\tlet objects = payload\n\t\t.chunks_exact(size_of::\u003cObjectId\u003e())\n\t\t.map(|chunk| ObjectId::from_le_bytes(chunk[..].try_into().unwrap()))\n\t\t.collect::\u003cVec\u003c_\u003e\u003e();\n\n\ttrace!(\n\t\tsession = session.public_id,\n\t\t\"Forgetting objects with ids: {objects:?}\"\n\t);\n\n\tfor object in objects {\n\t\tsession.version_map.remove(\u0026EntityId::Object(object));\n\t\tsession\n\t\t\t.global\n\t\t\t.interests()\n\t\t\t.forget(session.public_id, \u0026[EntityId::Object(object)]);\n\t}\n}\n\npub fn forget_players(\n\tevent: event::Reader\u003c'_\u003e,\n\tsession: \u0026mut session::Session,\n) {\n\tassert_eq!(event.get_class(), SystemEvents::ForgetPlayers as EventClass);\n\n\tlet Ok(payload) = event.get_payload() else {\n\t\ttrace!(\n\t\t\tsession = session.public_id,\n\t\t\t\"Invalid forget event {} payload\",\n\t\t\tevent.get_class()\n\t\t);\n\t\treturn;\n\t};\n\n\tif payload.is_empty() || payload.len() % size_of::\u003cPlayerId\u003e() != 0 {\n\t\ttrace!(\n\t\t\tsession = session.public_id,\n\t\t\t\"Invalid forget players event payload length {}\",\n\t\t\tpayload.len()\n\t\t);\n\t\treturn;\n\t}\n\n\tlet players = payload\n\t\t.chunks_exact(size_of::\u003cPlayerId\u003e())\n\t\t.map(|chunk| PlayerId::from_le_bytes(chunk[..].try_into().unwrap()))\n\t\t.collect::\u003cVec\u003c_\u003e\u003e();\n\n\ttrace!(\n\t\tsession = session.public_id,\n\t\t\"Forgetting players with ids: {players:?}\"\n\t);\n\n\tfor player in players {\n\t\tsession.version_map.remove(\u0026EntityId::Player(player));\n\t\tsession\n\t\t\t.global\n\t\t\t.interests()\n\t\t\t.forget(session.public_id, \u0026[EntityId::Player(player)]);\n\t}\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":39},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":36,"coverable":63},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","events","mod.rs"],"content":"use {\n\tcrate::{session::Session, state::EntityId},\n\tarrayvec::ArrayVec,\n\tcapnp::struct_list,\n\tquark_client_sdk::{\n\t\tprotocol::{events::SystemEvents, inbound::event},\n\t\tAttributeId,\n\t\tRecipient,\n\t\tRelevance,\n\t\tTimestamp,\n\t\tValue,\n\t\tWellKnownAttribute,\n\t\tMAX_PAYLOAD_LEN,\n\t},\n\tserde::{Deserialize, Serialize},\n\tstd::sync::Arc,\n\ttracing::trace,\n};\n\nmod despawn;\npub mod propagate;\n\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct Event {\n\tpub class: u16,\n\tpub sender: EntityId,\n\tpub payload: ArrayVec\u003cu8, MAX_PAYLOAD_LEN\u003e,\n\tpub timestamp: Timestamp,\n}\n\npub fn process(\n\treader: struct_list::Reader\u003cevent::Owned\u003e,\n\tsession: \u0026mut Session,\n) -\u003e anyhow::Result\u003c()\u003e {\n\tlet sender = match session\n\t\t.player_obj()\n\t\t.attributes()\n\t\t.get(WellKnownAttribute::Delegate as AttributeId)\n\t{\n\t\tSome(Value::Uint64(object_id)) =\u003e {\n\t\t\tmatch session.global.objects().contains_key(\u0026object_id) {\n\t\t\t\ttrue =\u003e EntityId::Object(object_id),\n\t\t\t\tfalse =\u003e EntityId::Player(session.public_id),\n\t\t\t}\n\t\t}\n\t\t_ =\u003e EntityId::Player(session.public_id),\n\t};\n\n\tfor event in reader.iter() {\n\t\t// note:\n\t\t// the `class if SystemEvents::* as u16 == class` check is a workaround\n\t\t// for the fact that Rust doesn't support matching on enum variants\n\t\t// with integers even if the enum is repr(int)\n\n\t\tmatch event.get_class() {\n\t\t\t// Process object despawn events.\n\t\t\tclass if SystemEvents::ObjectsDespawned as u16 == class =\u003e {\n\t\t\t\tdespawn::objects(event, session);\n\t\t\t}\n\n\t\t\t// process forgetting objects\n\t\t\tclass if SystemEvents::ForgetObjects as u16 == class =\u003e {\n\t\t\t\tdespawn::forget_objects(event, session);\n\t\t\t}\n\n\t\t\t// process forgetting players\n\t\t\tclass if SystemEvents::ForgetPlayers as u16 == class =\u003e {\n\t\t\t\tdespawn::forget_players(event, session);\n\t\t\t}\n\n\t\t\t// Reserved range of events for the engine.\n\t\t\t// Those events are not propagated to other players.\n\t\t\t0..=1000 =\u003e {\n\t\t\t\ttrace!(\n\t\t\t\t\tsession = session.public_id,\n\t\t\t\t\t\"Received event in reserved range: {event:?}\"\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Generic app-level events are always propagated to relevant players as\n\t\t\t// is without any processing by the engine.\n\t\t\t_ =\u003e {\n\t\t\t\tlet global = Arc::clone(\u0026session.global);\n\n\t\t\t\tlet recipient = match event.get_recipient().which()? {\n\t\t\t\t\tevent::recipient::Which::Radius(radius) =\u003e {\n\t\t\t\t\t\tRecipient::Radius(Relevance::new(radius))\n\t\t\t\t\t}\n\t\t\t\t\tevent::recipient::Which::Object(object) =\u003e {\n\t\t\t\t\t\tRecipient::Entity(EntityId::Object(object))\n\t\t\t\t\t}\n\t\t\t\t\tevent::recipient::Which::Player(player) =\u003e {\n\t\t\t\t\t\tRecipient::Entity(EntityId::Player(player))\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tlet event = Event {\n\t\t\t\t\tsender,\n\t\t\t\t\tclass: event.get_class(),\n\t\t\t\t\tpayload: event.get_payload()?[..].try_into()?,\n\t\t\t\t\ttimestamp: event.get_timestamp(),\n\t\t\t\t};\n\n\t\t\t\t// tell all producers that support event repolication to replicate this\n\t\t\t\t// event to all consumers that support event replication\n\t\t\t\tglobal.replicate().app_event(\u0026event, \u0026recipient);\n\n\t\t\t\ttokio::spawn(\n\t\t\t\t\t// process the event on a separate task\n\t\t\t\t\tasync move { propagate::process(event, recipient, \u0026global) },\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\t}\n\n\tOk(())\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":482},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":964},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":482},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":482},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":482},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":473},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":482},"fn_name":null}],"covered":28,"coverable":32},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","events","propagate.rs"],"content":"//! Handlers for application-level events.\n\nuse {\n\tsuper::Event,\n\tcrate::{\n\t\tglobal::GlobalState,\n\t\tsession::command::Command,\n\t\tstate::{player::PlayerId, EntityId},\n\t},\n\tfxhash::FxHashSet,\n\tquark_client_sdk::Recipient,\n\tstd::sync::Arc,\n};\n\npub fn process(event: Event, recipient: Recipient, global: \u0026GlobalState) {\n\tlet recipients = match recipient {\n\t\tRecipient::Radius(radius) =\u003e match event.sender {\n\t\t\tEntityId::Object(id) =\u003e global\n\t\t\t\t.objects()\n\t\t\t\t.get(\u0026id)\n\t\t\t\t.map(|o| global.indices().relevant(o.value(), radius))\n\t\t\t\t.unwrap_or_default(),\n\t\t\tEntityId::Player(id) =\u003e global\n\t\t\t\t.players()\n\t\t\t\t.get(\u0026id)\n\t\t\t\t.map(|o| global.indices().relevant(o.value(), radius))\n\t\t\t\t.unwrap_or_default(),\n\t\t},\n\t\tRecipient::Entity(id) =\u003e [id].into_iter().collect(),\n\t};\n\n\t// now for each identified recipient, we need to find the sessions\n\t// that are associated with them that will receive the event. We store\n\t// the result in a hashset to ensure that sessions won't receive duplicate\n\t// events.\n\tlet recipient_sessions = recipients\n\t\t.iter()\n\t\t.filter_map(|id| match id {\n\t\t\tEntityId::Player(id) =\u003e Some(*id),\n\t\t\tEntityId::Object(id) =\u003e match global.graph().root_owner_of(*id) {\n\t\t\t\tSome(EntityId::Player(id)) =\u003e Some(id),\n\t\t\t\t_ =\u003e None,\n\t\t\t},\n\t\t})\n\t\t.collect::\u003cFxHashSet\u003cPlayerId\u003e\u003e();\n\n\tlet sender = match event.sender {\n\t\tEntityId::Player(id) =\u003e id,\n\t\tEntityId::Object(id) =\u003e match global.graph().root_owner_of(id) {\n\t\t\tSome(EntityId::Player(id)) =\u003e id,\n\t\t\t_ =\u003e return,\n\t\t},\n\t};\n\n\tlet event = Arc::new(event);\n\tfor session in recipient_sessions.into_iter() {\n\t\tif session == sender {\n\t\t\t// don't deliver this message to the sender\n\t\t\tcontinue;\n\t\t}\n\n\t\tglobal\n\t\t\t.commands()\n\t\t\t.send_to(\u0026session, Command::ReceiveEvent(Arc::clone(\u0026event)));\n\t}\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":57},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":24},"fn_name":null}],"covered":23,"coverable":25},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","global.rs"],"content":"//! Defines the server global state\n\nuse {\n\tcrate::{\n\t\tauth::AuthenticationSettings,\n\t\tobjects::ObjectsState,\n\t\topts::{Profile, ServerOptions},\n\t\trelevance::Indices,\n\t\treplication,\n\t\tschema::{Lifetime, Schema},\n\t\tsession::{\n\t\t\tcommand::{Command, Commands},\n\t\t\tinterests::Interests,\n\t\t\tresume::ResumableSessions,\n\t\t},\n\t\tstate::{\n\t\t\tgraph::ObjectGraph,\n\t\t\tplayer::{PlayerEntity, PlayerId},\n\t\t\tDespawnedEntity,\n\t\t\tEntityId,\n\t\t},\n\t\ttopology::Topology,\n\t},\n\tdashmap::DashMap,\n\tfxhash::FxBuildHasher,\n\tstd::sync::Arc,\n\ttokio::net::UdpSocket,\n\ttracing::info,\n};\n\npub type PlayersState = DashMap\u003cPlayerId, PlayerEntity, FxBuildHasher\u003e;\n\npub struct GlobalState {\n\t/// This is the global state of all players in the world that are currently\n\t/// connected.\n\tplayers: Arc\u003cPlayersState\u003e,\n\n\t/// This is the global state of all objects in the world that have not been\n\t/// despawned yet.\n\tobjects: Arc\u003cObjectsState\u003e,\n\n\t/// This is a temporary storage for sessions that have been disconnected\n\t/// but are still eligible for resuming. After the resume timeout is elapsed\n\t/// the session is removed from this collection and is no longer eligible.\n\t/// All objects owned by a timed out session are orphaned and can be claimed\n\t/// by any other player.\n\tresumes: ResumableSessions,\n\n\t/// This is a collection of all indices that index objects and players and\n\t/// are used to determine which players and objects are relevant to each\n\t/// other.\n\tindices: Arc\u003cIndices\u003e,\n\n\t/// Those are channels that are used to send internal commands to individual\n\t/// sessions.\n\tcommands: Arc\u003cCommands\u003e,\n\n\t/// Used to keep track of which players are aware of which objects and\n\t/// players. This is used when objects are despawned or players disconnect,\n\t/// to notify everyone that is aware of the despawned object or disconnected\n\t/// player that it does not exist anymore.\n\tinterests: Interests,\n\n\t/// The object graph is a directed graph of objects ownership relationships.\n\t/// It is used to track the ownership of objects and to quickly find all\n\t/// objects that are owned by an entity.\n\tgraph: Arc\u003cObjectGraph\u003e,\n\n\t/// Configures the authentication process that is invoked during session\n\t/// handshake, and is responsible for assigining player ids to new sessions\n\t/// and initialize their initial set of attributes.\n\tauth: AuthenticationSettings,\n\n\t/// Holds instances of all replication producers that are used to send\n\t/// changes that happen on this node to other consumers.\n\treplication: replication::Producers,\n\n\t/// The profile that was loaded from the profile file on startup\n\tprofile: Profile,\n\n\t/// The schema that was loaded from the schema file on startup.\n\t///\n\t/// Schemas optionally configure the types of objects and players\n\t/// that exist in the world, the attributes that they have and\n\t/// the behavior that they exhibit.\n\tschema: Schema,\n\n\t/// The options that were used to configure the server at startup.\n\topts: ServerOptions,\n\n\t/// The topology of all nodes in the cluster.\n\t///\n\t/// This is used to discover proxy and quark nodes in the cluster and\n\t/// make various decisions across the cluster based on the state of\n\t/// the cluster.\n\ttopology: Arc\u003cTopology\u003e,\n\n\t/// The UDP socket that is used to communicate with clients over unreliable\n\t/// channels.\n\tudp_socket: UdpSocket,\n}\n\nimpl GlobalState {\n\tpub async fn new(\n\t\topts: ServerOptions,\n\t\ttopology: Arc\u003cTopology\u003e,\n\t) -\u003e anyhow::Result\u003cArc\u003cSelf\u003e\u003e {\n\t\tlet profile = opts.profile();\n\t\tlet schema = opts.schema()?;\n\n\t\tlet players = Arc::\u003cPlayersState\u003e::default();\n\t\tlet objects = Arc::\u003cObjectsState\u003e::default();\n\n\t\tlet graph = Arc::\u003cObjectGraph\u003e::default();\n\t\tlet commands = Arc::new(Commands::default());\n\t\tlet interests = Interests::new(Arc::clone(\u0026commands));\n\t\tlet replication = replication::Producers::new(\u0026opts.replicate_to)?;\n\t\tlet auth = opts.authentication();\n\n\t\tlet udp_socket = UdpSocket::bind(opts.listen_addr)\n\t\t\t.await\n\t\t\t.expect(\"failed to bind to local udp socket\");\n\n\t\tinfo!(\"UDP endpoint enabled on {}\", opts.listen_addr);\n\n\t\tlet indices = Arc::new(Indices::new(\n\t\t\t\u0026schema,\n\t\t\t\u0026profile,\n\t\t\tArc::clone(\u0026graph),\n\t\t\tArc::clone(\u0026players),\n\t\t\tArc::clone(\u0026objects),\n\t\t));\n\n\t\tOk(Arc::new(Self {\n\t\t\tauth,\n\t\t\tgraph,\n\t\t\tplayers,\n\t\t\tobjects,\n\t\t\tresumes: ResumableSessions::new(profile.resume_timeout),\n\t\t\tindices,\n\t\t\tcommands,\n\t\t\tinterests,\n\t\t\treplication,\n\t\t\tprofile,\n\t\t\tschema,\n\t\t\topts,\n\t\t\ttopology,\n\t\t\tudp_socket,\n\t\t}))\n\t}\n\n\tpub fn players(\u0026self) -\u003e \u0026PlayersState {\n\t\t\u0026self.players\n\t}\n\n\tpub fn objects(\u0026self) -\u003e \u0026ObjectsState {\n\t\t\u0026self.objects\n\t}\n\n\tpub const fn resumes(\u0026self) -\u003e \u0026ResumableSessions {\n\t\t\u0026self.resumes\n\t}\n\n\tpub fn indices(\u0026self) -\u003e \u0026Arc\u003cIndices\u003e {\n\t\t\u0026self.indices\n\t}\n\n\tpub fn commands(\u0026self) -\u003e \u0026Commands {\n\t\t\u0026self.commands\n\t}\n\n\tpub const fn interests(\u0026self) -\u003e \u0026Interests {\n\t\t\u0026self.interests\n\t}\n\n\tpub const fn graph(\u0026self) -\u003e \u0026Arc\u003cObjectGraph\u003e {\n\t\t\u0026self.graph\n\t}\n\n\tpub const fn auth(\u0026self) -\u003e \u0026AuthenticationSettings {\n\t\t\u0026self.auth\n\t}\n\n\tpub const fn replicate(\u0026self) -\u003e \u0026replication::Producers {\n\t\t\u0026self.replication\n\t}\n\n\tpub const fn profile(\u0026self) -\u003e \u0026Profile {\n\t\t\u0026self.profile\n\t}\n\n\tpub const fn schema(\u0026self) -\u003e \u0026Schema {\n\t\t\u0026self.schema\n\t}\n\n\tpub const fn opts(\u0026self) -\u003e \u0026ServerOptions {\n\t\t\u0026self.opts\n\t}\n\n\tpub const fn udp(\u0026self) -\u003e \u0026UdpSocket {\n\t\t\u0026self.udp_socket\n\t}\n\n\tpub fn topology(\u0026self) -\u003e \u0026Topology {\n\t\t\u0026self.topology\n\t}\n\n\tpub fn despawn_player(\n\t\tself: \u0026Arc\u003cSelf\u003e,\n\t\tplayer_id: PlayerId,\n\t\tresume_token: String,\n\t) {\n\t\tif self.players().remove(\u0026player_id).is_none() {\n\t\t\treturn; // player does not exist\n\t\t}\n\n\t\t// unregister the commands sender from global state.\n\t\tself.commands().unregister(\u0026player_id);\n\n\t\t// will need to despawn all dependent objects\n\t\tlet children = self.graph().children_of(EntityId::Player(player_id));\n\n\t\tlet global = Arc::clone(self);\n\t\ttokio::spawn(async move {\n\t\t\tfor object_id in children {\n\t\t\t\tlet is_lifetime_bound = global\n\t\t\t\t\t.objects()\n\t\t\t\t\t.get(\u0026object_id)\n\t\t\t\t\t.map(|object| {\n\t\t\t\t\t\t*global.schema().spec_of(object.value()).lifetime()\n\t\t\t\t\t\t\t== Lifetime::Owner\n\t\t\t\t\t})\n\t\t\t\t\t.unwrap_or(false);\n\n\t\t\t\tif is_lifetime_bound {\n\t\t\t\t\tglobal.objects().system_despawn(object_id, \u0026global);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// let all other nodes in the cluster know that this player has\n\t\t// disconnected.\n\t\tself\n\t\t\t.replicate()\n\t\t\t.despawn(DespawnedEntity::Player(player_id, resume_token));\n\n\t\t// Inform all players that are aware of the disconnected player that it\n\t\t// has disconnected.\n\t\tlet aware_players = self\n\t\t\t.interests()\n\t\t\t.take_players_aware_of_player(player_id)\n\t\t\t.unwrap_or_default();\n\n\t\tfor player in aware_players {\n\t\t\tself\n\t\t\t\t.commands()\n\t\t\t\t.send_to(\u0026player, Command::PlayerDisconnected(player_id));\n\t\t}\n\n\t\t// remove the player from the ownership graph\n\t\tself.graph().player_disconnected(player_id);\n\t}\n}\n","traces":[{"line":104,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":238},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":39911},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":39911},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":24670},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":24670},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":3888},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":3888},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":570},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":570},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":3581},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":3581},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":12588},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":12588},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":234},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":234},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":2213},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":2213},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":715},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":715},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":1135},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":1135},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":365},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":365},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":59},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":23},"fn_name":null}],"covered":69,"coverable":73},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","main.rs"],"content":"use crate::opts::ServerOptions;\n\nmod admin;\nmod auth;\nmod events;\nmod global;\nmod measure;\nmod objects;\nmod opts;\nmod proxy;\nmod relevance;\nmod replication;\nmod schema;\nmod server;\nmod session;\nmod state;\nmod topology;\n\n#[cfg(test)]\nmod tests;\n\n#[global_allocator]\nstatic GLOBAL: mimalloc::MiMalloc = mimalloc::MiMalloc;\n\n#[tokio::main]\nasync fn main() -\u003e anyhow::Result\u003c()\u003e {\n\tuse clap::Parser;\n\n\tlet opts = opts::Opts::parse();\n\topts.configure_logging();\n\n\topts\n\t\t.configure_metrics()\n\t\t.await\n\t\t.expect(\"failed to configure metrics system\");\n\n\t// Increase the maximum number of file descriptors that can be opened by the\n\t// process. Each connected socket is a file descriptor, and Linux by default\n\t// has a limit of 1024 file descriptors per process. This function increases\n\t// the limit to 500,000 file descriptors per process.\n\t#[cfg(not(windows))]\n\trlimit::setrlimit(rlimit::Resource::NOFILE, 500_000, 500_000)?;\n\n\t// this machine is part of a quark cluster topology, even if it's a single\n\t// node cluster, we still need to know the topology of the cluster in case new\n\t// machines dynamically join the cluster.\n\tuse crate::topology::Topology;\n\tlet topology = Topology::new(\u0026opts);\n\n\tmatch opts.mode {\n\t\tSome(opts::Mode::Server(opts)) =\u003e server::run(opts, topology).await,\n\t\tSome(opts::Mode::Proxy(opts)) =\u003e proxy::run(opts, topology).await,\n\t\tNone =\u003e server::run(ServerOptions::default(), topology).await,\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","measure.rs"],"content":"use {\n\thyper::{\n\t\theader::CONTENT_TYPE,\n\t\tservice::{make_service_fn, service_fn},\n\t\tBody,\n\t\tRequest,\n\t\tResponse,\n\t\tServer,\n\t},\n\tmetrics::Recorder,\n\tprometheus::Encoder,\n};\n\n#[macro_export]\nmacro_rules! measured {\n\t($id:expr, $e:expr) =\u003e {{\n\t\tlet start = std::time::Instant::now();\n\t\tlet result = $e;\n\t\tlet end = start.elapsed();\n\n\t\tmetrics::histogram!($id, end.as_micros() as f64);\n\t\tresult\n\t}};\n}\n\nasync fn serve_req(\n\t_req: Request\u003cBody\u003e,\n) -\u003e Result\u003cResponse\u003cBody\u003e, hyper::Error\u003e {\n\tlet encoder = prometheus::TextEncoder::new();\n\tlet mut buffer = vec![];\n\n\tencoder\n\t\t.encode(\u0026prometheus::default_registry().gather(), \u0026mut buffer)\n\t\t.unwrap();\n\n\tlet response = Response::builder()\n\t\t.status(200)\n\t\t.header(CONTENT_TYPE, encoder.format_type())\n\t\t.body(Body::from(buffer))\n\t\t.unwrap();\n\n\tOk(response)\n}\n\npub async fn server(addr: std::net::SocketAddr) {\n\tprintln!(\"Prometheus query server listening on http://{}\", addr);\n\n\tlet serve_future = Server::bind(\u0026addr).serve(make_service_fn(|_| async {\n\t\tOk::\u003c_, hyper::Error\u003e(service_fn(serve_req))\n\t}));\n\n\tif let Err(err) = serve_future.await {\n\t\teprintln!(\"Prometheus query server error: {}\", err);\n\t}\n}\n\n#[allow(dead_code)]\npub enum MetricsType {\n\tCounter,\n\tGauge,\n\tHistogram,\n}\n\nstruct Metrics {\n\tname: \u0026'static str,\n\tmetrics_type: MetricsType,\n\tunit: metrics::Unit,\n\tdescription: \u0026'static str,\n}\n\nconst METRICES_ARRAY: [Metrics; 43] = [\n\tMetrics {\n\t\tname: \"session_decode_error\",\n\t\tmetrics_type: MetricsType::Counter,\n\t\tunit: metrics::Unit::Count,\n\t\tdescription: \"Session Decode Error\",\n\t},\n\tMetrics {\n\t\tname: \"session_processing_error\",\n\t\tmetrics_type: MetricsType::Counter,\n\t\tunit: metrics::Unit::Count,\n\t\tdescription: \"Session Processing Error\",\n\t},\n\tMetrics {\n\t\tname: \"session_new_success\",\n\t\tmetrics_type: MetricsType::Counter,\n\t\tunit: metrics::Unit::Count,\n\t\tdescription: \"Session New Success\",\n\t},\n\tMetrics {\n\t\tname: \"session_handshake_auth_failure\",\n\t\tmetrics_type: MetricsType::Counter,\n\t\tunit: metrics::Unit::Count,\n\t\tdescription: \"Session Handshake Auth Failure\",\n\t},\n\tMetrics {\n\t\tname: \"session_resume_success\",\n\t\tmetrics_type: MetricsType::Counter,\n\t\tunit: metrics::Unit::Count,\n\t\tdescription: \"Session Resume Success\",\n\t},\n\tMetrics {\n\t\tname: \"session_handshake_failure\",\n\t\tmetrics_type: MetricsType::Counter,\n\t\tunit: metrics::Unit::Count,\n\t\tdescription: \"Session Handshake Failure\",\n\t},\n\tMetrics {\n\t\tname: \"verison_map_size\",\n\t\tmetrics_type: MetricsType::Counter,\n\t\tunit: metrics::Unit::Count,\n\t\tdescription: \"Client version cache elements count\",\n\t},\n\tMetrics {\n\t\tname: \"index_spatial_query_count\",\n\t\tmetrics_type: MetricsType::Counter,\n\t\tunit: metrics::Unit::Count,\n\t\tdescription: \"Index Spatial Query Count\",\n\t},\n\tMetrics {\n\t\tname: \"session_duration\",\n\t\tmetrics_type: MetricsType::Histogram,\n\t\tunit: metrics::Unit::Milliseconds,\n\t\tdescription: \"Session Duration\",\n\t},\n\tMetrics {\n\t\tname: \"tick_processing_time\",\n\t\tmetrics_type: MetricsType::Histogram,\n\t\tunit: metrics::Unit::Microseconds,\n\t\tdescription: \"Tick Processing Time\",\n\t},\n\tMetrics {\n\t\tname: \"tick_request_size\",\n\t\tmetrics_type: MetricsType::Histogram,\n\t\tunit: metrics::Unit::Bytes,\n\t\tdescription: \"Tick Request Size\",\n\t},\n\tMetrics {\n\t\tname: \"tick_relevant_players\",\n\t\tmetrics_type: MetricsType::Histogram,\n\t\tunit: metrics::Unit::Count,\n\t\tdescription: \"Tick Relevant Players\",\n\t},\n\tMetrics {\n\t\tname: \"update_set_count\",\n\t\tmetrics_type: MetricsType::Histogram,\n\t\tunit: metrics::Unit::Count,\n\t\tdescription: \"The total number of players and objects in a tick response\",\n\t},\n\tMetrics {\n\t\tname: \"tick_relevant_objects\",\n\t\tmetrics_type: MetricsType::Histogram,\n\t\tunit: metrics::Unit::Count,\n\t\tdescription: \"Tick Relevant Objects\",\n\t},\n\tMetrics {\n\t\tname: \"tick_build_response_duration\",\n\t\tmetrics_type: MetricsType::Histogram,\n\t\tunit: metrics::Unit::Microseconds,\n\t\tdescription: \"Tick Build Response Duration\",\n\t},\n\tMetrics {\n\t\tname: \"remote_view_prune_duration\",\n\t\tmetrics_type: MetricsType::Histogram,\n\t\tunit: metrics::Unit::Microseconds,\n\t\tdescription: \"Remote View Prune Duration\",\n\t},\n\tMetrics {\n\t\tname: \"tick_send_response_duration\",\n\t\tmetrics_type: MetricsType::Histogram,\n\t\tunit: metrics::Unit::Microseconds,\n\t\tdescription: \"Duration of sending tick response\",\n\t},\n\tMetrics {\n\t\tname: \"version_map_size\",\n\t\tmetrics_type: MetricsType::Histogram,\n\t\tunit: metrics::Unit::Count,\n\t\tdescription: \"Session Version Map Size\",\n\t},\n\tMetrics {\n\t\tname: \"tick_response_size\",\n\t\tmetrics_type: MetricsType::Histogram,\n\t\tunit: metrics::Unit::Bytes,\n\t\tdescription: \"Tick Response Size\",\n\t},\n\tMetrics {\n\t\tname: \"state_players_sync_duration\",\n\t\tmetrics_type: MetricsType::Histogram,\n\t\tunit: metrics::Unit::Microseconds,\n\t\tdescription: \"State Players Sync Duration\",\n\t},\n\tMetrics {\n\t\tname: \"state_players_save_duration\",\n\t\tmetrics_type: MetricsType::Histogram,\n\t\tunit: metrics::Unit::Microseconds,\n\t\tdescription: \"State Players Save Duration\",\n\t},\n\tMetrics {\n\t\tname: \"state_objects_sync_duration\",\n\t\tmetrics_type: MetricsType::Histogram,\n\t\tunit: metrics::Unit::Microseconds,\n\t\tdescription: \"State Objects Sync Duration\",\n\t},\n\tMetrics {\n\t\tname: \"state_objects_save_duration\",\n\t\tmetrics_type: MetricsType::Histogram,\n\t\tunit: metrics::Unit::Microseconds,\n\t\tdescription: \"State Objects Save Duration\",\n\t},\n\tMetrics {\n\t\tname: \"state_state_sync_duration\",\n\t\tmetrics_type: MetricsType::Histogram,\n\t\tunit: metrics::Unit::Microseconds,\n\t\tdescription: \"State State Sync Duration\",\n\t},\n\tMetrics {\n\t\tname: \"state_state_save_duration\",\n\t\tmetrics_type: MetricsType::Histogram,\n\t\tunit: metrics::Unit::Microseconds,\n\t\tdescription: \"State State Save Duration\",\n\t},\n\tMetrics {\n\t\tname: \"state_active_player_count\",\n\t\tmetrics_type: MetricsType::Histogram,\n\t\tunit: metrics::Unit::Count,\n\t\tdescription: \"State Active Player Count\",\n\t},\n\tMetrics {\n\t\tname: \"state_active_object_count\",\n\t\tmetrics_type: MetricsType::Histogram,\n\t\tunit: metrics::Unit::Count,\n\t\tdescription: \"State Active Object Count\",\n\t},\n\tMetrics {\n\t\tname: \"index_spatial_reindex_duration\",\n\t\tmetrics_type: MetricsType::Histogram,\n\t\tunit: metrics::Unit::Microseconds,\n\t\tdescription: \"Index Spatial Reindex Duration\",\n\t},\n\tMetrics {\n\t\tname: \"spatial_index_count\",\n\t\tmetrics_type: MetricsType::Histogram,\n\t\tunit: metrics::Unit::Count,\n\t\tdescription: \"Spatial Index Count\",\n\t},\n\tMetrics {\n\t\tname: \"index_spatial_query_duration\",\n\t\tmetrics_type: MetricsType::Histogram,\n\t\tunit: metrics::Unit::Microseconds,\n\t\tdescription: \"Index Spatial Query Duration\",\n\t},\n\tMetrics {\n\t\tname: \"udp_replication_packets_received_count\",\n\t\tmetrics_type: MetricsType::Counter,\n\t\tunit: metrics::Unit::Count,\n\t\tdescription: \"Number of UDP replication packets received\",\n\t},\n\tMetrics {\n\t\tname: \"udp_replication_packets_sent_count\",\n\t\tmetrics_type: MetricsType::Counter,\n\t\tunit: metrics::Unit::Count,\n\t\tdescription: \"Number of UDP replication packets sent\",\n\t},\n\tMetrics {\n\t\tname: \"udp_replication_received_packet_size\",\n\t\tmetrics_type: MetricsType::Histogram,\n\t\tunit: metrics::Unit::Bytes,\n\t\tdescription: \"Size of UDP received replication packets\",\n\t},\n\tMetrics {\n\t\tname: \"udp_replication_sent_packet_size\",\n\t\tmetrics_type: MetricsType::Histogram,\n\t\tunit: metrics::Unit::Bytes,\n\t\tdescription: \"Size of UDP replication packets sent\",\n\t},\n\tMetrics {\n\t\tname: \"udp_replication_produced_packets_datum_count\",\n\t\tmetrics_type: MetricsType::Counter,\n\t\tunit: metrics::Unit::Count,\n\t\tdescription: \"Number of datums in one UDP replication packets sent\",\n\t},\n\tMetrics {\n\t\tname: \"udp_replication_produced_packets_backlog_count\",\n\t\tmetrics_type: MetricsType::Counter,\n\t\tunit: metrics::Unit::Count,\n\t\tdescription: \"Number of packets in UDP replication outbound backlog\",\n\t},\n\tMetrics {\n\t\tname: \"udp_replication_packets_received_invalid_count\",\n\t\tmetrics_type: MetricsType::Counter,\n\t\tunit: metrics::Unit::Count,\n\t\tdescription: \"Number of invalid packets in UDP replication\",\n\t},\n\tMetrics {\n\t\tname: \"udp_replication_entity_packets\",\n\t\tmetrics_type: MetricsType::Counter,\n\t\tunit: metrics::Unit::Count,\n\t\tdescription: \"Number of UDP replication packets with entity changes\",\n\t},\n\tMetrics {\n\t\tname: \"udp_replication_event_packets\",\n\t\tmetrics_type: MetricsType::Counter,\n\t\tunit: metrics::Unit::Count,\n\t\tdescription: \"Number of UDP replication packets with events\",\n\t},\n\tMetrics {\n\t\tname: \"udp_replication_control_packets\",\n\t\tmetrics_type: MetricsType::Counter,\n\t\tunit: metrics::Unit::Count,\n\t\tdescription: \"Number of UDP replication packets with control messages\",\n\t},\n\tMetrics {\n\t\tname: \"udp_client_update_packets_received_invalid_count\",\n\t\tmetrics_type: MetricsType::Counter,\n\t\tunit: metrics::Unit::Count,\n\t\tdescription: \"Number of UDP client packets with invalid length\",\n\t},\n\tMetrics {\n\t\tname: \"udp_client_update_packets_received_count\",\n\t\tmetrics_type: MetricsType::Counter,\n\t\tunit: metrics::Unit::Count,\n\t\tdescription: \"Number of UDP client packets received\",\n\t},\n\tMetrics {\n\t\tname: \"udp_client_update_received_packet_size\",\n\t\tmetrics_type: MetricsType::Histogram,\n\t\tunit: metrics::Unit::Count,\n\t\tdescription: \"Size of UDP packets received from clients\",\n\t},\n];\n\npub fn register_metrics(recorder: \u0026dyn Recorder) {\n\tfor entry in METRICES_ARRAY {\n\t\tmatch entry.metrics_type {\n\t\t\tMetricsType::Counter =\u003e {\n\t\t\t\trecorder.describe_counter(\n\t\t\t\t\tentry.name.into(),\n\t\t\t\t\tSome(entry.unit),\n\t\t\t\t\tentry.description.into(),\n\t\t\t\t);\n\t\t\t}\n\t\t\tMetricsType::Gauge =\u003e {\n\t\t\t\trecorder.describe_gauge(\n\t\t\t\t\tentry.name.into(),\n\t\t\t\t\tSome(entry.unit),\n\t\t\t\t\tentry.description.into(),\n\t\t\t\t);\n\t\t\t}\n\t\t\tMetricsType::Histogram =\u003e {\n\t\t\t\trecorder.describe_histogram(\n\t\t\t\t\tentry.name.into(),\n\t\t\t\t\tSome(entry.unit),\n\t\t\t\t\tentry.description.into(),\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","objects","average.rs"],"content":"use {\n\tsuper::{current_timestamp, mode::BlendMode},\n\tcrate::{\n\t\tschema::{Blend, GetByKey},\n\t\tsession::Session,\n\t\tstate::{\n\t\t\tentity::AttributeId,\n\t\t\tobject::{ObjectEntity, ObjectId},\n\t\t\tTimestamp,\n\t\t\tTimestampedVal,\n\t\t},\n\t},\n\tbitvec::array::BitArray,\n\tdashmap::{mapref::entry::Entry, DashMap},\n\tparking_lot::RwLock,\n\tquark_client_sdk::{protocol::common::object, EntityId, Value},\n\tschemars::JsonSchema,\n\tserde::{Deserialize, Serialize},\n\tstd::{\n\t\tmem::{size_of, MaybeUninit},\n\t\tops::{Add, AddAssign, Div, SubAssign},\n\t\ttime::{Duration, Instant},\n\t},\n};\n\n#[derive(\n\tDebug, Clone, Copy, Default, PartialEq, JsonSchema, Serialize, Deserialize,\n)]\n#[serde(rename_all = \"snake_case\")]\npub enum AverageMethod {\n\t#[default]\n\tMean,\n\tMedian,\n\tMode,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\", default)]\npub struct AverageParams {\n\tpub samples: usize,\n\t#[serde(with = \"humantime_serde\")]\n\tpub period: Duration,\n\tpub method: AverageMethod,\n}\n\nimpl Default for AverageParams {\n\tfn default() -\u003e Self {\n\t\tSelf {\n\t\t\tsamples: 16,\n\t\t\tperiod: Duration::from_millis(50),\n\t\t\tmethod: AverageMethod::Mean,\n\t\t}\n\t}\n}\n\npub const MAX_CAPACITY: usize = 128;\nconst WINDOW_BITS: usize = (MAX_CAPACITY / size_of::\u003cusize\u003e()) / 8;\n\n#[derive(Debug)]\nstruct History {\n\tparams: AverageParams,\n\toccupancy: BitArray\u003c[usize; WINDOW_BITS]\u003e,\n\tvalues: [MaybeUninit\u003c(AveragableValue, Instant)\u003e; MAX_CAPACITY],\n}\n\nimpl History {\n\tfn new(value: AveragableValue, params: AverageParams) -\u003e Self {\n\t\tassert!(params.samples \u003c= MAX_CAPACITY);\n\t\tassert!(params.samples \u003e 1);\n\n\t\tlet occupancy_buffer = [0usize; WINDOW_BITS];\n\t\tlet mut occupancy = BitArray::new(occupancy_buffer);\n\t\tlet mut values = [MaybeUninit::uninit(); MAX_CAPACITY];\n\n\t\toccupancy.set(0, true);\n\t\tvalues[0] = MaybeUninit::new((value, Instant::now()));\n\n\t\tSelf {\n\t\t\toccupancy,\n\t\t\tvalues,\n\t\t\tparams,\n\t\t}\n\t}\n\n\t/// Emplaces a new value into the history and returns the number\n\t/// of non-expired values in the history. All values of the history\n\t/// are always contiguous, not necessarily sorted, but contiguous.\n\tfn emplace(\u0026mut self, value: AveragableValue) -\u003e usize {\n\t\tlet mut oldest = (0, Duration::ZERO);\n\n\t\t// scan through all occupied slots and remove expired slots\n\t\t// and find the oldest non-expired slot, in case we need to\n\t\t// make room for a new value.\n\t\tfor i in 0..self.occupancy.len() {\n\t\t\tif *self.occupancy.get(i).unwrap() {\n\t\t\t\tlet (_, timestamp) = unsafe { self.values[i].assume_init() };\n\t\t\t\tif timestamp.elapsed() \u003e self.params.period {\n\t\t\t\t\tself.occupancy.set(i, false); // remove expired slot\n\t\t\t\t} else if oldest.1 \u003c timestamp.elapsed() {\n\t\t\t\t\toldest = (i, timestamp.elapsed());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// if all slots are occupied, remove the oldest\n\t\tif self.occupancy.count_ones() \u003e= self.params.samples {\n\t\t\tself.occupancy.set(oldest.0, false);\n\t\t}\n\n\t\t// now compact the values to remove gaps in occupancy\n\t\t// by this point we should have at least one free slot\n\t\tfor i in 0..self.occupancy.len() {\n\t\t\tif !*self.occupancy.get(i).unwrap() {\n\t\t\t\tlet next_occupied =\n\t\t\t\t\tself.occupancy.iter().skip(i).position(|v| *v).unwrap_or(0);\n\t\t\t\tself.values.swap(i, i + next_occupied);\n\t\t\t\tself.occupancy.set(i, true);\n\t\t\t\tself.occupancy.set(i + next_occupied, false);\n\t\t\t}\n\t\t}\n\n\t\tlet free_slot = self\n\t\t\t.occupancy\n\t\t\t.first_zero()\n\t\t\t.expect(\"must have at least one free slot\");\n\n\t\tself.occupancy.set(free_slot, true);\n\t\tself.values[free_slot] = MaybeUninit::new((value, Instant::now()));\n\n\t\tfree_slot + 1\n\t}\n\n\t/// Pushes a new value into the history and returns\n\t/// the average so far for things that are more recent\n\t/// then the window duration. We return the same timestamp if value is\n\t/// not modified by the server, otherwise we return server's timestamp\n\tfn push(\n\t\t\u0026mut self,\n\t\tvalue: AveragableValue,\n\t\ttimestamp: Timestamp,\n\t) -\u003e (AveragableValue, Timestamp) {\n\t\tlet occupancy = self.emplace(value);\n\t\tlet avg = match self.params.method {\n\t\t\tAverageMethod::Mean =\u003e {\n\t\t\t\tlet sum = self.values[..occupancy]\n\t\t\t\t\t.iter()\n\t\t\t\t\t.map(|val| unsafe { val.assume_init() }.0)\n\t\t\t\t\t.reduce(|acc, v| acc + v)\n\t\t\t\t\t.unwrap();\n\t\t\t\tsum / occupancy\n\t\t\t}\n\t\t\tAverageMethod::Median =\u003e {\n\t\t\t\tself.values[..occupancy].sort_by(|a, b| {\n\t\t\t\t\tlet (a, _) = unsafe { a.assume_init() };\n\t\t\t\t\tlet (b, _) = unsafe { b.assume_init() };\n\t\t\t\t\ta.partial_cmp(\u0026b).unwrap()\n\t\t\t\t});\n\t\t\t\tlet mid = occupancy / 2;\n\t\t\t\tunsafe { self.values[mid].assume_init() }.0\n\t\t\t}\n\t\t\tAverageMethod::Mode =\u003e {\n\t\t\t\t// we want to avoid any allocations here\n\t\t\t\t// so we accept an n^2 algorithm for this\n\t\t\t\t// case given that we know that the maximum\n\t\t\t\t// number of samples is fixed to a small number.\n\t\t\t\tlet mut counts = [0; MAX_CAPACITY];\n\n\t\t\t\t#[allow(clippy::needless_range_loop)]\n\t\t\t\tfor i in 0..occupancy {\n\t\t\t\t\tfor j in 0..occupancy {\n\t\t\t\t\t\tif unsafe { self.values[i].assume_init() }.0\n\t\t\t\t\t\t\t== unsafe { self.values[j].assume_init() }.0\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcounts[i] += 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet mut max = 0;\n\t\t\t\tlet mut maxix = 0;\n\n\t\t\t\t#[allow(clippy::needless_range_loop)]\n\t\t\t\tfor i in 0..occupancy {\n\t\t\t\t\tif counts[i] \u003e max {\n\t\t\t\t\t\tmax = counts[i];\n\t\t\t\t\t\tmaxix = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tunsafe { self.values[maxix].assume_init() }.0\n\t\t\t}\n\t\t};\n\t\tlet timestamp = if occupancy == 1 {\n\t\t\ttimestamp\n\t\t} else {\n\t\t\tcurrent_timestamp()\n\t\t};\n\n\t\t(avg, timestamp)\n\t}\n}\n\n#[derive(Default)]\npub struct Average {\n\thistory: DashMap\u003c(ObjectId, AttributeId), RwLock\u003cHistory\u003e\u003e,\n\tfields: DashMap\u003cObjectId, Vec\u003cAttributeId\u003e\u003e,\n}\n\nimpl BlendMode for Average {\n\tfn despawned(\u0026self, object: ObjectId) {\n\t\tlet Some((_, fields)) = self.fields.remove(\u0026object) else {\n\t\t\treturn;\n\t\t};\n\n\t\tfor field in fields {\n\t\t\tself.history.remove(\u0026(object, field));\n\t\t}\n\t}\n\n\tfn update(\n\t\t\u0026self,\n\t\tby: \u0026Session,\n\t\tobject: \u0026ObjectEntity,\n\t\tkeys: \u0026[AttributeId],\n\t\treader: object::Reader\u003c'_\u003e,\n\t) -\u003e Vec\u003cOption\u003cTimestampedVal\u003e\u003e {\n\t\t// represents no changes to all attributes\n\t\t// in the same order as the keys\n\t\tlet no_changes = || vec![None; keys.len()];\n\n\t\tlet EntityId::Object(object_id) = *object.id() else {\n\t\t\t// this is not an object entity\n\t\t\treturn no_changes();\n\t\t};\n\n\t\tlet mut changes = Vec::with_capacity(keys.len());\n\n\t\tfor key in keys {\n\t\t\tlet key = (object_id, *key);\n\t\t\tlet Some((value, timestamp)) = reader\n\t\t\t\t.get_attributes()\n\t\t\t\t.ok()\n\t\t\t\t.and_then(|reader| {\n\t\t\t\t\treader\n\t\t\t\t\t\t.iter()\n\t\t\t\t\t\t.find(|attrib| attrib.get_key() == key.1)\n\t\t\t\t\t\t.and_then(|attrib| {\n\t\t\t\t\t\t\tValue::from_capnp_reader(\u0026attrib.get_value())\n\t\t\t\t\t\t\t\t.map(|v| v.try_into().ok())\n\t\t\t\t\t\t\t\t.ok()\n\t\t\t\t\t\t\t\t.map(|v| v.map(|y| (y, attrib.get_timestamp())))\n\t\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t\t.flatten()\n\t\t\telse {\n\t\t\t\tchanges.push(None);\n\t\t\t\tcontinue;\n\t\t\t};\n\n\t\t\tif let Some(history) = self.history.get(\u0026key) {\n\t\t\t\t// this is the fast path and more likely to happen\n\t\t\t\t// don't take a shard lock on the dashmap\n\t\t\t\t// instead lock very locally on individual entry\n\t\t\t\tlet history = history.value();\n\t\t\t\tlet (avg, avg_timestamp) = history.write().push(value, timestamp);\n\t\t\t\tchanges.push(Some((avg.into(), avg_timestamp).into()));\n\t\t\t} else {\n\t\t\t\t// this is the slower and less likely path where the attribute\n\t\t\t\t// is seen for the first time. We need to configure it's averaging\n\t\t\t\t// parameters and instantiate the data structure that will accumulate\n\t\t\t\t// the values.\n\t\t\t\tlet (avg, avg_timestamp) = match self.history.entry(key) {\n\t\t\t\t\tEntry::Occupied(mut history) =\u003e {\n\t\t\t\t\t\thistory.get_mut().write().push(value, timestamp)\n\t\t\t\t\t}\n\t\t\t\t\tEntry::Vacant(slot) =\u003e {\n\t\t\t\t\t\tlet Blend::Average(params) = by\n\t\t\t\t\t\t\t.global\n\t\t\t\t\t\t\t.schema()\n\t\t\t\t\t\t\t.spec_of(object)\n\t\t\t\t\t\t\t.attributes()\n\t\t\t\t\t\t\t.get_by_key(\u0026key.1)\n\t\t\t\t\t\t\t.map(|a| a.blend)\n\t\t\t\t\t\t\t.expect(\"attributes not in schema have default blend\")\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tunreachable!(\n\t\t\t\t\t\t\t\t\"This blending mode should have not been called on attribute \\\n\t\t\t\t\t\t\t\t id {}: {:?}\",\n\t\t\t\t\t\t\t\tkey.1,\n\t\t\t\t\t\t\t\tby.global.schema().spec_of(object).blend()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tslot.insert(RwLock::new(History::new(value, params)));\n\t\t\t\t\t\tself.fields.entry(object_id).or_default().push(key.1);\n\t\t\t\t\t\t(value, timestamp)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tchanges.push(Some((avg.into(), avg_timestamp).into()));\n\t\t\t}\n\t\t}\n\n\t\tchanges\n\t}\n\n\tfn can_despawn(\u0026self, _by: \u0026Session, _object: \u0026ObjectEntity) -\u003e bool {\n\t\ttrue\n\t}\n}\n\n#[derive(Copy, PartialEq, PartialOrd, Clone, Debug)]\nenum AveragableValue {\n\tUint8(u8),\n\tUint16(u16),\n\tUint32(u32),\n\tUint64(u64),\n\tInt8(i8),\n\tInt16(i16),\n\tInt32(i32),\n\tInt64(i64),\n\tFloat32(f32),\n\tFloat64(f64),\n\tVec2((f32, f32)),\n\tVec3((f32, f32, f32)),\n\tVec4((f32, f32, f32, f32)),\n\tVec2d((f64, f64)),\n\tVec3d((f64, f64, f64)),\n\tVec4d((f64, f64, f64, f64)),\n}\n\nimpl TryFrom\u003cValue\u003e for AveragableValue {\n\ttype Error = ();\n\n\tfn try_from(value: Value) -\u003e Result\u003cSelf, Self::Error\u003e {\n\t\tmatch value {\n\t\t\tValue::Vec2(v) =\u003e Ok(AveragableValue::Vec2(v)),\n\t\t\tValue::Vec3(v) =\u003e Ok(AveragableValue::Vec3(v)),\n\t\t\tValue::Uint8(u) =\u003e Ok(AveragableValue::Uint8(u)),\n\t\t\tValue::Uint16(u) =\u003e Ok(AveragableValue::Uint16(u)),\n\t\t\tValue::Uint32(u) =\u003e Ok(AveragableValue::Uint32(u)),\n\t\t\tValue::Uint64(u) =\u003e Ok(AveragableValue::Uint64(u)),\n\t\t\tValue::Int8(i) =\u003e Ok(AveragableValue::Int8(i)),\n\t\t\tValue::Int16(i) =\u003e Ok(AveragableValue::Int16(i)),\n\t\t\tValue::Int32(i) =\u003e Ok(AveragableValue::Int32(i)),\n\t\t\tValue::Int64(i) =\u003e Ok(AveragableValue::Int64(i)),\n\t\t\tValue::Float32(f) =\u003e Ok(AveragableValue::Float32(f)),\n\t\t\tValue::Float64(f) =\u003e Ok(AveragableValue::Float64(f)),\n\t\t\tValue::Vec2d(v) =\u003e Ok(AveragableValue::Vec2d(v)),\n\t\t\tValue::Vec3d(v) =\u003e Ok(AveragableValue::Vec3d(v)),\n\t\t\tValue::Vec4(v) =\u003e Ok(AveragableValue::Vec4(v)),\n\t\t\tValue::Vec4d(v) =\u003e Ok(AveragableValue::Vec4d(v)),\n\t\t\t_ =\u003e Err(()),\n\t\t}\n\t}\n}\n\nimpl From\u003cAveragableValue\u003e for Value {\n\tfn from(value: AveragableValue) -\u003e Self {\n\t\tmatch value {\n\t\t\tAveragableValue::Uint8(value) =\u003e Value::Uint8(value),\n\t\t\tAveragableValue::Uint16(value) =\u003e Value::Uint16(value),\n\t\t\tAveragableValue::Uint32(value) =\u003e Value::Uint32(value),\n\t\t\tAveragableValue::Uint64(value) =\u003e Value::Uint64(value),\n\t\t\tAveragableValue::Int8(value) =\u003e Value::Int8(value),\n\t\t\tAveragableValue::Int16(value) =\u003e Value::Int16(value),\n\t\t\tAveragableValue::Int32(value) =\u003e Value::Int32(value),\n\t\t\tAveragableValue::Int64(value) =\u003e Value::Int64(value),\n\t\t\tAveragableValue::Float32(value) =\u003e Value::Float32(value),\n\t\t\tAveragableValue::Float64(value) =\u003e Value::Float64(value),\n\t\t\tAveragableValue::Vec2(value) =\u003e Value::Vec2(value),\n\t\t\tAveragableValue::Vec3(value) =\u003e Value::Vec3(value),\n\t\t\tAveragableValue::Vec4(value) =\u003e Value::Vec4(value),\n\t\t\tAveragableValue::Vec2d(value) =\u003e Value::Vec2d(value),\n\t\t\tAveragableValue::Vec3d(value) =\u003e Value::Vec3d(value),\n\t\t\tAveragableValue::Vec4d(value) =\u003e Value::Vec4d(value),\n\t\t}\n\t}\n}\n\nimpl Add for AveragableValue {\n\ttype Output = Self;\n\n\tfn add(self, other: Self) -\u003e Self {\n\t\tmatch (self, other) {\n\t\t\t(AveragableValue::Uint8(a), AveragableValue::Uint8(b)) =\u003e {\n\t\t\t\tAveragableValue::Uint8(a + b)\n\t\t\t}\n\t\t\t(AveragableValue::Uint16(a), AveragableValue::Uint16(b)) =\u003e {\n\t\t\t\tAveragableValue::Uint16(a + b)\n\t\t\t}\n\t\t\t(AveragableValue::Uint32(a), AveragableValue::Uint32(b)) =\u003e {\n\t\t\t\tAveragableValue::Uint32(a + b)\n\t\t\t}\n\t\t\t(AveragableValue::Uint64(a), AveragableValue::Uint64(b)) =\u003e {\n\t\t\t\tAveragableValue::Uint64(a + b)\n\t\t\t}\n\t\t\t(AveragableValue::Int8(a), AveragableValue::Int8(b)) =\u003e {\n\t\t\t\tAveragableValue::Int8(a + b)\n\t\t\t}\n\t\t\t(AveragableValue::Int16(a), AveragableValue::Int16(b)) =\u003e {\n\t\t\t\tAveragableValue::Int16(a + b)\n\t\t\t}\n\t\t\t(AveragableValue::Int32(a), AveragableValue::Int32(b)) =\u003e {\n\t\t\t\tAveragableValue::Int32(a + b)\n\t\t\t}\n\t\t\t(AveragableValue::Int64(a), AveragableValue::Int64(b)) =\u003e {\n\t\t\t\tAveragableValue::Int64(a + b)\n\t\t\t}\n\t\t\t(AveragableValue::Float32(a), AveragableValue::Float32(b)) =\u003e {\n\t\t\t\tAveragableValue::Float32(a + b)\n\t\t\t}\n\t\t\t(AveragableValue::Float64(a), AveragableValue::Float64(b)) =\u003e {\n\t\t\t\tAveragableValue::Float64(a + b)\n\t\t\t}\n\t\t\t(AveragableValue::Vec2(a), AveragableValue::Vec2(b)) =\u003e {\n\t\t\t\tAveragableValue::Vec2((a.0 + b.0, a.1 + b.1))\n\t\t\t}\n\t\t\t(AveragableValue::Vec3(a), AveragableValue::Vec3(b)) =\u003e {\n\t\t\t\tAveragableValue::Vec3((a.0 + b.0, a.1 + b.1, a.2 + b.2))\n\t\t\t}\n\t\t\t(AveragableValue::Vec4(a), AveragableValue::Vec4(b)) =\u003e {\n\t\t\t\tAveragableValue::Vec4((a.0 + b.0, a.1 + b.1, a.2 + b.2, a.3 + b.3))\n\t\t\t}\n\t\t\t(AveragableValue::Vec2d(a), AveragableValue::Vec2d(b)) =\u003e {\n\t\t\t\tAveragableValue::Vec2d((a.0 + b.0, a.1 + b.1))\n\t\t\t}\n\t\t\t(AveragableValue::Vec3d(a), AveragableValue::Vec3d(b)) =\u003e {\n\t\t\t\tAveragableValue::Vec3d((a.0 + b.0, a.1 + b.1, a.2 + b.2))\n\t\t\t}\n\t\t\t(AveragableValue::Vec4d(a), AveragableValue::Vec4d(b)) =\u003e {\n\t\t\t\tAveragableValue::Vec4d((a.0 + b.0, a.1 + b.1, a.2 + b.2, a.3 + b.3))\n\t\t\t}\n\t\t\t_ =\u003e unreachable!(),\n\t\t}\n\t}\n}\n\nimpl AddAssign for AveragableValue {\n\tfn add_assign(\u0026mut self, other: Self) {\n\t\tmatch (self, other) {\n\t\t\t(AveragableValue::Uint8(ref mut a), AveragableValue::Uint8(b)) =\u003e *a += b,\n\t\t\t(AveragableValue::Uint16(ref mut a), AveragableValue::Uint16(b)) =\u003e {\n\t\t\t\t*a += b\n\t\t\t}\n\t\t\t(AveragableValue::Uint32(ref mut a), AveragableValue::Uint32(b)) =\u003e {\n\t\t\t\t*a += b\n\t\t\t}\n\t\t\t(AveragableValue::Uint64(ref mut a), AveragableValue::Uint64(b)) =\u003e {\n\t\t\t\t*a += b\n\t\t\t}\n\t\t\t(AveragableValue::Int8(ref mut a), AveragableValue::Int8(b)) =\u003e *a += b,\n\t\t\t(AveragableValue::Int16(ref mut a), AveragableValue::Int16(b)) =\u003e *a += b,\n\t\t\t(AveragableValue::Int32(ref mut a), AveragableValue::Int32(b)) =\u003e *a += b,\n\t\t\t(AveragableValue::Int64(ref mut a), AveragableValue::Int64(b)) =\u003e *a += b,\n\t\t\t(AveragableValue::Float32(ref mut a), AveragableValue::Float32(b)) =\u003e {\n\t\t\t\t*a += b\n\t\t\t}\n\t\t\t(AveragableValue::Float64(ref mut a), AveragableValue::Float64(b)) =\u003e {\n\t\t\t\t*a += b\n\t\t\t}\n\t\t\t(AveragableValue::Vec2(ref mut a), AveragableValue::Vec2(b)) =\u003e {\n\t\t\t\ta.0 += b.0;\n\t\t\t\ta.1 += b.1;\n\t\t\t}\n\t\t\t(AveragableValue::Vec3(ref mut a), AveragableValue::Vec3(b)) =\u003e {\n\t\t\t\ta.0 += b.0;\n\t\t\t\ta.1 += b.1;\n\t\t\t\ta.2 += b.2;\n\t\t\t}\n\t\t\t(AveragableValue::Vec4(ref mut a), AveragableValue::Vec4(b)) =\u003e {\n\t\t\t\ta.0 += b.0;\n\t\t\t\ta.1 += b.1;\n\t\t\t\ta.2 += b.2;\n\t\t\t\ta.3 += b.3;\n\t\t\t}\n\t\t\t(AveragableValue::Vec2d(ref mut a), AveragableValue::Vec2d(b)) =\u003e {\n\t\t\t\ta.0 += b.0;\n\t\t\t\ta.1 += b.1;\n\t\t\t}\n\t\t\t(AveragableValue::Vec3d(ref mut a), AveragableValue::Vec3d(b)) =\u003e {\n\t\t\t\ta.0 += b.0;\n\t\t\t\ta.1 += b.1;\n\t\t\t\ta.2 += b.2;\n\t\t\t}\n\t\t\t(AveragableValue::Vec4d(ref mut a), AveragableValue::Vec4d(b)) =\u003e {\n\t\t\t\ta.0 += b.0;\n\t\t\t\ta.1 += b.1;\n\t\t\t\ta.2 += b.2;\n\t\t\t\ta.3 += b.3;\n\t\t\t}\n\t\t\t_ =\u003e unreachable!(),\n\t\t}\n\t}\n}\n\nimpl SubAssign for AveragableValue {\n\tfn sub_assign(\u0026mut self, other: Self) {\n\t\tmatch (self, other) {\n\t\t\t(AveragableValue::Uint8(ref mut a), AveragableValue::Uint8(b)) =\u003e *a -= b,\n\t\t\t(AveragableValue::Uint16(ref mut a), AveragableValue::Uint16(b)) =\u003e {\n\t\t\t\t*a -= b\n\t\t\t}\n\t\t\t(AveragableValue::Uint32(ref mut a), AveragableValue::Uint32(b)) =\u003e {\n\t\t\t\t*a -= b\n\t\t\t}\n\t\t\t(AveragableValue::Uint64(ref mut a), AveragableValue::Uint64(b)) =\u003e {\n\t\t\t\t*a -= b\n\t\t\t}\n\t\t\t(AveragableValue::Int8(ref mut a), AveragableValue::Int8(b)) =\u003e *a -= b,\n\t\t\t(AveragableValue::Int16(ref mut a), AveragableValue::Int16(b)) =\u003e *a -= b,\n\t\t\t(AveragableValue::Int32(ref mut a), AveragableValue::Int32(b)) =\u003e *a -= b,\n\t\t\t(AveragableValue::Int64(ref mut a), AveragableValue::Int64(b)) =\u003e *a -= b,\n\t\t\t(AveragableValue::Float32(ref mut a), AveragableValue::Float32(b)) =\u003e {\n\t\t\t\t*a -= b\n\t\t\t}\n\t\t\t(AveragableValue::Float64(ref mut a), AveragableValue::Float64(b)) =\u003e {\n\t\t\t\t*a -= b\n\t\t\t}\n\t\t\t(AveragableValue::Vec2(ref mut a), AveragableValue::Vec2(b)) =\u003e {\n\t\t\t\ta.0 -= b.0;\n\t\t\t\ta.1 -= b.1;\n\t\t\t}\n\t\t\t(AveragableValue::Vec3(ref mut a), AveragableValue::Vec3(b)) =\u003e {\n\t\t\t\ta.0 -= b.0;\n\t\t\t\ta.1 -= b.1;\n\t\t\t\ta.2 -= b.2;\n\t\t\t}\n\t\t\t(AveragableValue::Vec4(ref mut a), AveragableValue::Vec4(b)) =\u003e {\n\t\t\t\ta.0 -= b.0;\n\t\t\t\ta.1 -= b.1;\n\t\t\t\ta.2 -= b.2;\n\t\t\t}\n\t\t\t(AveragableValue::Vec2d(ref mut a), AveragableValue::Vec2d(b)) =\u003e {\n\t\t\t\ta.0 -= b.0;\n\t\t\t\ta.1 -= b.1;\n\t\t\t}\n\t\t\t(AveragableValue::Vec3d(ref mut a), AveragableValue::Vec3d(b)) =\u003e {\n\t\t\t\ta.0 -= b.0;\n\t\t\t\ta.1 -= b.1;\n\t\t\t\ta.2 -= b.2;\n\t\t\t}\n\t\t\t(AveragableValue::Vec4d(ref mut a), AveragableValue::Vec4d(b)) =\u003e {\n\t\t\t\ta.0 -= b.0;\n\t\t\t\ta.1 -= b.1;\n\t\t\t\ta.2 -= b.2;\n\t\t\t}\n\t\t\t_ =\u003e unreachable!(),\n\t\t}\n\t}\n}\n\nimpl Div\u003cusize\u003e for AveragableValue {\n\ttype Output = Self;\n\n\tfn div(self, rhs: usize) -\u003e Self {\n\t\tmatch self {\n\t\t\tAveragableValue::Uint8(value) =\u003e {\n\t\t\t\tAveragableValue::Uint8(value / rhs as u8)\n\t\t\t}\n\t\t\tAveragableValue::Uint16(value) =\u003e {\n\t\t\t\tAveragableValue::Uint16(value / rhs as u16)\n\t\t\t}\n\t\t\tAveragableValue::Uint32(value) =\u003e {\n\t\t\t\tAveragableValue::Uint32(value / rhs as u32)\n\t\t\t}\n\t\t\tAveragableValue::Uint64(value) =\u003e {\n\t\t\t\tAveragableValue::Uint64(value / rhs as u64)\n\t\t\t}\n\t\t\tAveragableValue::Int8(value) =\u003e AveragableValue::Int8(value / rhs as i8),\n\t\t\tAveragableValue::Int16(value) =\u003e {\n\t\t\t\tAveragableValue::Int16(value / rhs as i16)\n\t\t\t}\n\t\t\tAveragableValue::Int32(value) =\u003e {\n\t\t\t\tAveragableValue::Int32(value / rhs as i32)\n\t\t\t}\n\t\t\tAveragableValue::Int64(value) =\u003e {\n\t\t\t\tAveragableValue::Int64(value / rhs as i64)\n\t\t\t}\n\t\t\tAveragableValue::Float32(value) =\u003e {\n\t\t\t\tAveragableValue::Float32(value / rhs as f32)\n\t\t\t}\n\t\t\tAveragableValue::Float64(value) =\u003e {\n\t\t\t\tAveragableValue::Float64(value / rhs as f64)\n\t\t\t}\n\t\t\tAveragableValue::Vec2(value) =\u003e {\n\t\t\t\tAveragableValue::Vec2((value.0 / rhs as f32, value.1 / rhs as f32))\n\t\t\t}\n\t\t\tAveragableValue::Vec3(value) =\u003e AveragableValue::Vec3((\n\t\t\t\tvalue.0 / rhs as f32,\n\t\t\t\tvalue.1 / rhs as f32,\n\t\t\t\tvalue.2 / rhs as f32,\n\t\t\t)),\n\t\t\tAveragableValue::Vec4(value) =\u003e AveragableValue::Vec4((\n\t\t\t\tvalue.0 / rhs as f32,\n\t\t\t\tvalue.1 / rhs as f32,\n\t\t\t\tvalue.2 / rhs as f32,\n\t\t\t\tvalue.3 / rhs as f32,\n\t\t\t)),\n\t\t\tAveragableValue::Vec2d(value) =\u003e {\n\t\t\t\tAveragableValue::Vec2d((value.0 / rhs as f64, value.1 / rhs as f64))\n\t\t\t}\n\t\t\tAveragableValue::Vec3d(value) =\u003e AveragableValue::Vec3d((\n\t\t\t\tvalue.0 / rhs as f64,\n\t\t\t\tvalue.1 / rhs as f64,\n\t\t\t\tvalue.2 / rhs as f64,\n\t\t\t)),\n\t\t\tAveragableValue::Vec4d(value) =\u003e AveragableValue::Vec4d((\n\t\t\t\tvalue.0 / rhs as f64,\n\t\t\t\tvalue.1 / rhs as f64,\n\t\t\t\tvalue.2 / rhs as f64,\n\t\t\t\tvalue.3 / rhs as f64,\n\t\t\t)),\n\t\t}\n\t}\n}\n\n#[cfg(test)]\nmod test {\n\tuse {\n\t\tsuper::History,\n\t\tcrate::objects::average::AveragableValue,\n\t\tquark_client_sdk::Value,\n\t\tstd::time::Duration,\n\t};\n\n\t#[test]\n\tfn average_smoke() {\n\t\tlet params = super::AverageParams {\n\t\t\tsamples: 2,\n\t\t\tperiod: Duration::from_secs(1),\n\t\t\tmethod: super::AverageMethod::Mean,\n\t\t};\n\t\t// Testing for Value::Uint8 and Value::Int8\n\t\tlet value1 = Value::Uint8(10).try_into().unwrap();\n\t\tlet value2 = Value::Uint8(20).try_into().unwrap();\n\t\tlet mut avg = History::new(value1, params);\n\t\tlet (avg_value2, timestamp) = avg.push(value2, 1);\n\t\tlet newval = Value::from(avg_value2);\n\t\tassert_eq!(newval, Value::Uint8(15));\n\t\tassert!(timestamp \u003e 1);\n\n\t\tlet value1 = Value::Int8(10).try_into().unwrap();\n\t\tlet value2 = Value::Int8(20).try_into().unwrap();\n\t\tlet mut avg = History::new(value1, params);\n\t\tlet (avg_value2, _) = avg.push(value2, 1);\n\t\tlet newval = Value::from(avg_value2);\n\t\tassert_eq!(newval, Value::Int8(15));\n\n\t\t// Testing for Value::Uint16 and Value::Int16\n\t\tlet value1 = Value::Uint16(10).try_into().unwrap();\n\t\tlet value2 = Value::Uint16(20).try_into().unwrap();\n\t\tlet mut avg = History::new(value1, params);\n\t\tlet (avg_value2, _) = avg.push(value2, 1);\n\t\tlet newval = Value::from(avg_value2);\n\t\tassert_eq!(newval, Value::Uint16(15));\n\n\t\tlet value1 = Value::Int16(10).try_into().unwrap();\n\t\tlet value2 = Value::Int16(20).try_into().unwrap();\n\t\tlet mut avg = History::new(value1, params);\n\t\tlet (avg_value2, _) = avg.push(value2, 1);\n\t\tlet newval = Value::from(avg_value2);\n\t\tassert_eq!(newval, Value::Int16(15));\n\n\t\t// Testing for Value::Uint32 and Value::Int32\n\t\tlet value1 = Value::Uint32(10).try_into().unwrap();\n\t\tlet value2 = Value::Uint32(20).try_into().unwrap();\n\t\tlet mut avg = History::new(value1, params);\n\t\tlet (avg_value2, _) = avg.push(value2, 1);\n\t\tlet newval = Value::from(avg_value2);\n\t\tassert_eq!(newval, Value::Uint32(15));\n\n\t\tlet value1 = Value::Int32(10).try_into().unwrap();\n\t\tlet value2 = Value::Int32(20).try_into().unwrap();\n\t\tlet mut avg = History::new(value1, params);\n\t\tlet (avg_value2, _) = avg.push(value2, 1);\n\t\tlet newval = Value::from(avg_value2);\n\t\tassert_eq!(newval, Value::Int32(15));\n\n\t\t// Testing for Value::Uint64 and Value::Int64\n\t\tlet value1 = Value::Uint64(10).try_into().unwrap();\n\t\tlet value2 = Value::Uint64(20).try_into().unwrap();\n\t\tlet mut avg = History::new(value1, params);\n\t\tlet (avg_value2, _) = avg.push(value2, 1);\n\t\tlet newval = Value::from(avg_value2);\n\t\tassert_eq!(newval, Value::Uint64(15));\n\n\t\tlet value1 = Value::Int64(10).try_into().unwrap();\n\t\tlet value2 = Value::Int64(20).try_into().unwrap();\n\t\tlet mut avg = History::new(value1, params);\n\t\tlet (avg_value2, _) = avg.push(value2, 1);\n\t\tlet newval = Value::from(avg_value2);\n\t\tassert_eq!(newval, Value::Int64(15));\n\n\t\t// Testing for Value::Float32 and Value::Float64\n\t\tlet value1 = Value::Float32(12.5).try_into().unwrap();\n\t\tlet value2 = Value::Float32(12.5).try_into().unwrap();\n\t\tlet mut avg = History::new(value1, params);\n\t\tlet (avg_value2, _) = avg.push(value2, 1);\n\t\tlet newval = Value::from(avg_value2);\n\t\tassert_eq!(newval, Value::Float32(12.5));\n\n\t\tlet value1 = Value::Float64(12.5).try_into().unwrap();\n\t\tlet value2 = Value::Float64(10.5).try_into().unwrap();\n\t\tlet mut avg = History::new(value1, params);\n\t\tlet (avg_value2, _) = avg.push(value2, 1);\n\t\tlet newval = Value::from(avg_value2);\n\t\tassert_eq!(newval, Value::Float64(11.5));\n\n\t\t// Testing for Value::Vec2 and Value::Vec2d\n\t\tlet value1 = Value::Vec2((12.5, 12.5)).try_into().unwrap();\n\t\tlet value2 = Value::Vec2((12.5, 12.5)).try_into().unwrap();\n\t\tlet mut avg = History::new(value1, params);\n\t\tlet (avg_value2, _) = avg.push(value2, 1);\n\t\tlet newval = Value::from(avg_value2);\n\t\tassert_eq!(newval, Value::Vec2((12.5, 12.5)));\n\n\t\tlet value1 = Value::Vec2d((12.5, 12.5)).try_into().unwrap();\n\t\tlet value2 = Value::Vec2d((10.5, 10.5)).try_into().unwrap();\n\t\tlet mut avg = History::new(value1, params);\n\t\tlet (avg_value2, _) = avg.push(value2, 1);\n\t\tlet newval = Value::from(avg_value2);\n\t\tassert_eq!(newval, Value::Vec2d((11.5, 11.5)));\n\n\t\t// Testing for Value::Vec3 and Value::Vec3d\n\t\tlet value1 = Value::Vec3((12.5, 12.5, 12.5)).try_into().unwrap();\n\t\tlet value2 = Value::Vec3((12.5, 12.5, 12.5)).try_into().unwrap();\n\t\tlet mut avg = History::new(value1, params);\n\t\tlet (avg_value2, _) = avg.push(value2, 1);\n\t\tlet newval = Value::from(avg_value2);\n\t\tassert_eq!(newval, Value::Vec3((12.5, 12.5, 12.5)));\n\n\t\tlet value1 = Value::Vec3d((12.5, 12.5, 12.5)).try_into().unwrap();\n\t\tlet value2 = Value::Vec3d((10.5, 10.5, 10.5)).try_into().unwrap();\n\t\tlet mut avg = History::new(value1, params);\n\t\tlet (avg_value2, _) = avg.push(value2, 1);\n\t\tlet newval = Value::from(avg_value2);\n\t\tassert_eq!(newval, Value::Vec3d((11.5, 11.5, 11.5)));\n\n\t\t// Testing for Value::Vec4 and Value::Vec4d\n\t\tlet value1 = Value::Vec4((12.5, 12.5, 12.5, 12.5)).try_into().unwrap();\n\t\tlet value2 = Value::Vec4((12.5, 12.5, 12.5, 12.5)).try_into().unwrap();\n\t\tlet mut avg = History::new(value1, params);\n\t\tlet (avg_value2, _) = avg.push(value2, 1);\n\t\tlet newval = Value::from(avg_value2);\n\t\tassert_eq!(newval, Value::Vec4((12.5, 12.5, 12.5, 12.5)));\n\n\t\tlet value1 = Value::Vec4d((12.5, 12.5, 12.5, 12.5)).try_into().unwrap();\n\t\tlet value2 = Value::Vec4d((10.5, 10.5, 10.5, 10.5)).try_into().unwrap();\n\t\tlet mut avg = History::new(value1, params);\n\t\tlet (avg_value2, _) = avg.push(value2, 1);\n\t\tlet newval = Value::from(avg_value2);\n\t\tassert_eq!(newval, Value::Vec4d((11.5, 11.5, 11.5, 11.5)));\n\t}\n\n\t#[test]\n\tfn average_expired_values() {\n\t\tlet params = super::AverageParams {\n\t\t\tsamples: 6,\n\t\t\tperiod: Duration::from_millis(100),\n\t\t\tmethod: super::AverageMethod::Mean,\n\t\t};\n\t\tlet value1 = Value::Uint32(10).try_into().unwrap();\n\t\tlet value2 = Value::Uint32(20).try_into().unwrap();\n\t\tlet mut avg = History::new(value1, params);\n\t\tlet (avg_value2, timestamp) = avg.push(value2, 1);\n\t\tlet newval = Value::from(avg_value2);\n\t\tassert_eq!(newval, Value::Uint32(15));\n\t\tassert!(timestamp \u003e 1);\n\n\t\tstd::thread::sleep(Duration::from_millis(200));\n\n\t\t// previous values are older than averaging period\n\t\t// should be discarded and only the most recent one\n\t\t// should be considered.\n\t\tlet value3 = Value::Uint32(7).try_into().unwrap();\n\t\tlet (avg_value3, timestamp) = avg.push(value3, 2);\n\t\tlet newval = Value::from(avg_value3);\n\t\tassert_eq!(newval, Value::Uint32(7));\n\t\tassert_eq!(timestamp, 2);\n\t}\n\n\t#[test]\n\tfn average_discard_oldest() {\n\t\tlet params = super::AverageParams {\n\t\t\tsamples: 2,\n\t\t\tperiod: Duration::from_millis(100),\n\t\t\tmethod: super::AverageMethod::Mean,\n\t\t};\n\t\tlet value1 = Value::Uint32(10).try_into().unwrap();\n\t\tlet value2 = Value::Uint32(20).try_into().unwrap();\n\t\tlet mut avg = History::new(value1, params);\n\t\tstd::thread::sleep(Duration::from_millis(10));\n\t\tlet (avg_value2, _) = avg.push(value2, 1);\n\t\tlet newval = Value::from(avg_value2);\n\t\tassert_eq!(newval, Value::Uint32(15));\n\t\tstd::thread::sleep(Duration::from_millis(10));\n\n\t\t// here the capacity of the averaging window is 2\n\t\t// so the oldest value should be discarded and the\n\t\t// average should be calculated from the most recent\n\t\t// two values.\n\t\tlet value3 = Value::Uint32(8).try_into().unwrap();\n\t\tlet (avg_value3, _) = avg.push(value3, 1);\n\t\tlet newval = Value::from(avg_value3);\n\t\tassert_eq!(newval, Value::Uint32(14));\n\t}\n\n\t#[test]\n\tfn add_sub_assign_smoke() {\n\t\t// Testing for AveragableValue::Uint8 and AveragableValue::Int8\n\t\tlet mut value1 = AveragableValue::Uint8(10);\n\t\tvalue1 += AveragableValue::Uint8(20);\n\t\tassert_eq!(value1, AveragableValue::Uint8(30));\n\t\tvalue1 -= AveragableValue::Uint8(20);\n\t\tassert_eq!(value1, AveragableValue::Uint8(10));\n\n\t\tlet mut value1 = AveragableValue::Int8(10);\n\t\tvalue1 += AveragableValue::Int8(20);\n\t\tassert_eq!(value1, AveragableValue::Int8(30));\n\t\tvalue1 -= AveragableValue::Int8(20);\n\t\tassert_eq!(value1, AveragableValue::Int8(10));\n\n\t\t// Testing for AveragableValue::Uint16 and AveragableValue::Int16\n\t\tlet mut value1 = AveragableValue::Uint16(10);\n\t\tvalue1 += AveragableValue::Uint16(20);\n\t\tassert_eq!(value1, AveragableValue::Uint16(30));\n\t\tvalue1 -= AveragableValue::Uint16(20);\n\t\tassert_eq!(value1, AveragableValue::Uint16(10));\n\n\t\tlet mut value1 = AveragableValue::Int16(10);\n\t\tvalue1 += AveragableValue::Int16(20);\n\t\tassert_eq!(value1, AveragableValue::Int16(30));\n\t\tvalue1 -= AveragableValue::Int16(20);\n\t\tassert_eq!(value1, AveragableValue::Int16(10));\n\n\t\t// Testing for AveragableValue::Uint32 and AveragableValue::Int32\n\t\tlet mut value1 = AveragableValue::Uint32(10);\n\t\tvalue1 += AveragableValue::Uint32(20);\n\t\tassert_eq!(value1, AveragableValue::Uint32(30));\n\t\tvalue1 -= AveragableValue::Uint32(20);\n\t\tassert_eq!(value1, AveragableValue::Uint32(10));\n\n\t\tlet mut value1 = AveragableValue::Int32(10);\n\t\tvalue1 += AveragableValue::Int32(20);\n\t\tassert_eq!(value1, AveragableValue::Int32(30));\n\t\tvalue1 -= AveragableValue::Int32(20);\n\t\tassert_eq!(value1, AveragableValue::Int32(10));\n\n\t\t// Testing for AveragableValue::Uint64 and AveragableValue::Int64\n\t\tlet mut value1 = AveragableValue::Uint64(10);\n\t\tvalue1 += AveragableValue::Uint64(20);\n\t\tassert_eq!(value1, AveragableValue::Uint64(30));\n\t\tvalue1 -= AveragableValue::Uint64(20);\n\t\tassert_eq!(value1, AveragableValue::Uint64(10));\n\n\t\tlet mut value1 = AveragableValue::Int64(10);\n\t\tvalue1 += AveragableValue::Int64(20);\n\t\tassert_eq!(value1, AveragableValue::Int64(30));\n\t\tvalue1 -= AveragableValue::Int64(20);\n\t\tassert_eq!(value1, AveragableValue::Int64(10));\n\n\t\t// Testing for AveragableValue::Float32 and AveragableValue::Float64\n\t\tlet mut value1 = AveragableValue::Float32(10.5);\n\t\tvalue1 += AveragableValue::Float32(12.5);\n\t\tassert_eq!(value1, AveragableValue::Float32(23.));\n\t\tvalue1 -= AveragableValue::Float32(12.5);\n\t\tassert_eq!(value1, AveragableValue::Float32(10.5));\n\n\t\tlet mut value1 = AveragableValue::Float64(10.5);\n\t\tvalue1 += AveragableValue::Float64(12.5);\n\t\tassert_eq!(value1, AveragableValue::Float64(23.));\n\t\tvalue1 -= AveragableValue::Float64(12.5);\n\t\tassert_eq!(value1, AveragableValue::Float64(10.5));\n\n\t\t// Testing for AveragableValue::Vec2 and AveragableValue::Vec2d\n\t\tlet mut value1 = AveragableValue::Vec2((10.5, 10.5));\n\t\tvalue1 += AveragableValue::Vec2((12.5, 12.5));\n\t\tassert_eq!(value1, AveragableValue::Vec2((23., 23.)));\n\t\tvalue1 -= AveragableValue::Vec2((12.5, 12.5));\n\t\tassert_eq!(value1, AveragableValue::Vec2((10.5, 10.5)));\n\n\t\tlet mut value1 = AveragableValue::Vec2d((10.5, 10.5));\n\t\tvalue1 += AveragableValue::Vec2d((12.5, 12.5));\n\t\tassert_eq!(value1, AveragableValue::Vec2d((23., 23.)));\n\t\tvalue1 -= AveragableValue::Vec2d((12.5, 12.5));\n\t\tassert_eq!(value1, AveragableValue::Vec2d((10.5, 10.5)));\n\n\t\t// Testing for AveragableValue::Vec3 and AveragableValue::Vec3d\n\t\tlet mut value1 = AveragableValue::Vec3((10.5, 10.5, 10.5));\n\t\tvalue1 += AveragableValue::Vec3((12.5, 12.5, 12.5));\n\t\tassert_eq!(value1, AveragableValue::Vec3((23., 23., 23.)));\n\t\tvalue1 -= AveragableValue::Vec3((12.5, 12.5, 12.5));\n\t\tassert_eq!(value1, AveragableValue::Vec3((10.5, 10.5, 10.5)));\n\n\t\tlet mut value1 = AveragableValue::Vec3d((10.5, 10.5, 10.5));\n\t\tvalue1 += AveragableValue::Vec3d((12.5, 12.5, 12.5));\n\t\tassert_eq!(value1, AveragableValue::Vec3d((23., 23., 23.)));\n\t\tvalue1 -= AveragableValue::Vec3d((12.5, 12.5, 12.5));\n\t\tassert_eq!(value1, AveragableValue::Vec3d((10.5, 10.5, 10.5)));\n\n\t\t// Testing for AveragableValue::Vec4 and AveragableValue::Vec4d\n\t\tlet mut value1 = AveragableValue::Vec4((10.5, 10.5, 10.5, 10.5));\n\t\tvalue1 += AveragableValue::Vec4((12.5, 12.5, 12.5, 12.5));\n\t\tassert_eq!(value1, AveragableValue::Vec4((23., 23., 23., 23.)));\n\t\tvalue1 -= AveragableValue::Vec4((12.5, 12.5, 12.5, 12.5));\n\t\tassert_eq!(value1, AveragableValue::Vec4((10.5, 10.5, 10.5, 23.)));\n\n\t\tlet mut value1 = AveragableValue::Vec4d((10.5, 10.5, 10.5, 10.5));\n\t\tvalue1 += AveragableValue::Vec4d((12.5, 12.5, 12.5, 12.5));\n\t\tassert_eq!(value1, AveragableValue::Vec4d((23., 23., 23., 23.)));\n\t\tvalue1 -= AveragableValue::Vec4d((12.5, 12.5, 12.5, 12.5));\n\t\tassert_eq!(value1, AveragableValue::Vec4d((10.5, 10.5, 10.5, 23.)));\n\t}\n}\n","traces":[{"line":47,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":2580},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":2560},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":2580},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":5102},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":2542},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":165232},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":59},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":457,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":505,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":506,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":509,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":519,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":523,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":527,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":533,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":556,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":557,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":559,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":562,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":563,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":565,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":566,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":568,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":570,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":572,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":573,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":575,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":576,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":581,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":582,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":584,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":585,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":587,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":588,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":589,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":590,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":592,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":593,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":594,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":595,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":596,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":598,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":599,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":601,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":602,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":603,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":604,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":606,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":607,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":608,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":609,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":610,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":235,"coverable":290},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","objects","mod.rs"],"content":"//! Objects Authortiy System\n//!\n//! The objects module is responsible for managing the authority and state of\n//! all objects in the simulation. Objects are entities that are not centroids\n//! of simulation and their values always originate in some form from a player\n//! session.\n//!\n//! This module implements the authority system for objects, which is\n//! responsible for deciding which updates to objects are allowed and which need\n//! to be interpolated, average, rejected, or otherwise modified.\n\nuse {\n\tself::{average::Average, mode::BlendMode, owner::OwnerOnly, select::Select},\n\tcrate::{\n\t\tglobal::GlobalState,\n\t\tschema::{Blend, GetByKey, Lifetime, Ownership, Spec},\n\t\tsession::{command::Command, Session},\n\t\tstate::{\n\t\t\tcurrent_timestamp,\n\t\t\tentity::{AttributeChange, EntityChanges},\n\t\t\tobject::{is_id_derived, is_id_shared, ObjectEntity, ObjectId},\n\t\t\tplayer::PlayerId,\n\t\t\trules,\n\t\t\tDespawnedEntity,\n\t\t\tEntityId,\n\t\t\tTimestampedVal,\n\t\t},\n\t},\n\tdashmap::{\n\t\titer::Iter,\n\t\tmapref::{entry::Entry, one::Ref},\n\t\tDashMap,\n\t},\n\tfxhash::FxBuildHasher,\n\tquark_client_sdk::{\n\t\tprotocol::common::object,\n\t\tAttributeId,\n\t\tValue,\n\t\tWellKnownAttribute,\n\t},\n\tsmallvec::SmallVec,\n\tstd::sync::Arc,\n\tthiserror::Error,\n\ttracing::trace,\n};\n\nmod average;\nmod mode;\nmod owner;\nmod select;\nmod sudo;\n\npub use average::{\n\tAverageMethod,\n\tAverageParams,\n\tMAX_CAPACITY as AVERAGING_MAX_CAPACITY,\n};\n\n#[derive(Debug, Error)]\npub enum Error {\n\t#[error(\"Invalid spawned object id {1} for player {0}\")]\n\tInvalidObjectId(PlayerId, ObjectId),\n\n\t#[error(\"Invalid incoming data: {0}\")]\n\tInvalidData(#[from] capnp::Error),\n\n\t#[error(\"Error while accessing entity: {0}\")]\n\tEntity(#[from] crate::state::entity::Error),\n}\n\npub struct ObjectsState {\n\tsystems: [Box\u003cdyn BlendMode\u003e; 3],\n\tobjects: DashMap\u003cObjectId, ObjectEntity, FxBuildHasher\u003e,\n}\n\nconst SELECT_SYSTEM: usize = 0;\nconst OWNER_SYSTEM: usize = 1;\nconst AVERAGE_SYSTEM: usize = 2;\n\n#[allow(clippy::derivable_impls)]\nimpl Default for ObjectsState {\n\tfn default() -\u003e Self {\n\t\tSelf {\n\t\t\tsystems: [\n\t\t\t\tBox::\u003cSelect\u003e::default(),\n\t\t\t\tBox::\u003cOwnerOnly\u003e::default(),\n\t\t\t\tBox::\u003cAverage\u003e::default(),\n\t\t\t],\n\t\t\tobjects: DashMap::default(),\n\t\t}\n\t}\n}\n\nimpl ObjectsState {\n\t#[inline(always)]\n\tpub fn len(\u0026self) -\u003e usize {\n\t\tself.objects.len()\n\t}\n\n\t#[inline(always)]\n\tpub fn get(\n\t\t\u0026self,\n\t\tobject_id: \u0026ObjectId,\n\t) -\u003e Option\u003cRef\u003c'_, ObjectId, ObjectEntity, FxBuildHasher\u003e\u003e {\n\t\tself.objects.get(object_id)\n\t}\n\n\t#[inline(always)]\n\tpub fn contains_key(\u0026self, object_id: \u0026ObjectId) -\u003e bool {\n\t\tself.objects.contains_key(object_id)\n\t}\n\n\t#[inline(always)]\n\tpub fn entry(\n\t\t\u0026self,\n\t\tobject_id: ObjectId,\n\t) -\u003e Entry\u003c'_, ObjectId, ObjectEntity, FxBuildHasher\u003e {\n\t\tself.objects.entry(object_id)\n\t}\n\n\t#[inline(always)]\n\tpub fn iter(\u0026self) -\u003e Iter\u003c'_, ObjectId, ObjectEntity, FxBuildHasher\u003e {\n\t\tself.objects.iter()\n\t}\n\n\t/// Handles an update request by a player session. This may result in\n\t/// modification to existing objects, or the creation of new objects. The\n\t/// authority system is responsible for determining if the update should be\n\t/// applied, and what changes should be made.\n\tpub fn upsert(\n\t\t\u0026self,\n\t\tby: \u0026Session,\n\t\treader: object::Reader\u003c'_\u003e,\n\t) -\u003e Result\u003cEntityChanges, Error\u003e {\n\t\tlet object_id = reader.get_id();\n\n\t\t// we're not using the .entry() api here to avoid taking a write lock\n\t\t// on the dashmap shard for the entire duration of the upsert operation.\n\n\t\t// more likely case, the object exists, don't force dashmap to\n\t\t// take a lock on reads:\n\t\tif let Some(existing) = self.objects.get(\u0026object_id) {\n\t\t\tself.update_existing_object(by, \u0026existing, reader)\n\t\t} else {\n\t\t\t// less likely case, the object does not exist, so we need to\n\t\t\t// take a lock on the dashmap to insert the object.\n\t\t\tlet (object, changes) = self.spawn_new_object(by, reader)?;\n\t\t\tself.objects.insert(object_id, object);\n\t\t\tOk(changes)\n\t\t}\n\t}\n\n\t/// This is called when a player wants to despawn an object.\n\t/// It is not guaranteed that the object will be despawned, as the authority\n\t/// system may prevent it.\n\tpub fn despawn(\u0026self, by: \u0026Session, object_id: ObjectId) {\n\t\tlet can_despawn = {\n\t\t\tlet Some(object) = self.objects.get(\u0026object_id) else {\n\t\t\t\treturn; // object does not exist\n\t\t\t};\n\n\t\t\t// get the spec of the object to determine the authority system that\n\t\t\t// governs it.\n\t\t\tlet spec = by.global.schema().spec_of(object.value());\n\n\t\t\tmatch spec.blend() {\n\t\t\t\tBlend::Owner =\u003e {\n\t\t\t\t\tself.systems[OWNER_SYSTEM].can_despawn(by, object.value())\n\t\t\t\t}\n\t\t\t\tBlend::Select =\u003e {\n\t\t\t\t\tself.systems[SELECT_SYSTEM].can_despawn(by, object.value())\n\t\t\t\t}\n\t\t\t\tBlend::Average { .. } =\u003e {\n\t\t\t\t\tself.systems[AVERAGE_SYSTEM].can_despawn(by, object.value())\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tif can_despawn {\n\t\t\tself.system_despawn(object_id, \u0026by.global);\n\t\t}\n\t}\n\n\t/// This is called when an object is despawned by the system (e.g. due to\n\t/// lifetime timeout or through replication). And not by a player.\n\t///\n\t/// This bypases the authority mechanism and will always kill the object.\n\tpub fn system_despawn(\u0026self, object_id: ObjectId, global: \u0026Arc\u003cGlobalState\u003e) {\n\t\tif self.objects.remove(\u0026object_id).is_none() {\n\t\t\treturn; // object does not exist\n\t\t};\n\n\t\t// inform the authority system that is managing this object\n\t\t// that it has been despawned.\n\t\tfor system in \u0026self.systems {\n\t\t\tsystem.despawned(object_id);\n\t\t}\n\n\t\tlet global = Arc::clone(global);\n\n\t\ttokio::spawn(async move {\n\t\t\t// remove the object from the ownership graph\n\t\t\tglobal.graph().object_despawned(object_id);\n\n\t\t\t// replicate to all other nodes that the object\n\t\t\t// was despawned\n\t\t\tglobal\n\t\t\t\t.replicate()\n\t\t\t\t.despawn(DespawnedEntity::Object(object_id));\n\n\t\t\t// Inform all players that are aware of the despawned object that it\n\t\t\t// has been despawned.\n\t\t\tlet aware_players = global\n\t\t\t\t.interests()\n\t\t\t\t.take_players_aware_of_object(object_id)\n\t\t\t\t.unwrap_or_default();\n\n\t\t\tfor player in aware_players {\n\t\t\t\tglobal\n\t\t\t\t\t.commands()\n\t\t\t\t\t.send_to(\u0026player, Command::DespawnObject(object_id));\n\t\t\t}\n\n\t\t\t// recursively despawn all its children that have lifetimes bound to it\n\t\t\tlet children = global.graph().children_of(EntityId::Object(object_id));\n\t\t\tfor child in children {\n\t\t\t\tlet is_lifetime_bound = global\n\t\t\t\t\t.objects()\n\t\t\t\t\t.get(\u0026child)\n\t\t\t\t\t.map(|object| {\n\t\t\t\t\t\t*global.schema().spec_of(object.value()).lifetime()\n\t\t\t\t\t\t\t== Lifetime::Owner\n\t\t\t\t\t})\n\t\t\t\t\t.unwrap_or(false);\n\n\t\t\t\tif is_lifetime_bound {\n\t\t\t\t\tglobal.objects().system_despawn(child, \u0026global);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// remove the object from the ownership graph\n\t\t\tglobal.graph().object_despawned(object_id);\n\n\t\t\ttrace!(\n\t\t\t\t\"object {object_id} has been despawned, removing it from the global \\\n\t\t\t\t state\",\n\t\t\t);\n\t\t});\n\t}\n\n\t/// Applies the updates to an object, based on the authority system that\n\t/// governs the object. The final value of the attributes is decided by the\n\t/// authority system that governs individual attributes.\n\t///\n\t/// This is called after individual attributes have been categorized\n\t/// into different authority systems. It takes the categorized keys\n\t/// and calls each authority system to apply the updates to the object\n\t/// for a subset of the keys and returns a combined set of all entity changes\n\t/// that were made.\n\tfn apply_updates(\n\t\t\u0026self,\n\t\tby: \u0026Session,\n\t\tobject: \u0026ObjectEntity,\n\t\tkeys_by_authority_type: AuthorityCategories,\n\t\treader: object::Reader\u003c'_\u003e,\n\t) -\u003e EntityChanges {\n\t\tlet mut changes = EntityChanges::default();\n\t\tlet mut apply_for = |system: \u0026dyn BlendMode, keys: \u0026[AttributeId]| {\n\t\t\tif !keys.is_empty() {\n\t\t\t\tchanges.attributes.extend(\n\t\t\t\t\tapply_system_changes(by, object, keys, reader, system).attributes,\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\n\t\tapply_for(\n\t\t\tself.systems[OWNER_SYSTEM].as_ref(),\n\t\t\t\u0026keys_by_authority_type.owner,\n\t\t);\n\n\t\tapply_for(\n\t\t\tself.systems[AVERAGE_SYSTEM].as_ref(),\n\t\t\t\u0026keys_by_authority_type.average,\n\t\t);\n\n\t\tapply_for(\n\t\t\tself.systems[SELECT_SYSTEM].as_ref(),\n\t\t\t\u0026keys_by_authority_type.select,\n\t\t);\n\n\t\trules::apply_post_update_rules(\u0026by.public_id, object, \u0026changes, \u0026by.global);\n\n\t\tchanges\n\t}\n\n\tfn update_existing_object(\n\t\t\u0026self,\n\t\tby: \u0026Session,\n\t\tobject: \u0026ObjectEntity,\n\t\treader: object::Reader\u003c'_\u003e,\n\t) -\u003e Result\u003cEntityChanges, Error\u003e {\n\t\t// existing object so it already has specification. Use it to\n\t\t// categorize the attributes by authority algorithm that governs\n\t\t// their writes.\n\t\tlet spec = by.global.schema().spec_of(object);\n\n\t\t// categorize the attributes by authority algorithm that governs their\n\t\t// writes and then apply the updates to the object. The categorization\n\t\t// process will also implicitly skip any attributes that violate the\n\t\t// schema rules.\n\t\tlet changes = self.apply_updates(\n\t\t\tby,\n\t\t\tobject,\n\t\t\tcategorize_attributes(by, object, spec, reader),\n\t\t\treader,\n\t\t);\n\n\t\t// Apply any object model rules that might have changed as a result of\n\t\t// this update.\n\t\trules::apply_post_update_rules(\u0026by.public_id, object, \u0026changes, \u0026by.global);\n\n\t\tOk(changes)\n\t}\n\n\t/// This is called when we get an update about an object with an ID not seen\n\t/// before. It will create a new object and apply the updates to it and\n\t/// initialize the whole object lifecycle.\n\tfn spawn_new_object(\n\t\t\u0026self,\n\t\tby: \u0026Session,\n\t\treader: object::Reader\u003c'_\u003e,\n\t) -\u003e Result\u003c(ObjectEntity, EntityChanges), Error\u003e {\n\t\tlet object_id = reader.get_id();\n\n\t\t// Shared objects are objects that are part of the level map and exist\n\t\t// offline on all clients statically. Clients can create their Quark\n\t\t// representation if they want to override the baked-in object.\n\t\t// For example we could have a tree object in the level map, but a\n\t\t// a player cuts that tree in half, so they create a new object with\n\t\t// the same ID and override the tree object attributes.\n\t\tlet mut is_shared_object = false;\n\n\t\t// first ensure that is is named correctly to avoid id collisions\n\t\tif !is_id_derived(object_id, by.public_id) {\n\t\t\tif is_id_shared(object_id) {\n\t\t\t\tis_shared_object = true;\n\t\t\t} else {\n\t\t\t\ttrace!(\n\t\t\t\t\t\"Player {} tried to spawn an object with an invalid id {object_id} \\\n\t\t\t\t\t (not derived from player id)\",\n\t\t\t\t\tby.public_id\n\t\t\t\t);\n\t\t\t\treturn Err(Error::InvalidObjectId(by.public_id, object_id));\n\t\t\t}\n\t\t}\n\n\t\tlet new_object = ObjectEntity::new(EntityId::Object(object_id));\n\t\tby.global\n\t\t\t.replicate()\n\t\t\t.spawn(EntityId::Object(object_id), \u0026new_object);\n\n\t\tlet mut changes = EntityChanges::default();\n\n\t\t// the class id must always be set for an object in the first\n\t\t// update, otherwise it will be set to the default class id\n\t\t// and cannot be changed later.\n\t\tlet class_id_timestamped =\n\t\t\tget_timestamped_value(WellKnownAttribute::ClassId as AttributeId, reader);\n\t\tlet class_id_timestamp = class_id_timestamped.as_ref().map(|v| v.1);\n\t\tif let Some(TimestampedVal(class_id, timestamp)) = class_id_timestamped {\n\t\t\tchanges.attributes.insert(\n\t\t\t\tWellKnownAttribute::ClassId as AttributeId,\n\t\t\t\tnew_object.attributes().try_set(\n\t\t\t\t\tWellKnownAttribute::ClassId as AttributeId,\n\t\t\t\t\tclass_id,\n\t\t\t\t\ttimestamp,\n\t\t\t\t)?,\n\t\t\t);\n\t\t}\n\n\t\t// Get the spec of the object to determine the authority\n\t\t// system and other behaviours that govern it.\n\t\tlet spec = by.global.schema().spec_of(\u0026new_object);\n\n\t\t// this is a new object, for new objects that have\n\t\t// ownership set to creator, we need to set the owner\n\t\t// before applying any other updates so that ownership\n\t\t// relevance and checks evaluate correctly.\n\t\t// For timestamp we take one from ClassId attribute, if it is not present\n\t\t// than current server's timestamp\n\t\tif !is_shared_object \u0026\u0026 *spec.ownership() == Ownership::Creator {\n\t\t\tlet TimestampedVal(initial_owner, timestamp) = get_timestamped_value(\n\t\t\t\tWellKnownAttribute::OwnerId as AttributeId,\n\t\t\t\treader,\n\t\t\t)\n\t\t\t.unwrap_or_else(|| {\n\t\t\t\t(\n\t\t\t\t\tValue::Uint32(by.public_id),\n\t\t\t\t\tclass_id_timestamp.unwrap_or_else(current_timestamp),\n\t\t\t\t)\n\t\t\t\t\t.into()\n\t\t\t});\n\n\t\t\tchanges.attributes.insert(\n\t\t\t\tWellKnownAttribute::OwnerId as AttributeId,\n\t\t\t\tnew_object.attributes().try_set(\n\t\t\t\t\tWellKnownAttribute::OwnerId as AttributeId,\n\t\t\t\t\tinitial_owner,\n\t\t\t\t\ttimestamp,\n\t\t\t\t)?,\n\t\t\t);\n\t\t}\n\n\t\t// if the object was created with an owner, index it\n\t\tif new_object\n\t\t\t.attributes()\n\t\t\t.contains_key(WellKnownAttribute::OwnerId as AttributeId)\n\t\t{\n\t\t\tby.global\n\t\t\t\t.graph()\n\t\t\t\t.owner_changed(object_id, EntityId::Player(by.public_id));\n\t\t}\n\n\t\tlet keys = categorize_attributes(by, \u0026new_object, spec, reader);\n\n\t\t// apply the updates as sudo, as the object is being created\n\t\t// and in the first write we're allowing everything as the\n\t\t// object is being constructed with initial state\n\n\t\tlet sudo = sudo::System::default();\n\t\tchanges.attributes.extend(\n\t\t\tapply_system_changes(by, \u0026new_object, \u0026keys.owner, reader, \u0026sudo)\n\t\t\t\t.attributes,\n\t\t);\n\t\tchanges.attributes.extend(\n\t\t\tapply_system_changes(by, \u0026new_object, \u0026keys.select, reader, \u0026sudo)\n\t\t\t\t.attributes,\n\t\t);\n\t\tchanges.attributes.extend(\n\t\t\tapply_system_changes(by, \u0026new_object, \u0026keys.average, reader, \u0026sudo)\n\t\t\t\t.attributes,\n\t\t);\n\n\t\t// Apply any object model rules that might have\n\t\t// changed as a result of this update.\n\t\trules::apply_post_update_rules(\n\t\t\t\u0026by.public_id,\n\t\t\t\u0026new_object,\n\t\t\t\u0026changes,\n\t\t\t\u0026by.global,\n\t\t);\n\n\t\t// let all authority systems know about the new object\n\t\tfor system in \u0026self.systems {\n\t\t\tsystem.spawned(by, \u0026new_object);\n\t\t}\n\n\t\t// Track that the player is aware of the object,\n\t\t// so it gets notified if the object despawns.\n\t\tby.global\n\t\t\t.interests()\n\t\t\t.mark_awareness(by.public_id, \u0026[EntityId::Object(object_id)]);\n\n\t\tOk((new_object, changes))\n\t}\n}\n\nfn apply_system_changes(\n\tby: \u0026Session,\n\tobject: \u0026ObjectEntity,\n\tkeys: \u0026[AttributeId],\n\treader: object::Reader\u003c'_\u003e,\n\tsystem: \u0026dyn BlendMode,\n) -\u003e EntityChanges {\n\tlet new_values = system.update(by, object, keys, reader);\n\tassert_eq!(new_values.len(), keys.len());\n\n\tlet mut changes = EntityChanges::default();\n\tfor (key, new_value) in keys.iter().zip(new_values) {\n\t\tif let Some(TimestampedVal(new_value, timestamp)) = new_value {\n\t\t\tlet Ok((updated, new)) = object\n\t\t\t\t.attributes()\n\t\t\t\t.access(*key, |attr| attr.set(new_value, timestamp))\n\t\t\telse {\n\t\t\t\tcontinue;\n\t\t\t};\n\n\t\t\tchanges.attributes.insert(\n\t\t\t\t*key,\n\t\t\t\tif new {\n\t\t\t\t\tAttributeChange::Created(timestamp)\n\t\t\t\t} else if updated {\n\t\t\t\t\tAttributeChange::Updated(timestamp)\n\t\t\t\t} else {\n\t\t\t\t\tAttributeChange::None\n\t\t\t\t},\n\t\t\t);\n\t\t}\n\t}\n\n\tchanges\n}\n\n#[derive(Debug, Default)]\nstruct AuthorityCategories {\n\towner: SmallVec\u003c[AttributeId; 16]\u003e,\n\taverage: SmallVec\u003c[AttributeId; 16]\u003e,\n\tselect: SmallVec\u003c[AttributeId; 16]\u003e,\n}\n\n/// This function has the responsibility of chosing which authority system is\n/// responsible for determining the final value of an attribute. It does this by\n/// categorizing the attributes into three categories: owner, aggregate, and\n/// default.\n///\n/// Also implicitly skips any attributes that violate the schema rules by not\n/// including them in the returned categories.\nfn categorize_attributes(\n\t_by: \u0026Session,\n\tobject: \u0026ObjectEntity,\n\tspec: \u0026Spec,\n\treader: object::Reader\u003c'_\u003e,\n) -\u003e AuthorityCategories {\n\tlet Ok(attributes) = reader.get_attributes() else {\n\t\treturn AuthorityCategories::default();\n\t};\n\n\tlet mut categories = AuthorityCategories::default();\n\n\t// in this loop we go over all incoming attributes and categorize them\n\t// into authority categories or drop them alltogether if they violate the\n\t// schema rules.\n\tfor attrib in attributes {\n\t\tlet key = attrib.get_key();\n\n\t\tif key == 0 {\n\t\t\tcontinue; // invalid attribute key\n\t\t}\n\n\t\tif key == WellKnownAttribute::ClassId as AttributeId\n\t\t\t\u0026\u0026 object.class_id().is_some()\n\t\t{\n\t\t\t// class id can be set only once\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet Ok(value) = Value::from_capnp_reader(\u0026attrib.get_value()) else {\n\t\t\tcontinue;\n\t\t};\n\n\t\tif object\n\t\t\t.attributes()\n\t\t\t.try_access(key, |v| v.get() == value)\n\t\t\t.unwrap_or_default()\n\t\t{\n\t\t\tcontinue; // no change in value\n\t\t}\n\t\t// we're setting the owner of the object\n\t\t// this can be set only if: 1) the object does not have an owner yet\n\t\t// or 2) the object is owned by the player that is trying to set the owner\n\t\telse if key == WellKnownAttribute::OwnerId as AttributeId {\n\t\t\tif !value.typeid().is_integer() \u0026\u0026 !value.typeid().is_none() {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// already has an owner, then owner-authority applies.\n\t\t\tif object.attributes().contains_key(key) {\n\t\t\t\tcategories.owner.push(key);\n\t\t\t} else {\n\t\t\t\tcategories.select.push(key);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif let Some(attrib_spec) = spec.attributes().get_by_key(\u0026key) {\n\t\t\t// attribute type does not match schema type, drop\n\t\t\tif let Some(ty) = attrib_spec.r#type {\n\t\t\t\tif value.typeid() != ty {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmatch attrib_spec.blend {\n\t\t\t\tBlend::Owner =\u003e {\n\t\t\t\t\tcategories.owner.push(key);\n\t\t\t\t}\n\t\t\t\tBlend::Average { .. } =\u003e {\n\t\t\t\t\tcategories.average.push(key);\n\t\t\t\t}\n\t\t\t\tBlend::Select =\u003e {\n\t\t\t\t\tcategories.select.push(key);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// attribute not defined in the schema\n\n\t\t\t// if the object is strict, then drop the attribute\n\t\t\tif spec.strict() {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tmatch spec.blend() {\n\t\t\t\t\tBlend::Owner =\u003e {\n\t\t\t\t\t\tcategories.owner.push(key);\n\t\t\t\t\t}\n\t\t\t\t\tBlend::Average { .. } =\u003e match value.typeid().is_interpolable() {\n\t\t\t\t\t\ttrue =\u003e categories.average.push(key),\n\t\t\t\t\t\tfalse =\u003e categories.select.push(key),\n\t\t\t\t\t},\n\t\t\t\t\tBlend::Select =\u003e {\n\t\t\t\t\t\tcategories.select.push(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcategories\n}\n\nfn get_timestamped_value(\n\tkey: AttributeId,\n\treader: object::Reader\u003c'_\u003e,\n) -\u003e Option\u003cTimestampedVal\u003e {\n\tfor attrib in reader.get_attributes().ok()?.iter() {\n\t\tif attrib.get_key() == key {\n\t\t\treturn TimestampedVal::from_capnp_reader(\u0026attrib).ok();\n\t\t}\n\t}\n\tNone\n}\n","traces":[{"line":82,"address":[],"length":0,"stats":{"Line":122},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":122},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":122},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":1327},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":1327},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":804},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":804},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":972},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":1272},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":150},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":672},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":669},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":165},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":165},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":636},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":636},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":636},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":636},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":652},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":1265},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":628},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":628},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":1245},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":617},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":617},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":617},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":628},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":628},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":6330},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":1899},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":2064},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":2064},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":2064},"fn_name":null},{"line":478,"address":[],"length":0,"stats":{"Line":2064},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":7338},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":10545},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":5271},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":5271},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":5271},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":5271},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":5271},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":5260},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":493,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":495,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":2064},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":801},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":1602},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[],"length":0,"stats":{"Line":11419},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":5309},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":547,"address":[],"length":0,"stats":{"Line":5288},"fn_name":null},{"line":548,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":553,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":556,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":5276},"fn_name":null},{"line":562,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":563,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":568,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":570,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":572,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":575,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":577,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":583,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":584,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":585,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":587,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":588,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":590,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":591,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":598,"address":[],"length":0,"stats":{"Line":5269},"fn_name":null},{"line":599,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":601,"address":[],"length":0,"stats":{"Line":5268},"fn_name":null},{"line":602,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":603,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":605,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":606,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":607,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":609,"address":[],"length":0,"stats":{"Line":5262},"fn_name":null},{"line":610,"address":[],"length":0,"stats":{"Line":5262},"fn_name":null},{"line":617,"address":[],"length":0,"stats":{"Line":801},"fn_name":null},{"line":620,"address":[],"length":0,"stats":{"Line":1261},"fn_name":null},{"line":624,"address":[],"length":0,"stats":{"Line":11683},"fn_name":null},{"line":625,"address":[],"length":0,"stats":{"Line":9161},"fn_name":null},{"line":626,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":629,"address":[],"length":0,"stats":{"Line":1231},"fn_name":null}],"covered":172,"coverable":193},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","objects","mode.rs"],"content":"use {\n\tcrate::{\n\t\tsession::Session,\n\t\tstate::{\n\t\t\tentity::AttributeId,\n\t\t\tobject::{ObjectEntity, ObjectId},\n\t\t\tTimestampedVal,\n\t\t},\n\t},\n\tquark_client_sdk::protocol::common::object,\n};\n\n/// The blending mode is responsible for deciding about the final values of\n/// attributes in objects with competing simulations from multiplie clients\npub trait BlendMode: Send + Sync {\n\t/// Informs the authority that an object has been spawned.\n\t/// This starts the lifecycle of an object and it will be updated until\n\t/// despawned.\n\tfn spawned(\u0026self, _by: \u0026Session, _object: \u0026ObjectEntity) {}\n\n\t/// Informs the authority that an object has been despawned.\n\t/// This ends the lifecycle of an object and it will no longer be updated\n\t/// until respawned.\n\tfn despawned(\u0026self, _object: ObjectId) {}\n\n\t/// Delegates updating the object values to the authority.\n\t/// The authority can decide about the new values applied to the object\n\t/// attributes with keys `keys`.\n\t///\n\t/// The returned vector contains the new values for the attributes in the\n\t/// same order as the keys. None means that the attribute should not be\n\t/// modified.\n\tfn update(\n\t\t\u0026self,\n\t\tby: \u0026Session,\n\t\tobject: \u0026ObjectEntity,\n\t\tkeys: \u0026[AttributeId],\n\t\treader: object::Reader\u003c'_\u003e,\n\t) -\u003e Vec\u003cOption\u003cTimestampedVal\u003e\u003e;\n\n\t/// Checks with the authority if an object can be despawned by a given player\n\t/// session.\n\tfn can_despawn(\u0026self, by: \u0026Session, object: \u0026ObjectEntity) -\u003e bool;\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":1266},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":15},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","objects","owner.rs"],"content":"use {\n\tsuper::mode::BlendMode,\n\tcrate::{\n\t\tsession::Session,\n\t\tstate::{\n\t\t\tentity::AttributeId,\n\t\t\tobject::ObjectEntity,\n\t\t\tEntityId,\n\t\t\tTimestampedVal,\n\t\t},\n\t},\n\tquark_client_sdk::protocol::common::object,\n\ttracing::trace,\n};\n\n/// This authority system permits only the owner of an object to update it.\n#[derive(Default)]\npub struct OwnerOnly {}\n\nimpl BlendMode for OwnerOnly {\n\tfn update(\n\t\t\u0026self,\n\t\tby: \u0026Session,\n\t\tobject: \u0026ObjectEntity,\n\t\tkeys: \u0026[AttributeId],\n\t\treader: object::Reader\u003c'_\u003e,\n\t) -\u003e Vec\u003cOption\u003cTimestampedVal\u003e\u003e {\n\t\t// represents no changes to all attributes\n\t\t// in the same order as the keys\n\t\tlet no_changes = || vec![None; keys.len()];\n\n\t\tlet EntityId::Object(object_id) = *object.id() else {\n\t\t\t// this is not an object entity\n\t\t\treturn no_changes();\n\t\t};\n\n\t\tif let Some(current_owner) = by.global.graph().root_owner_of(object_id) {\n\t\t\tif current_owner == EntityId::Player(by.public_id) {\n\t\t\t\tlet mut new_values = Vec::with_capacity(keys.len());\n\n\t\t\t\tlet Ok(attrib_reader) = reader.get_attributes() else {\n\t\t\t\t\treturn no_changes();\n\t\t\t\t};\n\n\t\t\t\tfor attribute_id in keys {\n\t\t\t\t\tnew_values.push(\n\t\t\t\t\t\tattrib_reader\n\t\t\t\t\t\t\t.iter()\n\t\t\t\t\t\t\t.find(|attrib| attrib.get_key() == *attribute_id)\n\t\t\t\t\t\t\t.and_then(|attrib| {\n\t\t\t\t\t\t\t\tTimestampedVal::from_capnp_reader(\u0026attrib).ok()\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn new_values;\n\t\t\t}\n\t\t}\n\n\t\ttrace!(\n\t\t\t\"Player {} update object {object_id} rejected: must be owner\",\n\t\t\tby.public_id,\n\t\t);\n\n\t\tno_changes()\n\t}\n\n\tfn can_despawn(\u0026self, by: \u0026Session, object: \u0026ObjectEntity) -\u003e bool {\n\t\tlet EntityId::Object(object_id) = *object.id() else {\n\t\t\treturn false; // this is not an object entity\n\t\t};\n\n\t\tif let Some(current_owner) = by.global.graph().root_owner_of(object_id) {\n\t\t\tcurrent_owner == EntityId::Player(by.public_id)\n\t\t} else {\n\t\t\tfalse\n\t\t}\n\t}\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":21,"coverable":25},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","objects","select.rs"],"content":"use {\n\tsuper::mode::BlendMode,\n\tcrate::{\n\t\trelevance::Relevance,\n\t\tsession::Session,\n\t\tstate::{\n\t\t\tentity::AttributeId,\n\t\t\tobject::{ObjectEntity, ObjectId},\n\t\t\tplayer::PlayerId,\n\t\t\tEntityId,\n\t\t\tTimestampedVal,\n\t\t},\n\t},\n\tdashmap::DashMap,\n\tfxhash::FxBuildHasher,\n\tquark_client_sdk::protocol::common::object,\n\tstd::time::Instant,\n\ttracing::trace,\n};\n\n#[derive(Default)]\npub struct Select {\n\tscores: DashMap\u003cObjectId, UpdateScore, FxBuildHasher\u003e,\n}\n\nimpl BlendMode for Select {\n\tfn spawned(\u0026self, by: \u0026Session, object: \u0026ObjectEntity) {\n\t\tlet EntityId::Object(object_id) = *object.id() else {\n\t\t\treturn; // this is not an object entity\n\t\t};\n\n\t\tself.scores.entry(object_id).or_insert_with(|| {\n\t\t\tlet this_relevance = by\n\t\t\t\t.global\n\t\t\t\t.indices()\n\t\t\t\t.relevance(by.player_obj().value(), object);\n\n\t\t\tUpdateScore {\n\t\t\t\ttime: Instant::now(),\n\t\t\t\tupdated_by: by.public_id,\n\t\t\t\trelevance: this_relevance,\n\t\t\t}\n\t\t});\n\t}\n\n\tfn despawned(\u0026self, object: ObjectId) {\n\t\tself.scores.remove(\u0026object);\n\t}\n\n\tfn update(\n\t\t\u0026self,\n\t\tby: \u0026Session,\n\t\tobject: \u0026ObjectEntity,\n\t\tkeys: \u0026[AttributeId],\n\t\treader: object::Reader\u003c'_\u003e,\n\t) -\u003e Vec\u003cOption\u003cTimestampedVal\u003e\u003e {\n\t\tlet nothing = || keys.iter().map(|_| None).collect::\u003cVec\u003c_\u003e\u003e();\n\n\t\tlet EntityId::Object(object_id) = *object.id() else {\n\t\t\treturn nothing(); // this is not an object entity\n\t\t};\n\n\t\tlet Ok(attributes) = reader.get_attributes() else {\n\t\t\treturn nothing(); // can't read attributes buffer\n\t\t};\n\n\t\tlet this_update_score = UpdateScore {\n\t\t\ttime: Instant::now(),\n\t\t\tupdated_by: by.public_id,\n\t\t\trelevance: by\n\t\t\t\t.global\n\t\t\t\t.indices()\n\t\t\t\t.relevance(by.player_obj().value(), object),\n\t\t};\n\n\t\tlet mut last_update_score = self\n\t\t\t.scores\n\t\t\t.entry(object_id)\n\t\t\t.or_insert(this_update_score.clone());\n\n\t\tif last_update_score.value() \u003c \u0026this_update_score {\n\t\t\ttrace!(\n\t\t\t\t\"Player {} is updating object {object_id} with relevance {}\",\n\t\t\t\tby.public_id,\n\t\t\t\tthis_update_score.relevance\n\t\t\t);\n\n\t\t\tlet mut output = Vec::with_capacity(keys.len());\n\t\t\t'outer: for key in keys {\n\t\t\t\tfor i in 0..attributes.len() {\n\t\t\t\t\tlet attr = attributes.get(i);\n\t\t\t\t\tif attr.get_key() == *key {\n\t\t\t\t\t\tlet Ok(value) = TimestampedVal::from_capnp_reader(\u0026attr) else {\n\t\t\t\t\t\t\toutput.push(None);\n\t\t\t\t\t\t\tcontinue 'outer;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\toutput.push(Some(value));\n\t\t\t\t\t\tcontinue 'outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// key given not in buffer\n\t\t\t\toutput.push(None);\n\t\t\t}\n\n\t\t\t// set the last update score to the current update score,\n\t\t\t// recalculate the relevancy value between the player that has\n\t\t\t// updated the object and the object itself after the attributes\n\t\t\t// changes were applied to the object.\n\t\t\t*last_update_score = UpdateScore {\n\t\t\t\ttime: Instant::now(),\n\t\t\t\tupdated_by: by.public_id,\n\t\t\t\trelevance: by\n\t\t\t\t\t.global\n\t\t\t\t\t.indices()\n\t\t\t\t\t.relevance(by.player_obj().value(), object),\n\t\t\t};\n\n\t\t\toutput\n\t\t} else {\n\t\t\tlet last_relevance = last_update_score.relevance;\n\t\t\ttrace!(\n\t\t\t\t\"Player {} update for object {object_id} with relevance {} is \\\n\t\t\t\t rejected (last relevance {last_relevance})\",\n\t\t\t\tby.public_id,\n\t\t\t\tthis_update_score.relevance\n\t\t\t);\n\t\t\t// the update is not allowed, return an empty changeset\n\t\t\tnothing()\n\t\t}\n\t}\n\n\tfn can_despawn(\u0026self, by: \u0026Session, object: \u0026ObjectEntity) -\u003e bool {\n\t\tlet EntityId::Object(object_id) = *object.id() else {\n\t\t\treturn false; // this is not an object entity\n\t\t};\n\n\t\tlet last_update_score = match self.scores.get(\u0026object_id) {\n\t\t\tSome(score) =\u003e score,\n\t\t\tNone =\u003e return true,\n\t\t};\n\n\t\tlet this_update_score = UpdateScore {\n\t\t\ttime: Instant::now(),\n\t\t\tupdated_by: by.public_id,\n\t\t\trelevance: by\n\t\t\t\t.global\n\t\t\t\t.indices()\n\t\t\t\t.relevance(by.player_obj().value(), object),\n\t\t};\n\n\t\tlast_update_score.value() \u003c \u0026this_update_score\n\t}\n}\n\n#[derive(Debug, Clone)]\nstruct UpdateScore {\n\ttime: Instant,\n\tupdated_by: PlayerId,\n\trelevance: Relevance,\n}\n\nimpl PartialEq for UpdateScore {\n\tfn eq(\u0026self, other: \u0026Self) -\u003e bool {\n\t\tself.partial_cmp(other) == Some(std::cmp::Ordering::Equal)\n\t}\n}\n\nimpl PartialOrd for UpdateScore {\n\tfn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cstd::cmp::Ordering\u003e {\n\t\tlet this_elapsed = self.time.elapsed().as_secs_f32();\n\n\t\t// the time decay is a value between 0.0 and 1.0 that represents\n\t\t// how much time has passed since the last update. The longer the\n\t\t// time since the last update, the less relevant it is.\n\n\t\tlet time_decay = (1.0 - this_elapsed).clamp(0.0, 1.0);\n\n\t\t// give priority boost to the player that wrote the last update\n\t\t// this is to ensure continuity of simulation by one writer when\n\t\t// other variables are not very different.\n\t\tlet continuity_score = match self.updated_by == other.updated_by {\n\t\t\ttrue =\u003e 1.0,\n\t\t\tfalse =\u003e 0.5,\n\t\t};\n\n\t\t// previous updates relevance decays over time\n\t\t// and current updates are prioritized over previous updates\n\t\t// if they have the same writer.\n\t\tlet this_score = time_decay * self.relevance.value();\n\t\tlet other_score = continuity_score * other.relevance.value();\n\n\t\tthis_score.partial_cmp(\u0026other_score)\n\t}\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":1266},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":633},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":160},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":163},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":320},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":160},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":159},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":159},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":1581},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":2588},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":2588},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":2588},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":1422},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":711},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":711},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":159},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":159},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":159},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":159},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":159},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":159},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":159},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":159},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":336},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":161},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":7},"fn_name":null}],"covered":51,"coverable":64},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","objects","sudo.rs"],"content":"use {\n\tsuper::mode::BlendMode,\n\tcrate::{\n\t\tsession::Session,\n\t\tstate::{entity::AttributeId, object::ObjectEntity, TimestampedVal},\n\t},\n\tquark_client_sdk::protocol::common::object,\n};\n\n/// This authority system writes all updates as is to the object.\n/// This authority system is not exposed to users of the system but is\n/// used internally in few places.\n#[derive(Default)]\npub struct System {}\n\nimpl BlendMode for System {\n\tfn update(\n\t\t\u0026self,\n\t\t_: \u0026Session,\n\t\t_: \u0026ObjectEntity,\n\t\tkeys: \u0026[AttributeId],\n\t\treader: object::Reader\u003c'_\u003e,\n\t) -\u003e Vec\u003cOption\u003cTimestampedVal\u003e\u003e {\n\t\tlet mut new_values = Vec::with_capacity(keys.len());\n\t\tlet Ok(attrib_reader) = reader.get_attributes() else {\n\t\t\treturn vec![None; keys.len()];\n\t\t};\n\n\t\tfor attribute_id in keys {\n\t\t\tnew_values.push(\n\t\t\t\tattrib_reader\n\t\t\t\t\t.iter()\n\t\t\t\t\t.find(|attrib| attrib.get_key() == *attribute_id)\n\t\t\t\t\t.and_then(|attrib| TimestampedVal::from_capnp_reader(\u0026attrib).ok()),\n\t\t\t);\n\t\t}\n\n\t\tnew_values\n\t}\n\n\tfn can_despawn(\u0026self, _: \u0026Session, _: \u0026ObjectEntity) -\u003e bool {\n\t\ttrue\n\t}\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":1899},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":1899},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":3798},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":15570},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":4557},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":4557},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":4557},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":32363},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":13671},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1899},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":10,"coverable":13},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","opts","mod.rs"],"content":"use {\n\tcrate::measure::{register_metrics, server},\n\tclap::{ArgAction, Parser, Subcommand, ValueEnum},\n\tmetrics_cloudwatch::Resolution,\n\tserde::{Deserialize, Serialize},\n\tstd::net::SocketAddr,\n\ttracing::Level,\n\ttracing_subscriber::{\n\t\tfilter::filter_fn,\n\t\tlayer::SubscriberExt,\n\t\tutil::SubscriberInitExt,\n\t\tLayer,\n\t},\n};\n\nmod proxy;\nmod server;\n\npub use {\n\tproxy::ProxyOptions,\n\tserver::{Profile, ServerOptions},\n};\n\n#[derive(Debug, Clone, Serialize, Deserialize, ValueEnum)]\npub enum Metrics {\n\tCloudwatch,\n\tPrometheus,\n}\n\n#[derive(Debug, Serialize, Deserialize, Subcommand)]\n#[allow(clippy::large_enum_variant)]\npub enum Mode {\n\tServer(ServerOptions),\n\tProxy(ProxyOptions),\n}\n\nimpl Default for Mode {\n\tfn default() -\u003e Self {\n\t\tSelf::Server(ServerOptions::default())\n\t}\n}\n\n#[derive(Debug, Serialize, Deserialize, Parser)]\n#[command(version, about, long_about = None)]\n#[command(propagate_version = true)]\npub struct Opts {\n\t#[command(subcommand)]\n\tpub mode: Option\u003cMode\u003e,\n\n\t/// Address for cluster discovery messages with other quark servers\n\t#[clap(long, env = \"QUARK_CONTROL\", default_value = \"0.0.0.0:5600\")]\n\tpub control_addr: SocketAddr,\n\n\t/// Address of any peer node in the cluster.\n\t/// Automatic discover of other nodes will happen through this peer(s).\n\t#[clap(long = \"peer\", env = \"QUARK_PEER\")]\n\tpub peers: Vec\u003cSocketAddr\u003e,\n\n\t#[clap(short, long, env = \"QUARK_METRICS\")]\n\tpub metrics: Option\u003cMetrics\u003e,\n\n\t#[clap(\n\t\tshort,\n\t\tlong,\n\t\tdefault_value = \"quark-unknown-server-metrics\",\n\t\tenv = \"QUARK_CLOUDWATCH_NAMESPACE\",\n\t\trequires = \"metrics\"\n\t)]\n\tpub cloudwatch_namespace: String,\n\n\t#[clap(\n\t\tshort,\n\t\tlong,\n\t\tenv = \"QUARK_PROMETHEUS_ADDRESS\",\n\t\tdefault_value = \"0.0.0.0:9898\",\n\t\trequires = \"metrics\"\n\t)]\n\tpub prometheus_addr: SocketAddr,\n\n\t#[clap(\n\t\tshort,\n\t\taction = ArgAction::Count,\n\t\tenv = \"QUARK_LOGGING\",\n\t\thelp = \"Use verbose output (-vv very verbose)\"\n\t)]\n\tpub verbose: u8,\n}\n\nimpl Opts {\n\tpub fn configure_logging(\u0026self) {\n\t\tlet loglevel = match self.verbose {\n\t\t\t1 =\u003e Level::DEBUG,\n\t\t\t2 =\u003e Level::TRACE,\n\t\t\t_ =\u003e Level::INFO,\n\t\t};\n\n\t\tlet prefix_blacklist =\n\t\t\t\u0026[\"netlink\", \"tokio_util\", \"aws\", \"rustls\", \"hyper\", \"mio\"];\n\n\t\ttracing_subscriber::registry()\n\t\t\t.with(tracing_subscriber::fmt::layer().with_filter(filter_fn(\n\t\t\t\tmove |metadata| {\n\t\t\t\t\t!prefix_blacklist\n\t\t\t\t\t\t.iter()\n\t\t\t\t\t\t.any(|prefix| metadata.target().starts_with(prefix))\n\t\t\t\t\t\t\u0026\u0026 metadata.level() \u003c= \u0026loglevel\n\t\t\t\t},\n\t\t\t)))\n\t\t\t.init();\n\t}\n\n\t/// Configure the metrics system.\n\t///\n\t/// If we are running in AWS or we have access to AWS credentials then\n\t/// we will configure the metrics system to send metrics to CloudWatch.\n\t///\n\t/// Otherwise no metrics are persisted.\n\tpub async fn configure_metrics(\u0026self) -\u003e anyhow::Result\u003c()\u003e {\n\t\tlet Some(ref driver) = self.metrics else {\n\t\t\treturn Ok(());\n\t\t};\n\n\t\tmatch driver {\n\t\t\tMetrics::Cloudwatch =\u003e {\n\t\t\t\tmetrics_cloudwatch::Builder::new()\n\t\t\t\t\t.await\n\t\t\t\t\t.send_interval_secs(5)\n\t\t\t\t\t.storage_resolution(Resolution::Second)\n\t\t\t\t\t.cloudwatch_namespace(self.cloudwatch_namespace.clone())\n\t\t\t\t\t.init_thread(metrics::set_boxed_recorder)?;\n\t\t\t}\n\t\t\tMetrics::Prometheus =\u003e {\n\t\t\t\tmetrics_prometheus::install();\n\t\t\t\tlet addr = self.prometheus_addr;\n\t\t\t\ttokio::spawn(async move {\n\t\t\t\t\tserver(addr).await;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tlet mut res = metrics::try_recorder();\n\t\tlet recorder: \u0026dyn metrics::Recorder;\n\n\t\t// Initialization of recorder might take some time.\n\t\tloop {\n\t\t\tif let Some(rec) = res {\n\t\t\t\trecorder = rec;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tres = metrics::try_recorder();\n\t\t}\n\n\t\tregister_metrics(recorder);\n\n\t\tOk(())\n\t}\n}\n\nimpl Default for Opts {\n\tfn default() -\u003e Self {\n\t\tSelf {\n\t\t\tmode: Some(Mode::Server(ServerOptions::default())),\n\t\t\tverbose: 0,\n\t\t\tpeers: Vec::new(),\n\t\t\tcloudwatch_namespace: \"quark-unknown-server-metrics\".into(),\n\t\t\tprometheus_addr: \"0.0.0.0:9898\".parse().unwrap(),\n\t\t\tcontrol_addr: \"0.0.0.0:5600\".parse().unwrap(),\n\t\t\tmetrics: None,\n\t\t}\n\t}\n}\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":38},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","opts","proxy.rs"],"content":"use {\n\tcrate::auth::AuthenticationSettings,\n\tclap::Args,\n\thmac::{digest::KeyInit, Hmac},\n\tserde::{Deserialize, Serialize},\n\tsha2::Sha256,\n\tstd::net::SocketAddr,\n};\n\n#[derive(Debug, Clone, Serialize, Deserialize, Args)]\npub struct ProxyOptions {\n\t/// Public client facing address for the proxy\n\t#[clap(long, env = \"QUARK_ADDRESS\", default_value = \"0.0.0.0:5670\")]\n\tpub listen_addr: SocketAddr,\n\n\t#[serde(skip)]\n\t#[clap(long, env = \"QUARK_SECRET\", value_parser = parse_secret)]\n\tpub secret: Option\u003cHmac\u003cSha256\u003e\u003e,\n}\n\nimpl ProxyOptions {\n\t/// Configures the authentication process that is invoked during session\n\t/// handshake, and is responsible for assigining player ids to new sessions\n\t/// and initialize their initial set of attributes.\n\tpub fn authentication(\u0026self) -\u003e AuthenticationSettings {\n\t\tmatch self.secret {\n\t\t\tSome(ref secret) =\u003e AuthenticationSettings::Jwt {\n\t\t\t\tsecret: secret.clone(),\n\t\t\t},\n\t\t\tNone =\u003e AuthenticationSettings::development_server(),\n\t\t}\n\t}\n}\n\nfn parse_secret(input: \u0026str) -\u003e anyhow::Result\u003cHmac\u003cSha256\u003e\u003e {\n\tlet bytes = hex::decode(input)?;\n\tOk(Hmac::new_from_slice(\u0026bytes)?)\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":7},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","opts","server.rs"],"content":"use {\n\tcrate::{\n\t\tauth::AuthenticationSettings,\n\t\trelevance::{GlobalIndexConfig, GroupIndexConfig, SpatialIndexConfig},\n\t\tschema::Schema,\n\t},\n\tanyhow::Context,\n\tclap::Args,\n\thmac::{Hmac, Mac},\n\tserde::{Deserialize, Serialize},\n\tsha2::Sha256,\n\tstd::{net::SocketAddr, path::PathBuf, time::Duration},\n\turl::Url,\n};\n\n#[derive(Debug, Serialize, Deserialize, Args)]\npub struct ServerOptions {\n\t/// Public client facing address for the server\n\t#[clap(long, env = \"QUARK_ADDRESS\", default_value = \"0.0.0.0:5670\")]\n\tpub listen_addr: SocketAddr,\n\n\t#[clap(long, env = \"QUARK_PROFILE\")]\n\tpub profile: Option\u003cPathBuf\u003e,\n\n\t#[clap(long, env = \"QUARK_REPLICATE_TO\")]\n\tpub replicate_to: Vec\u003cUrl\u003e,\n\n\t#[clap(long, env = \"QUARK_REPLICATE_FROM\")]\n\tpub replicate_from: Vec\u003cUrl\u003e,\n\n\t#[clap(long, env = \"QUARK_ADMIN_API\")]\n\tpub admin_api: Option\u003cSocketAddr\u003e,\n\n\t#[serde(skip)]\n\t#[clap(long, env = \"QUARK_SECRET\", value_parser = parse_secret)]\n\tpub secret: Option\u003cHmac\u003cSha256\u003e\u003e,\n\n\t#[clap(long, env = \"QUARK_SCHEMA\")]\n\tpub schema: Option\u003cPathBuf\u003e,\n\n\t#[cfg(test)]\n\t#[clap(skip)]\n\t#[serde(skip)]\n\tpub tests_overrides: TestsOverrides,\n}\n\nimpl Default for ServerOptions {\n\tfn default() -\u003e Self {\n\t\tSelf {\n\t\t\tlisten_addr: \"0.0.0.0:5670\".parse().unwrap(),\n\t\t\tprofile: None,\n\t\t\treplicate_to: Vec::new(),\n\t\t\treplicate_from: Vec::new(),\n\t\t\tadmin_api: None,\n\t\t\tsecret: None,\n\t\t\tschema: None,\n\n\t\t\t#[cfg(test)]\n\t\t\ttests_overrides: TestsOverrides::default(),\n\t\t}\n\t}\n}\n\nimpl ServerOptions {\n\tpub fn profile(\u0026self) -\u003e Profile {\n\t\t#[cfg(test)]\n\t\tif let Some(ref profile) = self.tests_overrides.profile {\n\t\t\treturn profile.clone();\n\t\t}\n\n\t\tmatch \u0026self.profile {\n\t\t\tSome(path) =\u003e {\n\t\t\t\tlet profile: Profile = serde_json::from_str(\n\t\t\t\t\t\u0026std::fs::read_to_string(path).expect(\"failed to read config file\"),\n\t\t\t\t)\n\t\t\t\t.expect(\"invalid config file\");\n\t\t\t\tprofile\n\t\t\t}\n\t\t\tNone =\u003e Profile::default(),\n\t\t}\n\t}\n\n\t/// Configures the authentication process that is invoked during session\n\t/// handshake, and is responsible for assigining player ids to new sessions\n\t/// and initialize their initial set of attributes.\n\tpub fn authentication(\u0026self) -\u003e AuthenticationSettings {\n\t\tmatch self.secret {\n\t\t\tSome(ref secret) =\u003e AuthenticationSettings::Jwt {\n\t\t\t\tsecret: secret.clone(),\n\t\t\t},\n\t\t\tNone =\u003e AuthenticationSettings::development_server(),\n\t\t}\n\t}\n\n\tpub fn schema(\u0026self) -\u003e anyhow::Result\u003cSchema\u003e {\n\t\t#[cfg(test)]\n\t\tif let Some(ref schema) = self.tests_overrides.schema {\n\t\t\treturn Ok(schema.clone());\n\t\t}\n\n\t\tOk(\n\t\t\tself\n\t\t\t\t.schema\n\t\t\t\t.as_ref()\n\t\t\t\t.map(Schema::from_yaml_file)\n\t\t\t\t.transpose()\n\t\t\t\t.context(\"reading schema failed\")?\n\t\t\t\t.unwrap_or_default(),\n\t\t)\n\t}\n}\n\n#[cfg(test)]\n#[derive(Debug, Clone, Default)]\npub struct TestsOverrides {\n\tprofile: Option\u003cProfile\u003e,\n\tschema: Option\u003cSchema\u003e,\n}\n\n#[cfg(test)]\nimpl ServerOptions {\n\tpub fn with_profile(profile: Profile) -\u003e Self {\n\t\tlet overrides = TestsOverrides {\n\t\t\tprofile: Some(profile),\n\t\t\t..TestsOverrides::default()\n\t\t};\n\n\t\tSelf {\n\t\t\ttests_overrides: overrides,\n\t\t\t..Default::default()\n\t\t}\n\t}\n\n\tpub fn with_schema(schema: Schema) -\u003e Self {\n\t\tlet overrides = TestsOverrides {\n\t\t\tschema: Some(schema),\n\t\t\t..TestsOverrides::default()\n\t\t};\n\n\t\tSelf {\n\t\t\ttests_overrides: overrides,\n\t\t\t..Default::default()\n\t\t}\n\t}\n\n\tpub fn with_profile_and_schema(profile: Profile, schema: Schema) -\u003e Self {\n\t\tlet overrides = TestsOverrides {\n\t\t\tprofile: Some(profile),\n\t\t\tschema: Some(schema),\n\t\t};\n\n\t\tSelf {\n\t\t\ttests_overrides: overrides,\n\t\t\t..Default::default()\n\t\t}\n\t}\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\", default)]\npub struct Profile {\n\t#[serde(with = \"humantime_serde\")]\n\tpub resume_timeout: Duration,\n\n\t#[serde(with = \"humantime_serde\")]\n\tpub relevance_timeout: Duration,\n\n\t#[serde(with = \"humantime_serde\")]\n\tpub remote_view_prune_interval: Duration,\n\n\tpub spatial_index: SpatialIndexConfig,\n\tpub group_index: GroupIndexConfig,\n\tpub global_index: GlobalIndexConfig,\n}\n\nimpl Default for Profile {\n\tfn default() -\u003e Self {\n\t\tSelf {\n\t\t\tresume_timeout: Duration::from_secs(60),\n\t\t\trelevance_timeout: Duration::from_millis(500),\n\t\t\tremote_view_prune_interval: Duration::from_secs(300),\n\t\t\tspatial_index: SpatialIndexConfig::default(),\n\t\t\tgroup_index: GroupIndexConfig::default(),\n\t\t\tglobal_index: GlobalIndexConfig::default(),\n\t\t}\n\t}\n}\n\nfn parse_secret(input: \u0026str) -\u003e anyhow::Result\u003cHmac\u003cSha256\u003e\u003e {\n\tlet bytes = hex::decode(input)?;\n\tOk(Hmac::new_from_slice(\u0026bytes)?)\n}\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":714},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":780},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":648},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":648},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":118},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":135},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":103},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":660},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":660},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":660},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":660},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":660},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":660},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":660},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":29,"coverable":35},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","proxy","mod.rs"],"content":"use {\n\tcrate::{\n\t\tauth::AuthenticationSettings,\n\t\topts::ProxyOptions,\n\t\tsession::FramedStream,\n\t\tstate::player::PlayerId,\n\t\ttopology::Topology,\n\t},\n\tbytes::{Buf, BufMut, Bytes, BytesMut},\n\tfutures::{SinkExt, StreamExt},\n\tquark_client_sdk::protocol::handshake::{\n\t\tsession_handshake_request,\n\t\tsession_handshake_response,\n\t},\n\tstd::{net::SocketAddr, sync::Arc, time::Duration},\n\ttokio::net::{TcpListener, TcpStream},\n\ttokio_util::codec::{Framed, LengthDelimitedCodec},\n\ttracing::{error, info, trace},\n};\n\nmod session;\n\nstruct ProxyGlobalState {\n\ttopology: Arc\u003cTopology\u003e,\n\tauth: AuthenticationSettings,\n}\n\npub async fn run(\n\topts: ProxyOptions,\n\ttopology: Arc\u003cTopology\u003e,\n) -\u003e anyhow::Result\u003c()\u003e {\n\tinfo!(\"Proxy started with opts: {opts:#?}\");\n\n\tlet listener = TcpListener::bind(opts.listen_addr).await?;\n\tlet global = Arc::new(ProxyGlobalState {\n\t\ttopology,\n\t\tauth: opts.authentication(),\n\t});\n\n\tloop {\n\t\tif let Ok((stream, from)) = listener.accept().await {\n\t\t\ttrace!(\"accepting new connection from {from}\");\n\t\t\tlet global = Arc::clone(\u0026global);\n\t\t\ttokio::spawn(async move {\n\t\t\t\tif let Err(e) =\n\t\t\t\t\taccept_new_client(from, stream, Arc::clone(\u0026global)).await\n\t\t\t\t{\n\t\t\t\t\terror!(\"Failed to accept new client: {e}\");\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n}\n\nasync fn accept_new_client(\n\tfrom: std::net::SocketAddr,\n\ttcplink: TcpStream,\n\tglobal: Arc\u003cProxyGlobalState\u003e,\n) -\u003e anyhow::Result\u003c()\u003e {\n\tlet sock_ref = socket2::SockRef::from(\u0026tcplink);\n\tlet mut ka = socket2::TcpKeepalive::new();\n\tka = ka.with_time(Duration::from_secs(20));\n\tka = ka.with_interval(Duration::from_secs(20));\n\tsock_ref.set_tcp_keepalive(\u0026ka)?;\n\tsock_ref.set_nodelay(true)?;\n\n\tlet mut tcplink = FramedStream::new(tcplink, LengthDelimitedCodec::new());\n\n\tlet player_id = session::handshake(\n\t\tfrom, // client address\n\t\t\u0026mut tcplink,\n\t\t\u0026global.auth,\n\t)\n\t.await?;\n\n\t// now that we have the identity of the player, locate the server that\n\t// should host the player in the current topology\n\tlet target_server = global\n\t\t.topology\n\t\t.server_for(\u0026player_id)\n\t\t.ok_or(anyhow::anyhow!(\"No server found for session {player_id}\"))?\n\t\t.info()\n\t\t.listen_address;\n\n\t// create a new preauthenticated session on the target server\n\tlet mut server_stream = create_internal_session(\n\t\t\u0026global.topology.me().id, //\n\t\tplayer_id,\n\t\ttarget_server,\n\t)\n\t.await?;\n\n\t// start the proxying loop\n\t// TODO: This could be heavily optimized by various means\n\tloop {\n\t\ttokio::select! {\n\t\t\tserver_to_client = server_stream.next() =\u003e {\n\t\t\t\tlet Some(Ok(packet)) = server_to_client else {\n\t\t\t\t\t// server stream closed\n\t\t\t\t\treturn Ok(());\n\t\t\t\t};\n\n\t\t\t\ttcplink.send(packet.freeze()).await?;\n\t\t\t}\n\t\t\tclient_to_server = tcplink.next() =\u003e {\n\t\t\t\tlet Some(Ok(packet)) = client_to_server else {\n\t\t\t\t\t// client stream closed\n\t\t\t\t\treturn Ok(());\n\t\t\t\t};\n\t\t\t\tserver_stream.send(packet.freeze()).await?;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfn build_internal_handshake(player_id: PlayerId, proxy_id: \u0026str) -\u003e Bytes {\n\tlet outbuf = BytesMut::new();\n\t// build the start session handshake request\n\tlet mut request = capnp::message::Builder::new_default();\n\tlet builder = request.init_root::\u003csession_handshake_request::Builder\u003e();\n\tlet mut builder = builder.init_internal();\n\tbuilder.reborrow().set_assigned_id(player_id);\n\tbuilder.reborrow().set_proxy_id(proxy_id.into());\n\n\tlet mut writer = outbuf.writer();\n\tcapnp::serialize_packed::write_message(\u0026mut writer, \u0026request)\n\t\t.expect(\"failed to serialize capnp message\");\n\twriter.into_inner().freeze()\n}\n\nasync fn create_internal_session(\n\tproxy_id: \u0026str,\n\tplayer_id: PlayerId,\n\ttarget_server: SocketAddr,\n) -\u003e anyhow::Result\u003cFramedStream\u003e {\n\t// open a new session on the target server\n\t// using internal authentication handshake\n\tlet mut server_stream = Framed::new(\n\t\tTcpStream::connect(target_server).await?,\n\t\tLengthDelimitedCodec::new(),\n\t);\n\n\tlet internal_handshake = build_internal_handshake(player_id, proxy_id);\n\n\tserver_stream.send(internal_handshake).await?;\n\tlet Some(Ok(response)) = server_stream.next().await else {\n\t\treturn Err(anyhow::anyhow!(\"Internal handshake failed\"));\n\t};\n\n\tlet message = capnp::serialize_packed::read_message(\n\t\t\u0026mut response.reader(),\n\t\tcapnp::message::ReaderOptions::default(),\n\t)?;\n\n\tlet session_handshake_response::Which::Started(confirmation) = message\n\t\t.get_root::\u003csession_handshake_response::Reader\u003e()?\n\t\t.which()?\n\telse {\n\t\treturn Err(anyhow::anyhow!(\"Internal session handshake failed\"));\n\t};\n\n\tif confirmation?.get_assigned_id() != player_id {\n\t\treturn Err(anyhow::anyhow!(\n\t\t\t\"Internal session handshake failed (wrong player id)\"\n\t\t));\n\t}\n\n\tOk(server_stream)\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":54},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","proxy","session.rs"],"content":"use {\n\tcrate::{\n\t\tauth::{authenticate, AuthenticationSettings},\n\t\tsession::handshake::SessionHandshake,\n\t\tstate::{player::PlayerId, EntityId},\n\t},\n\tcapnp::{message::ReaderOptions, serialize_packed::read_message},\n\tfutures::StreamExt,\n\tquark_client_sdk::protocol::handshake::session_handshake_request,\n\tstd::net::SocketAddr,\n\ttokio::net::TcpStream,\n\ttokio_util::codec::{Framed, LengthDelimitedCodec},\n\ttracing::trace,\n};\n\ntype FramedStream = Framed\u003cTcpStream, LengthDelimitedCodec\u003e;\n\npub async fn handshake(\n\tfrom: SocketAddr,\n\tstream: \u0026mut FramedStream,\n\tauth: \u0026AuthenticationSettings,\n) -\u003e anyhow::Result\u003cPlayerId\u003e {\n\tlet Some(Ok(bytes)) = stream.next().await else {\n\t\treturn Err(anyhow::anyhow!(\"Client disconnected\"));\n\t};\n\n\tmatch parse_handshake(\u0026bytes)? {\n\t\tSessionHandshake::New(auth_data) =\u003e {\n\t\t\tlet initial_state = match authenticate(\u0026auth_data, auth) {\n\t\t\t\tOk(state) =\u003e state,\n\t\t\t\tErr(e) =\u003e {\n\t\t\t\t\treturn Err(anyhow::anyhow!(\"Invalid auth data: {}\", e));\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tlet EntityId::Player(public_id) = *initial_state.id() else {\n\t\t\t\treturn Err(anyhow::anyhow!(\"Invalid player id\"));\n\t\t\t};\n\n\t\t\ttrace!(\"Player {public_id} authenticated from {from}\");\n\n\t\t\tOk(public_id)\n\t\t}\n\t\tSessionHandshake::Resume(_) =\u003e {\n\t\t\tanyhow::bail!(\"Session resume on proxy is not supported yet\")\n\t\t}\n\t\tSessionHandshake::Internal(_, _) =\u003e {\n\t\t\tanyhow::bail!(\"Invalid handshake request (internal on proxy)\")\n\t\t}\n\t}\n}\n\npub fn parse_handshake(bytes: \u0026[u8]) -\u003e anyhow::Result\u003cSessionHandshake\u003e {\n\tlet reader = read_message(bytes, ReaderOptions::default())?;\n\tlet handshake = reader.get_root::\u003csession_handshake_request::Reader\u003e()?;\n\n\tmatch handshake.which()? {\n\t\tsession_handshake_request::Which::Start(reader) =\u003e {\n\t\t\tOk(SessionHandshake::New(reader?.get_auth()?.to_vec()))\n\t\t}\n\t\tsession_handshake_request::Which::Resume(reader) =\u003e Ok(\n\t\t\t// extract resume token\n\t\t\tSessionHandshake::Resume(reader?.get_token()?.to_vec()),\n\t\t),\n\t\tsession_handshake_request::Which::Internal(_) =\u003e {\n\t\t\tanyhow::bail!(\"Internal handshake is not supported on proxy nodes\")\n\t\t}\n\t}\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":22},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","relevance","global.rs"],"content":"use {\n\tsuper::{Relevance, RelevanceIndex},\n\tcrate::{\n\t\tmeasured,\n\t\tobjects::ObjectsState,\n\t\tschema::Schema,\n\t\tstate::{entity::Entity, EntityId},\n\t},\n\tparking_lot::RwLock,\n\tserde::{Deserialize, Serialize},\n\tstd::{collections::HashSet, sync::Arc, time::Duration},\n\ttokio::time::{interval, MissedTickBehavior},\n};\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\n#[serde(rename_all = \"camelCase\", default)]\npub struct Config {\n\t#[serde(with = \"humantime_serde\")]\n\tpub reindex_interval: Duration,\n}\n\nimpl Default for Config {\n\tfn default() -\u003e Self {\n\t\tSelf {\n\t\t\treindex_interval: Duration::from_secs(3),\n\t\t}\n\t}\n}\n\npub(super) struct GlobalObjectsIndex {\n\tsnapshot: Arc\u003cRwLock\u003cVec\u003cEntityId\u003e\u003e\u003e,\n}\n\nimpl GlobalObjectsIndex {\n\tpub fn new(\n\t\tconfig: Config,\n\t\tobjects: Arc\u003cObjectsState\u003e,\n\t\tschema: \u0026Schema,\n\t) -\u003e Self {\n\t\tlet snapshot: Arc\u003cRwLock\u003cVec\u003cEntityId\u003e\u003e\u003e =\n\t\t\tArc::new(RwLock::new(Vec::new()));\n\n\t\tlet snapshot_ptr = Arc::clone(\u0026snapshot);\n\t\tlet global_objects_class_ids: HashSet\u003c_\u003e = schema\n\t\t\t.objects\n\t\t\t.iter()\n\t\t\t.filter(|object| object.global)\n\t\t\t.map(|object| object.class_id)\n\t\t\t.collect();\n\n\t\ttokio::spawn(async move {\n\t\t\tlet snapshot = snapshot_ptr;\n\t\t\tlet mut timer = interval(config.reindex_interval);\n\t\t\ttimer.set_missed_tick_behavior(MissedTickBehavior::Skip);\n\n\t\t\tloop {\n\t\t\t\ttimer.tick().await;\n\n\t\t\t\tmeasured!(\"global_objects_reindex_duration\", {\n\t\t\t\t\tlet mut new_version = Vec::new();\n\t\t\t\t\tfor object in objects.iter() {\n\t\t\t\t\t\tif let Some(class_id) = object.class_id() {\n\t\t\t\t\t\t\tif global_objects_class_ids.contains(\u0026class_id) {\n\t\t\t\t\t\t\t\tnew_version.push(*object.id());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t*snapshot.write() = new_version;\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tSelf { snapshot }\n\t}\n}\n\nimpl RelevanceIndex for GlobalObjectsIndex {\n\tfn relevant(\u0026self, _: \u0026Entity, _: Relevance) -\u003e Vec\u003cEntityId\u003e {\n\t\tself.snapshot.read().clone()\n\t}\n\n\t/// Always return relevance as none when comparing entity to entity so that\n\t/// the global index is only used to retreive global objects but does not\n\t/// participate in the write access control.\n\tfn relevance(\u0026self, _: \u0026Entity, _: \u0026Entity) -\u003e Relevance {\n\t\tRelevance::none()\n\t}\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":661},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":661},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":268},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":238},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":715},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":298},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":298},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":495},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":230},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":298},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":2928},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":2928},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":960},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":960},"fn_name":null}],"covered":26,"coverable":26},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","relevance","group.rs"],"content":"use {\n\tsuper::{Relevance, RelevanceIndex},\n\tcrate::{\n\t\tglobal::PlayersState,\n\t\tmeasured,\n\t\tobjects::ObjectsState,\n\t\tstate::{\n\t\t\tentity::{AttributeId, Entity},\n\t\t\tEntityId,\n\t\t},\n\t},\n\tmetrics::{histogram, increment_counter},\n\tparking_lot::RwLock,\n\tquark_client_sdk::{Value, WellKnownAttribute},\n\trustc_hash::{FxHashMap, FxHashSet},\n\tserde::{Deserialize, Serialize},\n\tstd::{sync::Arc, time::Duration},\n\ttokio::time::{interval, MissedTickBehavior},\n};\n\ntype GroupId = u64;\ntype MembershipTable = FxHashMap\u003cGroupId, FxHashSet\u003cEntityId\u003e\u003e;\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\n#[serde(rename_all = \"camelCase\", default)]\npub struct Config {\n\t#[serde(with = \"humantime_serde\")]\n\tpub reindex_interval: Duration,\n}\n\nimpl Default for Config {\n\tfn default() -\u003e Self {\n\t\tSelf {\n\t\t\treindex_interval: Duration::from_secs(1),\n\t\t}\n\t}\n}\n\npub(super) struct GroupMembershipIndex {\n\t/// This is a snapshot of the latest built index. It is used to anwer queries\n\t/// about group membership. It is updated every time the index is rebuilt.\n\tsnapshot: Arc\u003cRwLock\u003cMembershipTable\u003e\u003e,\n}\n\nimpl GroupMembershipIndex {\n\tpub fn new(\n\t\tconfig: Config,\n\t\tplayers: Arc\u003cPlayersState\u003e,\n\t\tobjects: Arc\u003cObjectsState\u003e,\n\t) -\u003e Self {\n\t\tlet snapshot: Arc\u003cRwLock\u003cMembershipTable\u003e\u003e =\n\t\t\tArc::new(RwLock::new(FxHashMap::default()));\n\n\t\tlet config_copy = config.clone();\n\t\tlet snapshot_ptr = Arc::clone(\u0026snapshot);\n\n\t\ttokio::spawn(async move {\n\t\t\tlet config = config_copy;\n\t\t\tlet snapshot = snapshot_ptr;\n\t\t\tlet mut timer = interval(config.reindex_interval);\n\t\t\ttimer.set_missed_tick_behavior(MissedTickBehavior::Skip);\n\n\t\t\t// This is a list of all active players and objects that are currently\n\t\t\t// indexed in the spatial index. This is used to rebuild the index\n\n\t\t\tloop {\n\t\t\t\ttimer.tick().await;\n\n\t\t\t\t// rebuild the index\n\t\t\t\tlet new_version = measured!(\n\t\t\t\t\t\"index_group_reindex_duration\",\n\t\t\t\t\tcompute_new_snapshot(\u0026players, \u0026objects)\n\t\t\t\t);\n\n\t\t\t\thistogram!(\"group_index_count\", new_version.len() as f64);\n\n\t\t\t\t// swap the new version of the prcalculated hashes with the old one\n\t\t\t\t*snapshot.write() = new_version;\n\t\t\t}\n\t\t});\n\n\t\tSelf { snapshot }\n\t}\n}\n\nimpl RelevanceIndex for GroupMembershipIndex {\n\tfn relevant(\u0026self, entity: \u0026Entity, interest: Relevance) -\u003e Vec\u003cEntityId\u003e {\n\t\tif interest.is_none() {\n\t\t\treturn Vec::new();\n\t\t}\n\n\t\tincrement_counter!(\"index_group_query_count\");\n\n\t\tlet Some(group_id) = read_group_id(entity) else {\n\t\t\treturn Vec::new();\n\t\t};\n\n\t\tmeasured!(\n\t\t\t\"index_group_query_duration\",\n\t\t\tself\n\t\t\t\t.snapshot\n\t\t\t\t.read()\n\t\t\t\t.get(\u0026group_id)\n\t\t\t\t.map(|relevant| relevant.iter().copied().collect())\n\t\t\t\t.unwrap_or_default()\n\t\t)\n\t}\n\n\tfn relevance(\u0026self, a: \u0026Entity, b: \u0026Entity) -\u003e super::Relevance {\n\t\tlet Some(a_group_id) = read_group_id(a) else {\n\t\t\treturn Relevance::none();\n\t\t};\n\n\t\tlet Some(b_group_id) = read_group_id(b) else {\n\t\t\treturn Relevance::none();\n\t\t};\n\n\t\tif a_group_id == b_group_id {\n\t\t\tRelevance::max()\n\t\t} else {\n\t\t\tRelevance::none()\n\t\t}\n\t}\n}\n\nfn compute_new_snapshot(\n\tplayers: \u0026PlayersState,\n\tobjects: \u0026ObjectsState,\n) -\u003e MembershipTable {\n\tlet mut snapshot = MembershipTable::default();\n\n\tlet mut index = |id: EntityId, entity: \u0026Entity| {\n\t\tif let Some(group_id) = read_group_id(entity) {\n\t\t\tsnapshot.entry(group_id).or_default().insert(id);\n\t\t}\n\t};\n\n\tfor object in objects.iter() {\n\t\tindex(EntityId::Object(*object.key()), object.value());\n\t}\n\n\tfor player in players.iter() {\n\t\tindex(EntityId::Player(*player.key()), player.value());\n\t}\n\n\tsnapshot\n}\n\nfn read_group_id(entity: \u0026Entity) -\u003e Option\u003cGroupId\u003e {\n\tentity\n\t\t.attributes()\n\t\t.get(WellKnownAttribute::GroupId as AttributeId)\n\t\t.map(|value| match value {\n\t\t\tValue::Uint8(v) =\u003e v as GroupId,\n\t\t\tValue::Uint16(v) =\u003e v as GroupId,\n\t\t\tValue::Uint32(v) =\u003e v as GroupId,\n\t\t\tValue::Uint64(v) =\u003e v as GroupId,\n\t\t\tValue::Int8(v) =\u003e v as GroupId,\n\t\t\tValue::Int16(v) =\u003e v as GroupId,\n\t\t\tValue::Int32(v) =\u003e v as GroupId,\n\t\t\tValue::Int64(v) =\u003e v as GroupId,\n\t\t\t_ =\u003e 0,\n\t\t})\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":661},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":661},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":238},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1999},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1880},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":940},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":940},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":940},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":2928},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":2928},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":2928},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":2946},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":2910},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":960},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":962},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":958},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":940},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":940},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":4073},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":3156},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":3432},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":1246},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":4714},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":1887},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":940},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":7023},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":7023},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":7023},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":7066},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":41,"coverable":54},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","relevance","indices.rs"],"content":"use {\n\tsuper::{\n\t\tglobal::GlobalObjectsIndex,\n\t\tgroup::GroupMembershipIndex,\n\t\townership::OwnershipIndex,\n\t\tspatial::Spatial2DIndex,\n\t\tRelevance,\n\t\tRelevanceIndex,\n\t},\n\tcrate::{\n\t\tglobal::PlayersState,\n\t\tobjects::ObjectsState,\n\t\topts::Profile,\n\t\tschema::Schema,\n\t\tstate::{\n\t\t\tentity::{AttributeId, Entity},\n\t\t\tgraph::ObjectGraph,\n\t\t\tobject::ObjectId,\n\t\t\tEntityId,\n\t\t},\n\t},\n\tquark_client_sdk::WellKnownAttribute,\n\trustc_hash::FxHashSet,\n\tstd::{\n\t\tptr::{addr_eq, from_ref},\n\t\tsync::Arc,\n\t},\n};\n\npub struct Indices {\n\tgraph: Arc\u003cObjectGraph\u003e,\n\tobjects: Arc\u003cObjectsState\u003e,\n\tindices: Vec\u003cBox\u003cdyn RelevanceIndex\u003e\u003e,\n}\n\nimpl Indices {\n\t/// Returns all entities that are relevant to a given player according for all\n\t/// indices specified by their ids. The indices IDs are most often the\n\t/// subscriptions list for a player session.\n\tpub fn relevant(\n\t\t\u0026self,\n\t\tentity: \u0026Entity,\n\t\trelevancy: super::Relevance,\n\t) -\u003e FxHashSet\u003cEntityId\u003e {\n\t\tlet mut result = FxHashSet::default();\n\n\t\t// If the entity has an interest centroid, we use that as the centroid\n\t\t// for the relevancy calculation. Otherwise, we use the entity itself.\n\n\t\tlet mut centroid = entity;\n\t\tlet alt_centroid = entity\n\t\t\t.attributes()\n\t\t\t.get(WellKnownAttribute::Delegate as AttributeId)\n\t\t\t.and_then(|value| ObjectId::try_from(value).ok())\n\t\t\t.and_then(|id| self.objects.get(\u0026id));\n\n\t\tif let Some(ref e) = alt_centroid {\n\t\t\tif let EntityId::Object(object_id) = e.id() {\n\t\t\t\t// delegated interest centroid must be owned by the entity\n\t\t\t\t// delegating it.\n\t\t\t\tif self.graph.is_owned_by(*object_id, *entity.id()) {\n\t\t\t\t\tcentroid = e.value();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif !relevancy.is_none() {\n\t\t\tfor index in \u0026self.indices {\n\t\t\t\tlet relevant = index.relevant(centroid, relevancy);\n\t\t\t\tfor entity in relevant {\n\t\t\t\t\tresult.insert(entity);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tresult\n\t}\n\n\t/// Calculates the relevancy between a player and an entity.\n\t/// This is used when deciding which player has authority over an object.\n\t///\n\t/// This function will first check if entities have delegated centroids of\n\t/// interest, and if so, it will use those to calculate relevancy. If not,\n\t/// it will use the entities themselves.\n\tpub fn relevance(\u0026self, from: \u0026Entity, to: \u0026Entity) -\u003e Relevance {\n\t\tlet mut centroid_from = from;\n\t\tlet mut centroid_to = to;\n\n\t\tlet alt_centroid_from = from\n\t\t\t.attributes()\n\t\t\t.get(WellKnownAttribute::Delegate as AttributeId)\n\t\t\t.and_then(|value| ObjectId::try_from(value).ok())\n\t\t\t.and_then(|id| self.objects.get(\u0026id));\n\n\t\tif let Some(ref e) = alt_centroid_from {\n\t\t\tif let EntityId::Object(object_id) = e.id() {\n\t\t\t\t// delegated interest centroid must be owned by the entity\n\t\t\t\t// delegating it.\n\t\t\t\tif self.graph.is_owned_by(*object_id, *from.id()) {\n\t\t\t\t\tcentroid_from = e.value();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet alt_centroid_to = to\n\t\t\t.attributes()\n\t\t\t.get(WellKnownAttribute::Delegate as AttributeId)\n\t\t\t.and_then(|value| ObjectId::try_from(value).ok())\n\t\t\t.and_then(|id| self.objects.get(\u0026id));\n\n\t\tif let Some(ref e) = alt_centroid_to {\n\t\t\tif let EntityId::Object(object_id) = e.id() {\n\t\t\t\t// delegated interest centroid must be owned by the entity\n\t\t\t\t// delegating it.\n\t\t\t\tif self.graph.is_owned_by(*object_id, *to.id()) {\n\t\t\t\t\tcentroid_to = e.value();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet mut relevance = self\n\t\t\t.indices\n\t\t\t.iter()\n\t\t\t.map(|index| index.relevance(centroid_from, centroid_to))\n\t\t\t.max()\n\t\t\t.unwrap_or(Relevance::none());\n\n\t\t// if entities have delegated centroids of interest, we need to check\n\t\t// the relevancy between the actual entities and the centroids because of\n\t\t// things like ownership relationships.\n\t\tif !addr_eq(from_ref(centroid_from), from_ref(from))\n\t\t\t|| !addr_eq(from_ref(centroid_to), from_ref(to))\n\t\t{\n\t\t\trelevance = relevance.max(\n\t\t\t\tself\n\t\t\t\t\t.indices\n\t\t\t\t\t.iter()\n\t\t\t\t\t.map(|index| index.relevance(from, to))\n\t\t\t\t\t.max()\n\t\t\t\t\t.unwrap_or(Relevance::none()),\n\t\t\t);\n\t\t}\n\n\t\trelevance\n\t}\n\n\t/// Instntiates the default set of indices.\n\t///\n\t/// By default we have the following set of indices enabled:\n\t///\n\t/// 1. Spatial2DIndex\n\t/// 2. GroupMembershipIndex\n\t/// 3. OwnershipIndex\n\tpub fn new(\n\t\tschema: \u0026Schema,\n\t\tprofile: \u0026Profile,\n\t\townership: Arc\u003cObjectGraph\u003e,\n\t\tplayers: Arc\u003cPlayersState\u003e,\n\t\tobjects: Arc\u003cObjectsState\u003e,\n\t) -\u003e Self {\n\t\tSelf {\n\t\t\tgraph: Arc::clone(\u0026ownership),\n\t\t\tobjects: Arc::clone(\u0026objects),\n\t\t\tindices: vec![\n\t\t\t\tBox::new(Spatial2DIndex::new(\n\t\t\t\t\tprofile.spatial_index.clone(),\n\t\t\t\t\tArc::clone(\u0026ownership),\n\t\t\t\t\tArc::clone(\u0026players),\n\t\t\t\t\tArc::clone(\u0026objects),\n\t\t\t\t)),\n\t\t\t\tBox::new(GroupMembershipIndex::new(\n\t\t\t\t\tprofile.group_index.clone(),\n\t\t\t\t\tArc::clone(\u0026players),\n\t\t\t\t\tArc::clone(\u0026objects),\n\t\t\t\t)),\n\t\t\t\tBox::new(OwnershipIndex::new(ownership)),\n\t\t\t\tBox::new(GlobalObjectsIndex::new(\n\t\t\t\t\tprofile.global_index.clone(),\n\t\t\t\t\tArc::clone(\u0026objects),\n\t\t\t\t\tschema,\n\t\t\t\t)),\n\t\t\t],\n\t\t}\n\t}\n}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":2928},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":2928},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":2928},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":2928},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":2928},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":5941},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":5941},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":3013},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":85},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":75},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":75},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":2928},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":26352},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":33657},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":7315},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":2928},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":960},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":960},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":960},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":960},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":960},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":1923},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":1923},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":960},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":960},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":960},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":960},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":960},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":960},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":4800},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":960},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":960},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":119},"fn_name":null}],"covered":36,"coverable":49},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","relevance","mod.rs"],"content":"use crate::state::{entity::Entity, EntityId};\n\nmod global;\nmod group;\nmod indices;\nmod ownership;\nmod spatial;\n\npub type Relevance = quark_client_sdk::Relevance;\n\n/// This trait is implemented by all player and object relevancy indices.\n/// It finds all players or objects that are relevant to a given player at a\n/// this point in time.\n///\n/// All Ids are the local ids of the entities, not their public ids.\npub trait RelevanceIndex: Send + Sync {\n\t/// Called by the server when a session sends an update to the server with\n\t/// new values of its properties. This method will return all other entities\n\t/// (sessions) that are relevant to a player.\n\tfn relevant(\u0026self, entity: \u0026Entity, interest: Relevance) -\u003e Vec\u003cEntityId\u003e;\n\n\t/// Calculates the relevancy between two entities that could be either a\n\t/// player or an object. This distance measure is index specific.\n\t///\n\t/// This is used in serveral places, for example when deciding which\n\t/// player has authority over an object, or when clustering players and\n\t/// objects into regions.\n\t///\n\t/// This method is called very frequently and should be very fast.\n\t///\n\t/// If the distance cannot be calculated (for example because the entities\n\t/// are missing attributes that are required for the distance calculation)\n\t/// then this method should return None.\n\tfn relevance(\u0026self, a: \u0026Entity, b: \u0026Entity) -\u003e Relevance;\n}\n\npub use {\n\tglobal::Config as GlobalIndexConfig,\n\tgroup::Config as GroupIndexConfig,\n\tindices::Indices,\n\tspatial::Config as SpatialIndexConfig,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","relevance","ownership.rs"],"content":"use {\n\tsuper::{Relevance, RelevanceIndex},\n\tcrate::state::{entity::Entity, graph::ObjectGraph, EntityId},\n\tstd::sync::Arc,\n};\n\npub(super) struct OwnershipIndex {\n\tgraph: Arc\u003cObjectGraph\u003e,\n}\n\nimpl OwnershipIndex {\n\tpub fn new(graph: Arc\u003cObjectGraph\u003e) -\u003e OwnershipIndex {\n\t\tOwnershipIndex { graph }\n\t}\n}\n\nimpl RelevanceIndex for OwnershipIndex {\n\tfn relevant(\u0026self, entity: \u0026Entity, _: Relevance) -\u003e Vec\u003cEntityId\u003e {\n\t\tself\n\t\t\t.graph\n\t\t\t.children_of(*entity.id())\n\t\t\t.into_iter()\n\t\t\t.map(EntityId::Object)\n\t\t\t.collect()\n\t}\n\n\tfn relevance(\u0026self, a: \u0026Entity, b: \u0026Entity) -\u003e Relevance {\n\t\tif let EntityId::Object(object_id) = *b.id() {\n\t\t\tif self.graph.is_owned_by(object_id, *a.id()) {\n\t\t\t\tRelevance::max()\n\t\t\t} else {\n\t\t\t\tRelevance::none()\n\t\t\t}\n\t\t} else {\n\t\t\tRelevance::none()\n\t\t}\n\t}\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":2928},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":2928},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":2928},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":2928},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":2928},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":960},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":1920},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":940},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":10,"coverable":11},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","relevance","spatial.rs"],"content":"use {\n\tsuper::{Relevance, RelevanceIndex},\n\tcrate::{\n\t\tglobal::PlayersState,\n\t\tmeasured,\n\t\tobjects::ObjectsState,\n\t\tstate::{\n\t\t\tentity::{AttributeId, Entity},\n\t\t\tgraph::ObjectGraph,\n\t\t\tEntityId,\n\t\t},\n\t},\n\tmetrics::{histogram, increment_counter},\n\tquark_client_sdk::{Value, WellKnownAttribute},\n\trustc_hash::{FxHashMap, FxHashSet},\n\tserde::{Deserialize, Serialize},\n\tstd::{\n\t\tcollections::BTreeMap,\n\t\tsync::{Arc, RwLock},\n\t\ttime::{Duration, Instant},\n\t},\n\ttokio::time::{interval, MissedTickBehavior},\n};\n\ntype XCoordinate = i32;\ntype YCoordinate = i32;\ntype LevelCoordinate = i32;\n\ntype SpatialHash = (LevelCoordinate, XCoordinate, YCoordinate);\ntype IndexSnapshot = FxHashMap\u003c\n\tLevelCoordinate,\n\tFxHashMap\u003cXCoordinate, BTreeMap\u003cYCoordinate, Vec\u003cEntityId\u003e\u003e\u003e,\n\u003e;\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\n#[serde(rename_all = \"camelCase\", default)]\npub struct Config {\n\tpub max_radius: usize,\n\tpub map_width: usize,\n\tpub map_height: usize,\n\tpub cells_count_x: usize,\n\tpub cells_count_y: usize,\n\t#[serde(with = \"humantime_serde\")]\n\tpub reindex_interval: Duration,\n}\n\nimpl Default for Config {\n\tfn default() -\u003e Self {\n\t\tSelf {\n\t\t\tmax_radius: 20,\n\t\t\tmap_width: 1000000,\n\t\t\tmap_height: 1000000,\n\t\t\tcells_count_x: 500,\n\t\t\tcells_count_y: 500,\n\t\t\treindex_interval: Duration::from_secs(1),\n\t\t}\n\t}\n}\n\npub(super) struct Spatial2DIndex {\n\t/// Global index configuration. This is configured in the server profile file\n\t/// on startup.\n\tconfig: Config,\n\n\t/// This is a snapshot of the latest built index. It is used to anwer queries\n\t/// from individual sessions and is updated every time the index is rebuilt.\n\t///\n\t/// This is a hot path and the write lock should be as short as possible.\n\tsnapshot_by_hash: Arc\u003cRwLock\u003cIndexSnapshot\u003e\u003e,\n\n\tplayers: Arc\u003cPlayersState\u003e,\n\tobjects: Arc\u003cObjectsState\u003e,\n\townership_graph: Arc\u003cObjectGraph\u003e,\n}\n\nimpl Spatial2DIndex {\n\tpub fn new(\n\t\tconfig: Config,\n\t\tgraph: Arc\u003cObjectGraph\u003e,\n\t\tplayers: Arc\u003cPlayersState\u003e,\n\t\tobjects: Arc\u003cObjectsState\u003e,\n\t) -\u003e Self {\n\t\tlet snapshot_by_hash: Arc\u003cRwLock\u003cIndexSnapshot\u003e\u003e =\n\t\t\tArc::new(RwLock::new(FxHashMap::default()));\n\n\t\tlet config_copy = config.clone();\n\t\tlet snapshot_by_hash_ptr = Arc::clone(\u0026snapshot_by_hash);\n\n\t\tlet players_ref = Arc::clone(\u0026players);\n\t\tlet objects_ref = Arc::clone(\u0026objects);\n\t\ttokio::spawn(async move {\n\t\t\tlet config = config_copy;\n\t\t\tlet snapshot_by_hash = snapshot_by_hash_ptr;\n\t\t\tlet mut timer = interval(config.reindex_interval);\n\t\t\ttimer.set_missed_tick_behavior(MissedTickBehavior::Skip);\n\n\t\t\t// This is a list of all active players and objects that are currently\n\t\t\t// indexed in the spatial index. This is used to rebuild the index\n\n\t\t\tloop {\n\t\t\t\ttimer.tick().await;\n\n\t\t\t\t// rebuild the index\n\t\t\t\tlet new_version_by_hash = measured!(\n\t\t\t\t\t\"index_spatial_reindex_duration\",\n\t\t\t\t\tcompute_new_snapshots(\u0026config, \u0026players_ref, \u0026objects_ref)\n\t\t\t\t);\n\n\t\t\t\thistogram!(\"spatial_index_count\", new_version_by_hash.len() as f64);\n\n\t\t\t\t// swap the new version of the prcalculated hashes with the old one\n\t\t\t\t*snapshot_by_hash.write().expect(\"poisoned lock\") = new_version_by_hash;\n\t\t\t}\n\t\t});\n\n\t\tSelf {\n\t\t\tconfig,\n\t\t\tplayers,\n\t\t\tobjects,\n\t\t\tsnapshot_by_hash,\n\t\t\townership_graph: graph,\n\t\t}\n\t}\n\n\t/// Retreives the position of an object by first checking if the\n\t/// object has a position attribute, if not, then it will travers\n\t/// all its ownership graph upwards until it finds an object or a player\n\t/// that has a position attribute. The closest parent that has a position\n\t/// will be used as the position of the object.\n\tfn position_of_object(\n\t\t\u0026self,\n\t\tentity: \u0026Entity,\n\t) -\u003e Option\u003c(LevelCoordinate, f64, f64)\u003e {\n\t\tif let Some((level, x, y)) = read_position(entity) {\n\t\t\tSome((level, x, y))\n\t\t} else {\n\t\t\tlet EntityId::Object(obj_id) = *entity.id() else {\n\t\t\t\treturn None;\n\t\t\t};\n\n\t\t\tmatch self.ownership_graph.owner_of(obj_id)? {\n\t\t\t\tEntityId::Player(id) =\u003e {\n\t\t\t\t\tself.position_of_object(self.players.get(\u0026id)?.value())\n\t\t\t\t}\n\n\t\t\t\tEntityId::Object(id) =\u003e {\n\t\t\t\t\tself.position_of_object(self.objects.get(\u0026id)?.value())\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nimpl RelevanceIndex for Spatial2DIndex {\n\tfn relevant(\u0026self, entity: \u0026Entity, interest: Relevance) -\u003e Vec\u003cEntityId\u003e {\n\t\tif interest.is_none() {\n\t\t\treturn vec![];\n\t\t}\n\n\t\tlet query_start = Instant::now();\n\n\t\tlet Some((self_level, self_x, self_y)) = read_position(entity)\n\t\t\t.map(|(self_level, x, y)| calculate_hash(\u0026self.config, self_level, x, y))\n\t\telse {\n\t\t\treturn vec![];\n\t\t};\n\n\t\tlet mut output = FxHashSet::default();\n\n\t\tlet radius =\n\t\t\t(interest.value() * self.config.max_radius as f32).ceil() as i32;\n\n\t\tlet snapshot_read = self\n\t\t\t.snapshot_by_hash\n\t\t\t.read()\n\t\t\t.expect(\"bug: poisoned lock in spatial index\");\n\n\t\tlet Some(level_map) = snapshot_read.get(\u0026self_level) else {\n\t\t\treturn vec![];\n\t\t};\n\n\t\tfor delta_x in -radius..=radius {\n\t\t\tlet Some(y_map) = level_map.get(\u0026(self_x + delta_x)) else {\n\t\t\t\tcontinue;\n\t\t\t};\n\t\t\tfor relevant in y_map.range((self_y - radius)..=(self_y + radius)) {\n\t\t\t\toutput.extend(relevant.1.iter().copied());\n\t\t\t}\n\t\t}\n\n\t\thistogram!(\n\t\t\t\"index_spatial_query_duration\",\n\t\t\tquery_start.elapsed().as_micros() as f64\n\t\t);\n\n\t\tincrement_counter!(\"index_spatial_query_count\");\n\n\t\toutput.into_iter().collect()\n\t}\n\n\t/// Calculates an euclidean distance between two entities.\n\t/// If either of the two entities do not have the position attribute\n\t/// set, then None will be returned.\n\tfn relevance(\u0026self, a: \u0026Entity, b: \u0026Entity) -\u003e Relevance {\n\t\tlet Some((level_a, x_a, y_a)) = read_position(a)\n\t\t\t.map(|(level, x, y)| calculate_hash(\u0026self.config, level, x, y))\n\t\telse {\n\t\t\treturn Relevance::none();\n\t\t};\n\n\t\t// we are going to look for the first owner of the object\n\t\t// in the ownership graph that has a position attribute and\n\t\t// use that as the basis for caluclating the distance\n\t\tlet Some((level_b, x_b, y_b)) = self\n\t\t\t.position_of_object(b)\n\t\t\t.map(|(level, x, y)| calculate_hash(\u0026self.config, level, x, y))\n\t\telse {\n\t\t\treturn Relevance::none();\n\t\t};\n\n\t\t// if the two entities are not on the same level, then they are not relevant\n\t\tif level_a != level_b {\n\t\t\treturn Relevance::none();\n\t\t}\n\n\t\tlet manhattan_distance = (x_a - x_b).abs() + (y_a - y_b).abs();\n\t\tif manhattan_distance \u003e self.config.max_radius as i32 {\n\t\t\treturn Relevance::none();\n\t\t}\n\n\t\tlet distance = manhattan_distance as f32 / (self.config.max_radius as f32);\n\t\tlet relevance = (Relevance::max().value() * 1000.0) - (distance * 1000.0);\n\t\tlet relevance_rounded = relevance.round() / 1000.0;\n\t\tRelevance::new(relevance_rounded)\n\t}\n}\n\nfn calculate_hash(config: \u0026Config, level: i32, x: f64, y: f64) -\u003e SpatialHash {\n\tlet cell_size_x = config.map_width.div_ceil(config.cells_count_x) as f64;\n\tlet cell_size_y = config.map_height.div_ceil(config.cells_count_y) as f64;\n\t(level, (x / cell_size_x) as i32, (y / cell_size_y) as i32)\n}\n\nfn compute_new_snapshots(\n\tconfig: \u0026Config,\n\tplayers: \u0026PlayersState,\n\tobjects: \u0026ObjectsState,\n) -\u003e IndexSnapshot {\n\tlet mut new_version_by_hash = FxHashMap::\u003c\n\t\tLevelCoordinate,\n\t\tFxHashMap\u003cXCoordinate, BTreeMap\u003cYCoordinate, Vec\u003cEntityId\u003e\u003e\u003e,\n\t\u003e::default();\n\n\tlet mut index = |id, entity: \u0026Entity| {\n\t\tlet Some((level, x, y)) = read_position(entity) else {\n\t\t\treturn;\n\t\t};\n\n\t\tlet (level, x, y) = calculate_hash(config, level, x, y);\n\t\tlet btree = new_version_by_hash\n\t\t\t.entry(level)\n\t\t\t.or_default()\n\t\t\t.entry(x)\n\t\t\t.or_default();\n\t\tbtree.entry(y).or_default().push(id);\n\t};\n\n\tfor object in objects.iter() {\n\t\tindex(EntityId::Object(*object.key()), object.value());\n\t}\n\n\tfor player in players.iter() {\n\t\tindex(EntityId::Player(*player.key()), player.value());\n\t}\n\n\tnew_version_by_hash\n}\n\nfn read_position(entity: \u0026Entity) -\u003e Option\u003c(LevelCoordinate, f64, f64)\u003e {\n\tentity\n\t\t.attributes()\n\t\t.get(WellKnownAttribute::Position as AttributeId)\n\t\t.and_then(|value| match value {\n\t\t\tValue::Vec3((x, y, _)) | Value::Vec2((x, y)) =\u003e {\n\t\t\t\tSome((0, x as f64, y as f64))\n\t\t\t}\n\t\t\tValue::Vec4((x, y, _, level)) =\u003e {\n\t\t\t\tSome((level.round() as LevelCoordinate, x as f64, y as f64))\n\t\t\t}\n\t\t\tValue::Vec3d((x, y, _)) | Value::Vec2d((x, y)) =\u003e Some((0, x, y)),\n\t\t\tValue::Vec4d((x, y, _, level)) =\u003e {\n\t\t\t\tSome((level.round() as LevelCoordinate, x, y))\n\t\t\t}\n\t\t\t_ =\u003e None,\n\t\t})\n}\n\n#[cfg(test)]\nmod tests {\n\tuse {\n\t\tsuper::{Config, Spatial2DIndex},\n\t\tcrate::{\n\t\t\tglobal::PlayersState,\n\t\t\tobjects::ObjectsState,\n\t\t\trelevance::{Relevance, RelevanceIndex},\n\t\t\tstate::{\n\t\t\t\tentity::{AttributeId, AttributeValue, Entity},\n\t\t\t\tgraph::ObjectGraph,\n\t\t\t\tEntityId,\n\t\t\t},\n\t\t},\n\t\tquark_client_sdk::{Value, WellKnownAttribute},\n\t\tstd::{collections::HashSet, sync::Arc, time::Duration},\n\t};\n\n\t#[tokio::test]\n\tasync fn smoke() -\u003e anyhow::Result\u003c()\u003e {\n\t\tlet graph = Arc::\u003cObjectGraph\u003e::default();\n\t\tlet players = Arc::\u003cPlayersState\u003e::default();\n\t\tlet objects = Arc::\u003cObjectsState\u003e::default();\n\n\t\tplayers.insert(1, Entity::new(EntityId::Player(1)));\n\t\tplayers.insert(2, Entity::new(EntityId::Player(2)));\n\t\tplayers.insert(3, Entity::new(EntityId::Player(3)));\n\t\tplayers.insert(4, Entity::new(EntityId::Player(4)));\n\t\tplayers.insert(5, Entity::new(EntityId::Player(5)));\n\t\tplayers.insert(6, Entity::new(EntityId::Player(6)));\n\n\t\tlet player1 = players.get(\u00261).unwrap();\n\t\tlet player2 = players.get(\u00262).unwrap();\n\t\tlet player3 = players.get(\u00263).unwrap();\n\t\tlet player4 = players.get(\u00264).unwrap();\n\t\tlet player5 = players.get(\u00265).unwrap();\n\t\tlet player6 = players.get(\u00266).unwrap();\n\n\t\tlet index = Spatial2DIndex::new(\n\t\t\tConfig {\n\t\t\t\treindex_interval: Duration::from_millis(10),\n\t\t\t\t..Default::default()\n\t\t\t},\n\t\t\tArc::clone(\u0026graph),\n\t\t\tArc::clone(\u0026players),\n\t\t\tArc::clone(\u0026objects),\n\t\t);\n\n\t\tplayer1.attributes().push(\n\t\t\tWellKnownAttribute::Position as AttributeId,\n\t\t\tAttributeValue::new(Value::Vec3((1.0, 1.0, 1.0))),\n\t\t)?;\n\n\t\tplayer2.attributes().push(\n\t\t\tWellKnownAttribute::Position as AttributeId,\n\t\t\tAttributeValue::new(Value::Vec3((2.0, 2.0, 2.0))),\n\t\t)?;\n\n\t\t// player 3 has no position.\n\t\tplayer3.attributes().push(\n\t\t\tWellKnownAttribute::Rotation as AttributeId,\n\t\t\tAttributeValue::new(Value::Vec3((20000.0, 20000.0, 200.0))),\n\t\t)?;\n\n\t\t// player 4 is very far\n\t\tplayer4.attributes().push(\n\t\t\tWellKnownAttribute::Position as AttributeId,\n\t\t\tAttributeValue::new(Value::Vec3((900000.0, 900000.0, 200.0))),\n\t\t)?;\n\n\t\t// players 5 and 6 are on a different level\n\t\tplayer5.attributes().push(\n\t\t\tWellKnownAttribute::Position as AttributeId,\n\t\t\tAttributeValue::new(Value::Vec4((1.0, 1.0, 1.0, 2.0))),\n\t\t)?;\n\n\t\tplayer6.attributes().push(\n\t\t\tWellKnownAttribute::Position as AttributeId,\n\t\t\tAttributeValue::new(Value::Vec4((1.0, 1.0, 1.0, 2.0))),\n\t\t)?;\n\n\t\t// insert players and wait for the next iteration of indexing to happen\n\n\t\ttokio::time::sleep(Duration::from_millis(20)).await;\n\t\tassert!(index\n\t\t\t.snapshot_by_hash\n\t\t\t.read()\n\t\t\t.unwrap()\n\t\t\t.get(\u00260)\n\t\t\t.unwrap()\n\t\t\t.iter()\n\t\t\t.any(|(_, v)| {\n\t\t\t\tv.iter().any(|(_, k)| k.contains(\u0026EntityId::Player(1)))\n\t\t\t}));\n\n\t\ttokio::time::sleep(Duration::from_millis(20)).await;\n\t\tassert!(index\n\t\t\t.snapshot_by_hash\n\t\t\t.read()\n\t\t\t.unwrap()\n\t\t\t.get(\u00260)\n\t\t\t.unwrap()\n\t\t\t.iter()\n\t\t\t.any(|(_, v)| {\n\t\t\t\tv.iter().any(|(_, k)| k.contains(\u0026EntityId::Player(2)))\n\t\t\t}));\n\n\t\t// should not be inserted because it is missing position\n\t\ttokio::time::sleep(Duration::from_millis(20)).await;\n\t\tassert!(!index\n\t\t\t.snapshot_by_hash\n\t\t\t.read()\n\t\t\t.unwrap()\n\t\t\t.get(\u00260)\n\t\t\t.unwrap()\n\t\t\t.iter()\n\t\t\t.any(|(_, v)| {\n\t\t\t\tv.iter().any(|(_, k)| k.contains(\u0026EntityId::Player(3)))\n\t\t\t}));\n\n\t\ttokio::time::sleep(Duration::from_millis(20)).await;\n\t\tassert!(index\n\t\t\t.snapshot_by_hash\n\t\t\t.read()\n\t\t\t.unwrap()\n\t\t\t.get(\u00260)\n\t\t\t.unwrap()\n\t\t\t.iter()\n\t\t\t.any(|(_, v)| {\n\t\t\t\tv.iter().any(|(_, k)| k.contains(\u0026EntityId::Player(4)))\n\t\t\t}));\n\n\t\tassert_eq!(\n\t\t\tindex\n\t\t\t\t.relevant(\u0026player1, Relevance::max())\n\t\t\t\t.into_iter()\n\t\t\t\t.collect::\u003cHashSet\u003c_\u003e\u003e(),\n\t\t\tvec![EntityId::Player(1), EntityId::Player(2)]\n\t\t\t\t.into_iter()\n\t\t\t\t.collect::\u003cHashSet\u003c_\u003e\u003e()\n\t\t);\n\t\tassert_eq!(\n\t\t\tindex\n\t\t\t\t.relevant(\u0026player2, Relevance::max())\n\t\t\t\t.into_iter()\n\t\t\t\t.collect::\u003cHashSet\u003c_\u003e\u003e(),\n\t\t\tvec![EntityId::Player(1), EntityId::Player(2)]\n\t\t\t\t.into_iter()\n\t\t\t\t.collect::\u003cHashSet\u003c_\u003e\u003e()\n\t\t);\n\n\t\t// nobody,except self\n\t\tassert_eq!(index.relevant(\u0026player4, Relevance::max()), vec![\n\t\t\tEntityId::Player(4)\n\t\t]);\n\n\t\t// nothing\n\t\tassert_eq!(index.relevant(\u0026player4, Relevance::none()), vec![]);\n\n\t\t// distance smoke test\n\t\tassert_eq!(index.relevance(\u0026player1, \u0026player2), Relevance::max());\n\n\t\t// non-default level\n\t\tassert_eq!(index.relevance(\u0026player5, \u0026player6), Relevance::max());\n\t\tassert_eq!(index.relevance(\u0026player1, \u0026player5), Relevance::none());\n\n\t\tOk(())\n\t}\n\n\t#[tokio::test]\n\tasync fn distance_smoke() -\u003e anyhow::Result\u003c()\u003e {\n\t\tlet graph = Arc::\u003cObjectGraph\u003e::default();\n\t\tlet players = Arc::\u003cPlayersState\u003e::default();\n\t\tlet objects = Arc::\u003cObjectsState\u003e::default();\n\n\t\tplayers.insert(1, Entity::new(EntityId::Player(1)));\n\t\tplayers.insert(2, Entity::new(EntityId::Player(2)));\n\t\tplayers.insert(3, Entity::new(EntityId::Player(3)));\n\t\tplayers.insert(4, Entity::new(EntityId::Player(4)));\n\t\tplayers.insert(5, Entity::new(EntityId::Player(5)));\n\t\tplayers.insert(6, Entity::new(EntityId::Player(6)));\n\t\tplayers.insert(7, Entity::new(EntityId::Player(7)));\n\n\t\tlet player1 = players.get(\u00261).unwrap();\n\t\tlet player2 = players.get(\u00262).unwrap();\n\t\tlet player3 = players.get(\u00263).unwrap();\n\t\tlet player4 = players.get(\u00264).unwrap();\n\t\tlet player5 = players.get(\u00265).unwrap();\n\t\tlet player6 = players.get(\u00266).unwrap();\n\t\tlet player7 = players.get(\u00267).unwrap();\n\n\t\tlet index = Spatial2DIndex::new(\n\t\t\tConfig {\n\t\t\t\tmax_radius: 100,\n\t\t\t\tmap_width: 1000000,\n\t\t\t\tmap_height: 1000000,\n\t\t\t\tcells_count_x: 1000,\n\t\t\t\tcells_count_y: 1000,\n\t\t\t\treindex_interval: Duration::from_millis(10),\n\t\t\t},\n\t\t\tArc::clone(\u0026graph),\n\t\t\tArc::clone(\u0026players),\n\t\t\tArc::clone(\u0026objects),\n\t\t);\n\n\t\tplayer1.attributes().push(\n\t\t\tWellKnownAttribute::Position as AttributeId,\n\t\t\tAttributeValue::new(Value::Vec3((10.0, 10.0, 1.0))),\n\t\t)?;\n\n\t\tplayer2.attributes().push(\n\t\t\tWellKnownAttribute::Position as AttributeId,\n\t\t\tAttributeValue::new(Value::Vec3((20.0, 20.0, 2.0))),\n\t\t)?;\n\n\t\tplayer1.attributes().push(\n\t\t\tWellKnownAttribute::Position as AttributeId,\n\t\t\tAttributeValue::new(Value::Vec3((15.0, 20.0, 1.0))),\n\t\t)?;\n\n\t\tplayer2.attributes().push(\n\t\t\tWellKnownAttribute::Position as AttributeId,\n\t\t\tAttributeValue::new(Value::Vec3((30.0, 40.0, 2.0))),\n\t\t)?;\n\n\t\t// player 3 has no position.\n\t\tplayer3.attributes().push(\n\t\t\tWellKnownAttribute::Rotation as AttributeId,\n\t\t\tAttributeValue::new(Value::Vec3((20000.0, 20000.0, 200.0))),\n\t\t)?;\n\n\t\t// player 4 is using vec2 instead of vec3\n\t\t// and has the same position as player2\n\t\tplayer4.attributes().push(\n\t\t\tWellKnownAttribute::Position as AttributeId,\n\t\t\tAttributeValue::new(Value::Vec2((30.0, 40.0))),\n\t\t)?;\n\n\t\tplayer5.attributes().push(\n\t\t\tWellKnownAttribute::Position as AttributeId,\n\t\t\tAttributeValue::new(Value::Vec2((8000.0, 40.0))),\n\t\t)?;\n\n\t\tplayer6.attributes().push(\n\t\t\tWellKnownAttribute::Position as AttributeId,\n\t\t\tAttributeValue::new(Value::Vec2((92000.0, 40.0))),\n\t\t)?;\n\n\t\tplayer7.attributes().push(\n\t\t\tWellKnownAttribute::Position as AttributeId,\n\t\t\tAttributeValue::new(Value::Vec2((280001.0, 40.0))),\n\t\t)?;\n\n\t\t// wait for the next iteration of indexing to happen\n\t\ttokio::time::sleep(Duration::from_millis(20)).await;\n\n\t\t// missing position attribute\n\t\tassert!(index.relevance(\u0026player1, \u0026player3).is_none());\n\t\tassert!(index.relevance(\u0026player3, \u0026player1).is_none());\n\t\tassert!(index.relevance(\u0026player3, \u0026player2).is_none());\n\t\tassert!(index.relevance(\u0026player2, \u0026player3).is_none());\n\n\t\t// correct\n\t\tassert!(index.relevance(\u0026player1, \u0026player7).is_none());\n\t\tassert_eq!(index.relevance(\u0026player1, \u0026player2), Relevance::max());\n\t\tassert_eq!(index.relevance(\u0026player1, \u0026player5), Relevance::new(0.92));\n\t\tassert_eq!(index.relevance(\u0026player1, \u0026player6), Relevance::new(0.08));\n\t\tassert_eq!(index.relevance(\u0026player5, \u0026player6), Relevance::new(0.16));\n\n\t\t// commutative\n\t\tassert_eq!(\n\t\t\tindex.relevance(\u0026player2, \u0026player1),\n\t\t\tindex.relevance(\u0026player1, \u0026player2)\n\t\t);\n\n\t\t// vec2 vs vec3\n\t\tassert_eq!(index.relevance(\u0026player1, \u0026player4), Relevance::max());\n\n\t\t// irrelevant\n\t\tassert_eq!(index.relevance(\u0026player6, \u0026player7), Relevance::none());\n\n\t\t// zero distance\n\t\tassert_eq!(index.relevance(\u0026player2, \u0026player4), Relevance::max());\n\t\tassert_eq!(index.relevance(\u0026player4, \u0026player2), Relevance::max());\n\n\t\tOk(())\n\t}\n\n\t#[tokio::test]\n\tasync fn bug_caused_by_invalid_defaut_params() -\u003e anyhow::Result\u003c()\u003e {\n\t\tlet graph = Arc::\u003cObjectGraph\u003e::default();\n\t\tlet players = Arc::\u003cPlayersState\u003e::default();\n\t\tlet objects = Arc::\u003cObjectsState\u003e::default();\n\n\t\tplayers.insert(1, Entity::new(EntityId::Player(1)));\n\t\tplayers.insert(2, Entity::new(EntityId::Player(2)));\n\n\t\tlet player1 = players.get(\u00261).unwrap();\n\t\tlet player2 = players.get(\u00262).unwrap();\n\n\t\tlet index = Spatial2DIndex::new(\n\t\t\tConfig {\n\t\t\t\tmax_radius: 4,\n\t\t\t\tmap_width: 40000,\n\t\t\t\tmap_height: 40000,\n\t\t\t\tcells_count_x: 40,\n\t\t\t\tcells_count_y: 40,\n\t\t\t\treindex_interval: Duration::from_millis(10),\n\t\t\t},\n\t\t\tArc::clone(\u0026graph),\n\t\t\tArc::clone(\u0026players),\n\t\t\tArc::clone(\u0026objects),\n\t\t);\n\n\t\tplayer1.attributes().push(\n\t\t\tWellKnownAttribute::Position as AttributeId,\n\t\t\tAttributeValue::new(Value::Vec3((1127.057, 1504.4, 90.15))),\n\t\t)?;\n\n\t\tplayer2.attributes().push(\n\t\t\tWellKnownAttribute::Position as AttributeId,\n\t\t\tAttributeValue::new(Value::Vec3((-1000.387, -782.654, 90.15))),\n\t\t)?;\n\n\t\ttokio::time::sleep(Duration::from_millis(50)).await;\n\t\tassert!(index\n\t\t\t.snapshot_by_hash\n\t\t\t.read()\n\t\t\t.unwrap()\n\t\t\t.get(\u00260)\n\t\t\t.unwrap()\n\t\t\t.iter()\n\t\t\t.any(|(_, v)| {\n\t\t\t\tv.iter().any(|(_, k)| k.contains(\u0026EntityId::Player(1)))\n\t\t\t}));\n\n\t\ttokio::time::sleep(Duration::from_millis(50)).await;\n\t\tassert!(index\n\t\t\t.snapshot_by_hash\n\t\t\t.read()\n\t\t\t.unwrap()\n\t\t\t.get(\u00260)\n\t\t\t.unwrap()\n\t\t\t.iter()\n\t\t\t.any(|(_, v)| {\n\t\t\t\tv.iter().any(|(_, k)| k.contains(\u0026EntityId::Player(2)))\n\t\t\t}));\n\n\t\tassert_eq!(\n\t\t\tindex\n\t\t\t\t.relevant(\u0026player1, Relevance::max())\n\t\t\t\t.into_iter()\n\t\t\t\t.collect::\u003cHashSet\u003c_\u003e\u003e(),\n\t\t\tvec![EntityId::Player(1), EntityId::Player(2)]\n\t\t\t\t.into_iter()\n\t\t\t\t.collect::\u003cHashSet\u003c_\u003e\u003e()\n\t\t);\n\n\t\tassert!(index\n\t\t\t.relevant(\u0026player1, Relevance::none())\n\t\t\t.into_iter()\n\t\t\t.collect::\u003cHashSet\u003c_\u003e\u003e()\n\t\t\t.is_empty());\n\n\t\tassert_eq!(\n\t\t\tindex\n\t\t\t\t.relevant(\u0026player2, Relevance::max())\n\t\t\t\t.into_iter()\n\t\t\t\t.collect::\u003cHashSet\u003c_\u003e\u003e(),\n\t\t\tvec![EntityId::Player(2), EntityId::Player(1)]\n\t\t\t\t.into_iter()\n\t\t\t\t.collect::\u003cHashSet\u003c_\u003e\u003e()\n\t\t);\n\n\t\tassert!(index\n\t\t\t.relevant(\u0026player2, Relevance::none())\n\t\t\t.into_iter()\n\t\t\t.collect::\u003cHashSet\u003c_\u003e\u003e()\n\t\t\t.is_empty());\n\t\tOk(())\n\t}\n}\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":664},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":664},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":122},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":122},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":122},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":122},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":122},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":122},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":122},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":244},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":122},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":122},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":122},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":122},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":2776},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":2654},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":1327},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":1327},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":1327},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":1855},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":2814},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":1790},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":891},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":1782},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":2936},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":2936},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":2933},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":2236},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":2236},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":697},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":2049},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":187},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":99905},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":102020},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":97790},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":4230},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":2115},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":2049},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":2049},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":2049},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":978},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":1941},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":2919},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":959},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":959},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":958},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":958},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":956},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":956},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":956},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":956},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":6926},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":6926},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":6926},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":6926},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":1327},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":1327},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":1327},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":1327},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":1327},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":5941},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":7382},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":1846},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":4657},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":1665},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":7225},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":2949},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":1327},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":10380},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":10380},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":10380},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":17306},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":6641},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":6641},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":81},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":81},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":408},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":86,"coverable":91},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","replication","file","consumer.rs"],"content":"use {\n\tsuper::producer::{recover_attributes, recover_entity, ENTITY_ATTR_SIZE},\n\tcrate::{\n\t\tglobal::GlobalState,\n\t\tstate::{object::ObjectEntity, player::PlayerEntity, EntityId},\n\t},\n\tbytes::Buf,\n\tstd::{\n\t\tfs::File,\n\t\tio::{Cursor, Read, Seek, SeekFrom},\n\t\tpath::Path,\n\t\tsync::Arc,\n\t\ttime::{Duration, SystemTime, UNIX_EPOCH},\n\t},\n\ttracing::{info, trace, warn},\n\turl::Url,\n};\n\npub struct Consumer {}\n\nimpl Consumer {\n\t/// This consumer recovers objects only that were saved to disk, players are\n\t/// recovered through producer and are done as players connect.\n\t///\n\t/// Resumable sessions are also recovered here.\n\tpub fn start(url: Url, global: Arc\u003cGlobalState\u003e) {\n\t\tlet path = url.to_file_path().expect(\"file path\");\n\t\tinfo!(\"file replication from: {}\", path.display());\n\n\t\tfill_resumable_sessions(\u0026path, \u0026global);\n\t\tfill_objects(\u0026path, \u0026global);\n\t}\n}\n\nfn fill_resumable_sessions(path: \u0026Path, global: \u0026Arc\u003cGlobalState\u003e) {\n\t// Entry size on file.\n\t// 0..3: player ID\n\t// 4..19: resume token\n\tconst ENTRY_SIZE: usize = 4 + 16 + ENTITY_ATTR_SIZE;\n\n\t// try to recover resumable sessions.\n\tlet mut f = match File::open(path.join(\"resume.data\")) {\n\t\tOk(f) =\u003e f,\n\t\tErr(e) =\u003e {\n\t\t\twarn!(\"can't open resume.data: {e}\");\n\t\t\treturn;\n\t\t}\n\t};\n\n\tlet mut buffer = vec![];\n\tif let Err(e) = f.read_to_end(\u0026mut buffer) {\n\t\twarn!(\"failed to read resumable sessions: {e}\");\n\t\treturn;\n\t}\n\n\tlet mut buffer = Cursor::new(buffer);\n\tlet heartbeat =\n\t\tDuration::from_secs(buffer.get_u64()) + global.profile().resume_timeout;\n\tlet now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap();\n\tif now \u003e heartbeat {\n\t\twarn!(\n\t\t\t\"not recovering resumable sessions, diff: {:?}\",\n\t\t\tnow.saturating_sub(heartbeat)\n\t\t);\n\t\treturn;\n\t}\n\n\tlet size = buffer.remaining();\n\tlet slots =\n\t\t(size / ENTRY_SIZE) + if (size % ENTRY_SIZE) != 0 { 1 } else { 0 };\n\tlet mut token = [0u8; 16];\n\tfor slot in 0..slots {\n\t\tif let Err(e) =\n\t\t\tbuffer.seek(SeekFrom::Start(8 + slot as u64 * ENTRY_SIZE as u64))\n\t\t{\n\t\t\twarn!(\"failed to seek to resumable slot {slot}: {e}\");\n\t\t\treturn;\n\t\t}\n\n\t\tlet id = buffer.get_u32();\n\t\tbuffer.copy_to_slice(\u0026mut token[..]);\n\n\t\tmatch String::from_utf8(token.to_vec()) {\n\t\t\tOk(token) =\u003e {\n\t\t\t\tlet player = PlayerEntity::new(EntityId::Player(id));\n\t\t\t\tif recover_attributes::\u003c_, 0\u003e(\u0026mut buffer, player.attributes()) {\n\t\t\t\t\ttrace!(\"recovered resumable session {id} {token}\");\n\t\t\t\t\tglobal.resumes().park_raw_session(id, token, player);\n\t\t\t\t}\n\t\t\t}\n\t\t\tErr(e) =\u003e {\n\t\t\t\twarn!(\"failed to convert token ({token:?}) to utf8: {e}\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nfn fill_objects(path: \u0026Path, global: \u0026Arc\u003cGlobalState\u003e) {\n\tlet mut f = match File::open(path.join(\"objects.data\")) {\n\t\tOk(f) =\u003e f,\n\t\tErr(e) =\u003e {\n\t\t\twarn!(\"Not recovering objects; no object file data: {e}\");\n\t\t\treturn;\n\t\t}\n\t};\n\n\tlet mut buffer = vec![];\n\tlet size = match f.read_to_end(\u0026mut buffer) {\n\t\tOk(size) =\u003e size,\n\t\tErr(e) =\u003e {\n\t\t\twarn!(\"failed to read objects: {e}\");\n\t\t\treturn;\n\t\t}\n\t};\n\n\tconst ENTRY_SIZE: usize = 8 + ENTITY_ATTR_SIZE;\n\tlet slots = size / ENTRY_SIZE + if (size % ENTRY_SIZE) != 0 { 1 } else { 0 };\n\tlet mut buffer = Cursor::new(buffer);\n\tfor slot in 0..slots {\n\t\tif let Err(e) =\n\t\t\tbuffer.seek(SeekFrom::Start(slot as u64 * ENTRY_SIZE as u64))\n\t\t{\n\t\t\twarn!(\"failed to seek into consumer buffer: {e}\");\n\t\t\treturn;\n\t\t}\n\n\t\tlet id = buffer.get_u64();\n\t\tif id == 0 {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet object = ObjectEntity::new(EntityId::Object(id));\n\t\tif !recover_entity::\u003c_, 8\u003e(slot as u32, \u0026mut buffer, object.attributes()) {\n\t\t\twarn!(\"failed to recover object of id {id} at {slot}\");\n\t\t\treturn;\n\t\t}\n\n\t\tglobal.objects().entry(id).insert(object);\n\t\ttrace!(\"recovered object {id} at {slot}\");\n\t}\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":5},"fn_name":null}],"covered":38,"coverable":64},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","replication","file","idmapping.rs"],"content":"use {\n\tparking_lot::{FairMutex, RwLock},\n\tstd::collections::VecDeque,\n};\n\npub struct IdMapping {\n\tslots: RwLock\u003cVec\u003cu64\u003e\u003e,\n\tfree_slots: FairMutex\u003cVecDeque\u003cu32\u003e\u003e,\n}\n\nimpl IdMapping {\n\tpub fn new() -\u003e Self {\n\t\tSelf {\n\t\t\tslots: RwLock::default(),\n\t\t\tfree_slots: FairMutex::default(),\n\t\t}\n\t}\n\n\t/// Maps ID into a free slot.\n\t/// Re-uses a slot if there is a free unused one.\n\tpub fn map(\u0026self, id: u64) -\u003e u32 {\n\t\tlet mut slots = self.slots.write();\n\t\tlet mut free_slots = self.free_slots.lock();\n\t\tif let Some(slot) = free_slots.pop_front() {\n\t\t\tslots[slot as usize] = id;\n\t\t\tslot\n\t\t} else {\n\t\t\tlet slot = slots.len() as u32;\n\t\t\tif id == 0 {\n\t\t\t\t// mark as free slot.\n\t\t\t\tfree_slots.push_back(slot);\n\t\t\t}\n\n\t\t\tslots.push(id);\n\t\t\tslot\n\t\t}\n\t}\n\n\t/// Maps ID into a free slot.\n\t/// Does not re-use a slot if there is a free unused one.\n\tpub fn map_noreuse(\u0026self, id: u64) -\u003e u32 {\n\t\tlet mut slots = self.slots.write();\n\t\tlet slot = slots.len() as u32;\n\t\tif id == 0 {\n\t\t\t// mark as free slot.\n\t\t\tself.free_slots.lock().push_back(slot);\n\t\t}\n\n\t\tslots.push(id);\n\t\tslot\n\t}\n\n\t#[cfg(test)]\n\tpub fn free_slots(\u0026self) -\u003e Vec\u003cu32\u003e {\n\t\tlet free_slots = self.free_slots.lock();\n\t\tlet mut v = Vec::with_capacity(free_slots.len());\n\t\tfor slot in \u0026*free_slots {\n\t\t\tv.push(*slot);\n\t\t}\n\n\t\tv\n\t}\n\n\t/// Gets ID for a slot.\n\t#[cfg(test)]\n\tpub fn get(\u0026self, slot: u32) -\u003e Option\u003cu64\u003e {\n\t\tlet slots = self.slots.read();\n\t\tlet slot = slot as usize;\n\t\tif slot \u003c slots.len() {\n\t\t\tSome(slots[slot])\n\t\t} else {\n\t\t\tNone\n\t\t}\n\t}\n\n\t/// Gets the slot for an already mapped ID.\n\t/// FIXME: perhaps some lookup cache could be useful?\n\tpub fn slot(\u0026self, id: u64) -\u003e Option\u003cu32\u003e {\n\t\tlet slots = self.slots.read();\n\t\tif slots.is_empty() {\n\t\t\treturn None;\n\t\t}\n\n\t\tlet mut front = 0;\n\t\tlet mut back = slots.len() - 1;\n\t\tif front == back {\n\t\t\t// only 1 entry...\n\t\t\tif slots[0] == id {\n\t\t\t\treturn Some(0);\n\t\t\t} else {\n\t\t\t\treturn None;\n\t\t\t}\n\t\t}\n\n\t\twhile front \u003c= back {\n\t\t\tif slots[front] == id {\n\t\t\t\treturn Some(front as u32);\n\t\t\t}\n\n\t\t\tif slots[back] == id {\n\t\t\t\treturn Some(back as u32);\n\t\t\t}\n\n\t\t\tfront += 1;\n\t\t\tback -= 1;\n\t\t}\n\n\t\tNone\n\t}\n}\n\n#[cfg(test)]\nmod test {\n\tuse super::*;\n\n\t#[test]\n\tfn idmapping_smoke() {\n\t\tlet idmap = IdMapping::new();\n\t\tlet mut mapped = Vec::with_capacity(100);\n\t\tfor i in 0..=100 {\n\t\t\tmapped.push(idmap.map_noreuse(100 - i));\n\t\t}\n\n\t\tfor (i, mapped) in mapped.iter().enumerate() {\n\t\t\tassert_eq!(i as u32, *mapped);\n\t\t\tassert_eq!(idmap.slot(i as u64), Some(100 - i as u32));\n\t\t}\n\n\t\tassert_eq!(idmap.map_noreuse(101), 101);\n\t\tassert_eq!(idmap.get(101), Some(101));\n\t\tassert_eq!(idmap.slot(101), Some(101));\n\t}\n\n\t#[test]\n\tfn idmapping_reuse() {\n\t\tlet idmap = IdMapping::new();\n\t\tlet map = vec![1, 0, 5, 0, 7, 0, 8, 0, 10, 0];\n\t\tlet mut slots = vec![0; 10];\n\t\tfor i in map {\n\t\t\tslots.push(idmap.map_noreuse(i));\n\t\t}\n\n\t\tlet free_slots = idmap.free_slots();\n\t\tassert_eq!(free_slots.len(), 5);\n\t\tfor i in free_slots {\n\t\t\tassert_eq!(idmap.map(i as u64 + 0xff), i);\n\t\t\tassert_eq!(idmap.slot(i as u64 + 0xff), Some(i));\n\t\t}\n\t}\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":49},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":135},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":135},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":135},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":135},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":135},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":205},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":205},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":205},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":196},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":196},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":196},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":2732},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":2712},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":2652},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":94},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":2558},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":2558},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":20},"fn_name":null}],"covered":47,"coverable":49},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","replication","file","mod.rs"],"content":"mod consumer;\nmod idmapping;\nmod producer;\n\npub use {consumer::Consumer, producer::Producer};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","replication","file","producer.rs"],"content":"use {\n\tsuper::idmapping::IdMapping,\n\tcrate::{\n\t\tevents::Event,\n\t\treplication,\n\t\tstate::{\n\t\t\tentity::{\n\t\t\t\tAttributeChange,\n\t\t\t\tAttributesMap,\n\t\t\t\tEntity,\n\t\t\t\tEntityChanges,\n\t\t\t\tMAX_ATTRIBUTES,\n\t\t\t},\n\t\t\tobject::ObjectId,\n\t\t\tplayer::PlayerId,\n\t\t\tDespawnedEntity,\n\t\t\tEntityId,\n\t\t\tTimestampedVal,\n\t\t},\n\t},\n\tdashmap::DashMap,\n\tfxhash::FxBuildHasher,\n\tnum_traits::ToBytes,\n\tparking_lot::FairMutex,\n\tquark_client_sdk::{Recipient, Value},\n\tstd::{\n\t\tcollections::HashMap,\n\t\tfs::File,\n\t\tio::{Cursor, Read, Seek, SeekFrom, Write},\n\t\tpath::{Path, PathBuf},\n\t\tstr::FromStr,\n\t\tsync::Arc,\n\t\ttime::{Duration, SystemTime, UNIX_EPOCH},\n\t},\n\tthiserror::Error,\n\ttracing::{error, info, trace, warn},\n\turl::Url,\n};\n\n#[derive(Debug, Error)]\npub enum Error {\n\t#[error(\"can't open file {0}\")]\n\tFileOpen(std::io::Error),\n\n\t#[error(\"File metadata\")]\n\tFileMetadata(std::io::Error),\n\n\t#[error(\"error during idmap cache\")]\n\tIdMapCache(std::io::Error),\n\n\t#[error(\"attribute map cache\")]\n\tAttrMapCache(std::io::Error),\n\n\t#[error(\"bad replication path\")]\n\tBadReplicationPath,\n}\n\n/// Resumable sessions cache\n///  Key = (PlayerId, Slot)\n///  Value = (Token, Attributes)\ntype ResumeMap = HashMap\u003c(u32, u32), ([u8; 16], AttributesMap)\u003e;\n\npub struct Producer {\n\treplications: [Arc\u003cFileReplication\u003e; 2],\n\tresumes: Arc\u003cFairMutex\u003cResumeMap\u003e\u003e,\n}\n\nimpl Producer {\n\tpub fn new(endpoints: \u0026[Url]) -\u003e Result\u003cSelf, Error\u003e {\n\t\tlet mut delay = Duration::from_secs(1);\n\t\tlet endpoint = \u0026endpoints[0];\n\t\tendpoint.query_pairs().for_each(|(k, v)| {\n\t\t\tif let (\"delay\", str) = (k.as_ref(), v.as_ref()) {\n\t\t\t\tif let Ok(d) = humantime::Duration::from_str(str) {\n\t\t\t\t\tdelay = *d;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tlet path = endpoint\n\t\t\t.to_file_path()\n\t\t\t.map_err(|_| Error::BadReplicationPath)?;\n\t\tinfo!(\n\t\t\t\"file replication to: {} save delay set to: {delay:?}\",\n\t\t\tpath.display()\n\t\t);\n\n\t\tlet replications = [\n\t\t\tArc::new(FileReplication::new::\u003c4\u003e(\n\t\t\t\t\u0026path,\n\t\t\t\t\"players\".to_owned(),\n\t\t\t\tfalse,\n\t\t\t)?),\n\t\t\tArc::new(FileReplication::new::\u003c8\u003e(\n\t\t\t\t\u0026path,\n\t\t\t\t\"objects\".to_owned(),\n\t\t\t\ttrue,\n\t\t\t)?),\n\t\t];\n\n\t\ttokio::spawn(write_replication_cache(Arc::clone(\u0026replications[0]), delay));\n\t\ttokio::spawn(write_replication_cache(Arc::clone(\u0026replications[1]), delay));\n\n\t\tlet resumes = Arc::new(FairMutex::new(HashMap::new()));\n\t\ttokio::spawn(write_resumes(\n\t\t\tArc::clone(\u0026resumes),\n\t\t\tdelay,\n\t\t\tpath.join(\"resume.data\"),\n\t\t));\n\n\t\tOk(Self {\n\t\t\treplications,\n\t\t\tresumes,\n\t\t})\n\t}\n}\n\nimpl replication::Producer for Producer {\n\tfn entity(\n\t\t\u0026self,\n\t\tid: EntityId,\n\t\tchanges: \u0026EntityChanges,\n\t\tentity: \u0026Entity,\n\t\t_author: PlayerId,\n\t) {\n\t\tlet eattrs = match id {\n\t\t\tEntityId::Object(id) =\u003e {\n\t\t\t\tlet r = \u0026self.replications[1];\n\t\t\t\tlet Some(slot) = r.idmap.slot(id) else {\n\t\t\t\t\treturn;\n\t\t\t\t};\n\n\t\t\t\tlet Some(v) = r.cache.get(\u0026ReplicatedEntity::Object(id, slot)) else {\n\t\t\t\t\treturn;\n\t\t\t\t};\n\n\t\t\t\tv\n\t\t\t}\n\t\t\tEntityId::Player(id) =\u003e {\n\t\t\t\tlet r = \u0026self.replications[0];\n\t\t\t\tlet Some(slot) = r.idmap.slot(id as u64) else {\n\t\t\t\t\treturn;\n\t\t\t\t};\n\n\t\t\t\tlet Some(v) = r.cache.get(\u0026ReplicatedEntity::Player(id, slot)) else {\n\t\t\t\t\treturn;\n\t\t\t\t};\n\n\t\t\t\tv\n\t\t\t}\n\t\t};\n\n\t\tfor (attribute_id, change) in changes.attributes.iter() {\n\t\t\tif *change == AttributeChange::None {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif let Some(TimestampedVal(value, version)) =\n\t\t\t\tentity.attributes().get_with_timestamp(*attribute_id)\n\t\t\t{\n\t\t\t\t// Unwrapping here is not an issue since we use the same map.\n\t\t\t\teattrs.try_set(*attribute_id, value, version).unwrap();\n\t\t\t}\n\t\t}\n\t}\n\n\tfn event(\u0026self, _: \u0026Event, _: \u0026Recipient) {\n\t\t// not implemented for file producers\n\t}\n\n\tfn spawn(\u0026self, entity_id: EntityId, entity: \u0026Entity) {\n\t\tmatch entity_id {\n\t\t\tEntityId::Object(id) =\u003e {\n\t\t\t\tlet r = \u0026self.replications[1];\n\n\t\t\t\t// Object recovery is made in consumer during startup only.\n\t\t\t\t// Objects aren't recovered in runtime since despawn causes them\n\t\t\t\t// to be cleared from disk.\n\t\t\t\t//\n\t\t\t\t// Here we only cache the attributes.\n\t\t\t\tlet eattrs = AttributesMap::default();\n\t\t\t\tentity.attributes().iter(|k, v| {\n\t\t\t\t\teattrs.try_set(*k, v.get(), v.timestamp()).unwrap();\n\t\t\t\t});\n\n\t\t\t\tlet slot = r.idmap.slot(id).unwrap_or(r.idmap.map(id));\n\t\t\t\tr.cache.insert(ReplicatedEntity::Object(id, slot), eattrs);\n\t\t\t}\n\t\t\tEntityId::Player(id) =\u003e {\n\t\t\t\tlet r = \u0026self.replications[0];\n\n\t\t\t\tlet slot = {\n\t\t\t\t\tif let Some(slot) = r.idmap.slot(id as u64) {\n\t\t\t\t\t\t// try to recover from cache first:\n\t\t\t\t\t\tif let Some(eattrs) =\n\t\t\t\t\t\t\tr.cache.get(\u0026ReplicatedEntity::Player(id, slot))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\teattrs.iter(|k, v| {\n\t\t\t\t\t\t\t\t// Same attribute count is used, so unwrap() is OK.\n\t\t\t\t\t\t\t\tentity\n\t\t\t\t\t\t\t\t\t.attributes()\n\t\t\t\t\t\t\t\t\t.try_set(*k, v.get(), v.timestamp())\n\t\t\t\t\t\t\t\t\t.unwrap();\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\ttrace!(\"Recovered existing player (via cache) of id {id}\");\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet lock = r.file.lock();\n\t\t\t\t\t\tlet mut f = \u0026*lock;\n\t\t\t\t\t\tif recover_entity::\u003c_, 4\u003e(slot, \u0026mut f, entity.attributes()) {\n\t\t\t\t\t\t\ttrace!(\"Recovered existing player (via file) of id {id}\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tslot\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr.idmap.map(id as u64)\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tlet eattrs = AttributesMap::default();\n\t\t\t\tentity.attributes().iter(|k, v| {\n\t\t\t\t\teattrs.try_set(*k, v.get(), v.timestamp()).unwrap();\n\t\t\t\t});\n\n\t\t\t\tr.cache.insert(ReplicatedEntity::Player(id, slot), eattrs);\n\t\t\t}\n\t\t}\n\t}\n\n\tfn despawn(\u0026self, entity: DespawnedEntity) {\n\t\tmatch entity {\n\t\t\tDespawnedEntity::Object(id) =\u003e {\n\t\t\t\tlet r = \u0026self.replications[1];\n\t\t\t\tif let Some(slot) = r.idmap.slot(id) {\n\t\t\t\t\tlet _ = r.cache.remove(\u0026ReplicatedEntity::Object(id, slot));\n\n\t\t\t\t\tlet lock = r.file.lock();\n\t\t\t\t\tlet mut f = \u0026*lock;\n\t\t\t\t\tclear_attributes::\u003c_, 8\u003e(slot, \u0026mut f);\n\t\t\t\t}\n\t\t\t}\n\t\t\tDespawnedEntity::Player(id, resume_token) =\u003e {\n\t\t\t\tlet r = \u0026self.replications[0];\n\t\t\t\tif let Some(slot) = r.idmap.slot(id as u64) {\n\t\t\t\t\tlet lock = r.file.lock();\n\t\t\t\t\tlet mut f = \u0026*lock;\n\n\t\t\t\t\tlet eattrs = AttributesMap::default();\n\t\t\t\t\trecover_entity::\u003c_, 4\u003e(slot, \u0026mut f, \u0026eattrs);\n\n\t\t\t\t\tif let Some((_, cached_attrs)) =\n\t\t\t\t\t\tr.cache.remove(\u0026ReplicatedEntity::Player(id, slot))\n\t\t\t\t\t{\n\t\t\t\t\t\t// cache might have new attributes, overwrite them.\n\t\t\t\t\t\tcached_attrs.iter(|k, v| {\n\t\t\t\t\t\t\teattrs.try_set(*k, v.get(), v.timestamp()).unwrap();\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tself.resumes.lock().insert(\n\t\t\t\t\t\t(id, slot),\n\t\t\t\t\t\t(resume_token.as_bytes().try_into().unwrap(), eattrs),\n\t\t\t\t\t);\n\n\t\t\t\t\tclear_attributes::\u003c_, 4\u003e(slot, \u0026mut f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n#[derive(Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash)]\nenum ReplicatedEntity {\n\tObject(ObjectId, u32),\n\tPlayer(PlayerId, u32),\n}\n\npub(super) const ATTR_SIZE: usize = core::mem::size_of::\u003cTimestampedVal\u003e();\npub(super) const ENTITY_ATTR_SIZE: usize = ATTR_SIZE * MAX_ATTRIBUTES;\n\nstruct FileReplication {\n\tfile: FairMutex\u003cFile\u003e,\n\tcache: DashMap\u003cReplicatedEntity, AttributesMap, FxBuildHasher\u003e,\n\tidmap: IdMapping,\n}\n\nimpl FileReplication {\n\tfn new\u003cconst ID_SIZE: usize\u003e(\n\t\tpath: \u0026Path,\n\t\tprefix: String,\n\t\tpopulate_object_cache: bool,\n\t) -\u003e Result\u003cSelf, Error\u003e {\n\t\tlet mut file = File::options()\n\t\t\t.read(true)\n\t\t\t.write(true)\n\t\t\t.create(true)\n\t\t\t.truncate(false)\n\t\t\t.open(path.join(prefix + \".data\"))\n\t\t\t.map_err(Error::FileOpen)?;\n\n\t\tlet entry_size = (ID_SIZE + ENTITY_ATTR_SIZE) as u64;\n\t\tlet size = file.metadata().map_err(Error::FileMetadata)?.len();\n\t\tlet slots =\n\t\t\t(size / entry_size) + if (size % entry_size) != 0 { 1 } else { 0 };\n\n\t\tlet mut attributes = Vec::\u003cTimestampedVal\u003e::with_capacity(MAX_ATTRIBUTES);\n\t\tattributes.resize(MAX_ATTRIBUTES, Default::default());\n\n\t\tlet b = unsafe {\n\t\t\tlet ptr = attributes.as_mut_ptr() as *mut u8;\n\t\t\tcore::slice::from_raw_parts_mut(\n\t\t\t\tptr,\n\t\t\t\tattributes.len() * core::mem::size_of::\u003cValue\u003e(),\n\t\t\t)\n\t\t};\n\n\t\tlet cache = DashMap::default();\n\t\tlet idmap = IdMapping::new();\n\t\tlet mut idbuf = [0u8; ID_SIZE];\n\t\tfor slot in 0..slots {\n\t\t\tif let Err(e) = file.seek(SeekFrom::Start(slot * entry_size)) {\n\t\t\t\treturn Err(Error::IdMapCache(e));\n\t\t\t}\n\n\t\t\tif let Err(e) = file.read_exact(\u0026mut idbuf) {\n\t\t\t\treturn Err(Error::IdMapCache(e));\n\t\t\t}\n\n\t\t\t// Figure out the entity id.\n\t\t\tlet id = match ID_SIZE {\n\t\t\t\t4 =\u003e u32::from_be_bytes(idbuf[0..4].try_into().unwrap()) as u64,\n\t\t\t\t8 =\u003e u64::from_be_bytes(idbuf[0..8].try_into().unwrap()),\n\t\t\t\t_ =\u003e panic!(\"bad id size\"),\n\t\t\t};\n\n\t\t\t// We cannot re-use the entity entry here because we will end up\n\t\t\t// with zeroes if the entity gets recovered during spawn(), and then we\n\t\t\t// will have problems zero-ing out the entry that replaced the re-used\n\t\t\t// entry.\n\t\t\tlet slot = idmap.map_noreuse(id);\n\t\t\tif id == 0 {\n\t\t\t\t// id 0 is free slot.\n\t\t\t\tif populate_object_cache {\n\t\t\t\t\t// Insert empty cache entry.\n\t\t\t\t\t// This is because spawn() won't be called for this object, so the\n\t\t\t\t\t// cache entry must be created here.\n\t\t\t\t\tcache.insert(\n\t\t\t\t\t\tReplicatedEntity::Object(id, slot),\n\t\t\t\t\t\tAttributesMap::default(),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// populate cache from attributes if needed.\n\t\t\tif populate_object_cache {\n\t\t\t\tif let Err(e) = file.read(\u0026mut b[..]) {\n\t\t\t\t\treturn Err(Error::AttrMapCache(e));\n\t\t\t\t}\n\n\t\t\t\tlet attrs = AttributesMap::default();\n\t\t\t\tfor (i, value) in attributes.iter().enumerate() {\n\t\t\t\t\tlet value = value.clone();\n\t\t\t\t\tif value.0 == Value::None {\n\t\t\t\t\t\t// Avoid none values since the entity is fresh and no attributes\n\t\t\t\t\t\t// have been touched yet in the entity.\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif let Err(e) = attrs.try_set(i as u16, value.0, value.1) {\n\t\t\t\t\t\t// Possible change in attribute map definition\n\t\t\t\t\t\twarn!(\"failed to recover attribute: {i}: {e}\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttrace!(\"populate object cache {id} {slot}\");\n\t\t\t\tcache.insert(ReplicatedEntity::Object(id, slot), attrs);\n\t\t\t}\n\t\t}\n\n\t\t// seek back to start\n\t\tif let Err(e) = file.seek(SeekFrom::Start(0)) {\n\t\t\treturn Err(Error::IdMapCache(e));\n\t\t}\n\n\t\tOk(Self {\n\t\t\tfile: FairMutex::new(file),\n\t\t\tcache,\n\t\t\tidmap,\n\t\t})\n\t}\n}\n\n/// This function periodically clear resumable sessions cache and writes\n/// it to disk.\nasync fn write_resumes(\n\tresumes: Arc\u003cFairMutex\u003cResumeMap\u003e\u003e,\n\tdelay: Duration,\n\tpath: PathBuf,\n) {\n\t// Entry size on file.\n\t// 0..3: player ID\n\t// 4..19: resume token\n\tconst ENTRY_SIZE: u64 = 4 + 16 + ENTITY_ATTR_SIZE as u64;\n\n\tlet mut file = File::options()\n\t\t.write(true)\n\t\t.create(true)\n\t\t.truncate(true)\n\t\t.open(path)\n\t\t.expect(\"resume file open\");\n\n\tloop {\n\t\ttokio::time::sleep(delay).await;\n\n\t\tlet mut lock = resumes.lock();\n\t\tlet sessions = std::mem::take(\u0026mut *lock);\n\t\tdrop(lock);\n\n\t\tif let Err(e) = file.seek(SeekFrom::Start(0)) {\n\t\t\twarn!(\"failed to seek to beginning: {e}\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet now = SystemTime::now()\n\t\t\t.duration_since(UNIX_EPOCH)\n\t\t\t.unwrap()\n\t\t\t.as_secs();\n\t\tif let Err(e) = file.write_all(now.to_be_bytes().as_slice()) {\n\t\t\twarn!(\"failed to write heartbeat: {e}\");\n\t\t}\n\n\t\tlet mut buf = Cursor::new([0u8; ENTRY_SIZE as usize]);\n\t\tfor it in sessions {\n\t\t\tlet ((id, slot), (token, eattrs)) = (it.0, it.1);\n\t\t\tif let Err(e) = file.seek(SeekFrom::Start(8 + slot as u64 * ENTRY_SIZE)) {\n\t\t\t\twarn!(\n\t\t\t\t\t\"failed to seek to resume session for player {id} at slot {slot}: \\\n\t\t\t\t\t {e}\"\n\t\t\t\t);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbuf.seek(SeekFrom::Start(0)).unwrap();\n\t\t\tbuf.write_all(id.to_be_bytes().as_slice()).unwrap();\n\t\t\tbuf.write_all(token.as_slice()).unwrap();\n\t\t\tsave_attributes(buf.position(), \u0026eattrs, \u0026mut buf);\n\n\t\t\tif let Err(e) = file.write_all(buf.get_mut()) {\n\t\t\t\twarn!(\"failed to write resume session for {}.{:?}: {e}\", id, token);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/// This function periodically clears replication cache that has been\n/// filled by functions in the producer, and writes it to disk.\n///\n/// This function also saves idmapping afterwards.\nasync fn write_replication_cache(r: Arc\u003cFileReplication\u003e, delay: Duration) {\n\tloop {\n\t\ttokio::time::sleep(delay).await;\n\n\t\t// Get all cached data then write to disk.\n\t\t//\n\t\t// We don't want to keep holding the DashMap lock so we first\n\t\t// store into a normal hashmap, consuming the attributes map in each\n\t\t// entry.\n\t\tlet mut w = HashMap::with_capacity(r.cache.len());\n\t\tfor mut it in r.cache.iter_mut() {\n\t\t\tw.insert(*it.key(), std::mem::take(it.value_mut()));\n\t\t}\n\n\t\tlet lock = r.file.lock();\n\t\tlet mut f = \u0026*lock;\n\t\tfor (replicated_id, attrs) in w.iter() {\n\t\t\tsave_entity(replicated_id, attrs, \u0026mut f);\n\t\t}\n\t}\n}\n\n/// Saves attributes to disk specified by their slot.\nfn save_entity\u003cWriter: Write + Seek\u003e(\n\tid: \u0026ReplicatedEntity,\n\teattrs: \u0026AttributesMap,\n\twriter: \u0026mut Writer,\n) {\n\tlet (idbuf, slot) = match id {\n\t\tReplicatedEntity::Object(id, slot) =\u003e (id.to_be_bytes().to_vec(), slot),\n\t\tReplicatedEntity::Player(id, slot) =\u003e (id.to_be_bytes().to_vec(), slot),\n\t};\n\n\tlet mut offset = *slot as u64 * (idbuf.len() + ENTITY_ATTR_SIZE) as u64;\n\tif let Err(e) = writer.seek(SeekFrom::Start(offset)) {\n\t\twarn!(\"failed to seek to entity: {e}\");\n\t\treturn;\n\t}\n\n\t// write the entity id.\n\tif let Err(e) = writer.write_all(\u0026idbuf) {\n\t\twarn!(\"failed to write entity id: {e}\");\n\t\treturn;\n\t}\n\n\t// offset the id that we just wrote\n\toffset += idbuf.len() as u64;\n\tsave_attributes(offset, eattrs, writer)\n}\n\nfn save_attributes\u003cWriter: Write + Seek\u003e(\n\toffset: u64,\n\teattrs: \u0026AttributesMap,\n\twriter: \u0026mut Writer,\n) {\n\t// We have to write attributes individually since if we do write the whole map\n\t// as a byte array, we might face some complexities in recovery such as\n\t// unlocking a held lock inside the map, and so on, that's because entries\n\t// have their own individual lock.\n\t//\n\t// So, just write the attribute value instead, and recover only that.\n\teattrs.iter(|k, v| {\n\t\tif let Err(e) =\n\t\t\twriter.seek(SeekFrom::Start(offset + *k as u64 * ATTR_SIZE as u64))\n\t\t{\n\t\t\twarn!(\"failed to seek into attr: {k}: {e}\");\n\t\t\treturn;\n\t\t}\n\n\t\tlet v: TimestampedVal = (v.get(), v.timestamp()).into();\n\t\tlet slice = unsafe {\n\t\t\tlet ptr = \u0026v as *const TimestampedVal as *const u8;\n\t\t\tcore::slice::from_raw_parts(ptr, ATTR_SIZE)\n\t\t};\n\n\t\tif let Err(e) = writer.write_all(slice) {\n\t\t\twarn!(\"failed to write attribute: {e}\");\n\t\t}\n\t});\n}\n\n/// Try to recover as many attributes as possible from disk.\npub(super) fn recover_entity\u003cReader: Read + Seek, const ID_SIZE: u64\u003e(\n\tslot: u32,\n\treader: \u0026mut Reader,\n\tattributes: \u0026AttributesMap,\n) -\u003e bool {\n\tif let Err(e) = reader.seek(SeekFrom::Start(\n\t\t(slot as u64 * (ID_SIZE + ENTITY_ATTR_SIZE as u64)) + ID_SIZE,\n\t)) {\n\t\twarn!(\"reader seek failed: {e}\");\n\t\treturn false;\n\t}\n\n\trecover_attributes::\u003cReader, ID_SIZE\u003e(reader, attributes)\n}\n\n/// Try to recover as many attributes as possible from disk.\npub(super) fn recover_attributes\u003cReader: Read + Seek, const ID_SIZE: u64\u003e(\n\treader: \u0026mut Reader,\n\tattributes: \u0026AttributesMap,\n) -\u003e bool {\n\tlet mut attrs = Vec::\u003cTimestampedVal\u003e::with_capacity(MAX_ATTRIBUTES);\n\tattrs.resize(MAX_ATTRIBUTES, Default::default());\n\n\tlet b = unsafe {\n\t\tlet ptr = attrs.as_mut_ptr() as *mut u8;\n\t\tcore::slice::from_raw_parts_mut(\n\t\t\tptr,\n\t\t\tattrs.len() * core::mem::size_of::\u003cTimestampedVal\u003e(),\n\t\t)\n\t};\n\n\tif let Err(e) = reader.read(\u0026mut b[..]) {\n\t\twarn!(\"reader failed to read: {e}\");\n\t\treturn false;\n\t}\n\n\tfor (i, value) in attrs.into_iter().enumerate() {\n\t\tif value.0 == Value::None {\n\t\t\t// Avoid none values since the entity is fresh and no attributes have been\n\t\t\t// touched yet in the entity.\n\t\t\tcontinue;\n\t\t}\n\n\t\tif let Err(e) = attributes.try_set(i as u16, value.0, value.1) {\n\t\t\t// Possible change in attribute map definition\n\t\t\twarn!(\"failed to recover attribute: {i}: {e}\");\n\t\t}\n\t}\n\n\ttrue\n}\n\n/// Clears stored attributes\nfn clear_attributes\u003cW: Write + Seek, const ID_SIZE: usize\u003e(\n\tslot: u32,\n\twriter: \u0026mut W,\n) {\n\tif let Err(e) = writer.seek(SeekFrom::Start(\n\t\tslot as u64 * (ID_SIZE + ENTITY_ATTR_SIZE) as u64,\n\t)) {\n\t\twarn!(\"failed to seek to entity: {e}\");\n\t\treturn;\n\t}\n\n\tlet buf = vec![0; ID_SIZE + ENTITY_ATTR_SIZE];\n\tif let Err(e) = writer.write_all(\u0026buf) {\n\t\twarn!(\"failed to write zeroes of attributes: {e}\");\n\t}\n}\n\n#[cfg(test)]\nmod tests {\n\tuse super::*;\n\n\t#[test]\n\tfn save_recover_attrs_smoke() -\u003e anyhow::Result\u003c()\u003e {\n\t\tlet mut buffer = Cursor::new(vec![0u8; ENTITY_ATTR_SIZE * 3]);\n\n\t\tlet a1 = AttributesMap::default();\n\t\ta1.try_set(1, Value::Uint32(5), 1)?;\n\t\ta1.try_set(5, Value::Uint16(9000), 1)?;\n\t\tsave_entity(\u0026ReplicatedEntity::Player(0, 0), \u0026a1, \u0026mut buffer);\n\n\t\tlet a2 = AttributesMap::default();\n\t\ta2.try_set(1, Value::Uint32(10), 1)?;\n\t\ta2.try_set(5, Value::Uint16(18000), 1)?;\n\t\tsave_entity(\u0026ReplicatedEntity::Player(1, 1), \u0026a2, \u0026mut buffer);\n\n\t\tlet a3 = AttributesMap::default();\n\t\ta3.try_set(1, Value::Uint32(15), 1)?;\n\t\ta3.try_set(5, Value::Uint16(27000), 1)?;\n\t\tsave_entity(\u0026ReplicatedEntity::Player(2, 2), \u0026a3, \u0026mut buffer);\n\n\t\t// make sure all attributes were set correctly...\n\t\tlet e1 = Entity::new(EntityId::SYSTEM_PLAYER);\n\t\tassert!(recover_entity::\u003c_, 4\u003e(0, \u0026mut buffer, e1.attributes()));\n\t\tassert_eq!(\n\t\t\te1.attributes().try_access(1, |v| v.get()),\n\t\t\tSome(Value::Uint32(5))\n\t\t);\n\t\tassert_eq!(\n\t\t\te1.attributes().try_access(5, |v| v.get()),\n\t\t\tSome(Value::Uint16(9000))\n\t\t);\n\n\t\tlet e2 = Entity::new(EntityId::Player(1));\n\t\tassert!(recover_entity::\u003c_, 4\u003e(1, \u0026mut buffer, e2.attributes()));\n\n\t\tassert_eq!(\n\t\t\te2.attributes().try_access(1, |v| v.get()),\n\t\t\tSome(Value::Uint32(10))\n\t\t);\n\t\tassert_eq!(\n\t\t\te2.attributes().try_access(5, |v| v.get()),\n\t\t\tSome(Value::Uint16(18000))\n\t\t);\n\n\t\tlet e3 = Entity::new(EntityId::Player(2));\n\t\tassert!(recover_entity::\u003c_, 4\u003e(2, \u0026mut buffer, e3.attributes()));\n\n\t\tassert_eq!(\n\t\t\te3.attributes().try_access(1, |v| v.get()),\n\t\t\tSome(Value::Uint32(15))\n\t\t);\n\t\tassert_eq!(\n\t\t\te3.attributes().try_access(5, |v| v.get()),\n\t\t\tSome(Value::Uint16(27000))\n\t\t);\n\n\t\tOk(())\n\t}\n\n\t#[test]\n\tfn clear_attrs_smoke() -\u003e anyhow::Result\u003c()\u003e {\n\t\tlet mut buffer = Cursor::new(vec![0u8; ENTITY_ATTR_SIZE * 3]);\n\n\t\tlet a1 = AttributesMap::default();\n\t\ta1.try_set(1, Value::Uint32(5), 1)?;\n\t\ta1.try_set(5, Value::Uint16(9000), 1)?;\n\t\tsave_entity(\u0026ReplicatedEntity::Player(0, 0), \u0026a1, \u0026mut buffer);\n\t\tclear_attributes::\u003c_, 4\u003e(0, \u0026mut buffer);\n\n\t\tlet e1 = Entity::new(EntityId::SYSTEM_PLAYER);\n\t\tassert!(recover_entity::\u003c_, 4\u003e(0, \u0026mut buffer, e1.attributes()));\n\t\tassert!(e1.attributes().try_access(1, |_| true).is_none());\n\t\tassert!(e1.attributes().try_access(5, |_| true).is_none());\n\n\t\tOk(())\n\t}\n}\n","traces":[{"line":69,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":76},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":76},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":76},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":53},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":53},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":640},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":640},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":640},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":625},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":16764},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":8376},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":8376},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":8376},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":8376},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":8376},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":8376},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":8376},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":8376},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":8392},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":33538},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":16757},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":82617},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":32930},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":16757},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":16757},"fn_name":null},{"line":478,"address":[],"length":0,"stats":{"Line":82617},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":32930},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":32934},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":65868},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":8550},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":24384},"fn_name":null},{"line":495,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":32934},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":32934},"fn_name":null},{"line":509,"address":[],"length":0,"stats":{"Line":32934},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":32942},"fn_name":null},{"line":523,"address":[],"length":0,"stats":{"Line":33087},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":145},"fn_name":null},{"line":527,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":145},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":145},"fn_name":null},{"line":533,"address":[],"length":0,"stats":{"Line":145},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":145},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":145},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":549,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":550,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":552,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":553,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":556,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":564,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":565,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":568,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":570,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":571,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":575,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":576,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":580,"address":[],"length":0,"stats":{"Line":5289},"fn_name":null},{"line":581,"address":[],"length":0,"stats":{"Line":5248},"fn_name":null},{"line":584,"address":[],"length":0,"stats":{"Line":5169},"fn_name":null},{"line":587,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":589,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":593,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":597,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":601,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":602,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":604,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":608,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":609,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":610,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":167,"coverable":231},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","replication","mod.rs"],"content":"//! Quark replication system\n//!\n//! The replication system is responsible for replicating changes to the game\n//! state to other nodes or other types of consumers. The replication system is\n//! configured through a URL that is passed to the server on startup.\n//!\n//! ## Producers\n//! Replication producers are responsible for replicating changes that occure on\n//! this node to other consumers. Currently the following replication types are\n//! supported:\n//!\n//! - `udp://host:port` This replication type will send all changes to the\n//!   specified host and port as a series of UDP packets. This type of\n//!   replication is useful for replicating changes to other nodes in the same\n//!   cluster when running behind a load balancer.\n//!\n//! - `file://path-to-file` This replication type will write all changes to a\n//!   file on disk. This type of replication is used to create snapshots of the\n//!   game state for crash recovery scenarios.\n//!\n//!\n//! ## Consumers\n//! Replication consumers are responsible for receiving changes from other\n//! change producers. Currently the following replication types are supported:\n//!\n//! - `udp://host:port` This replication type will listen for UDP packets on the\n//!   specified host and port. This type of replication is useful for receiving\n//!   changes from other nodes in the same cluster when running behind a load\n//!   balancer.\n//!\n//! - `file://path-to-file` This replication type will read all changes from a\n//!   file on disk during startup and restore the state of the system to the\n//!   state that was written to the file. This type of replication is used to\n//!   restore the game state from a snapshot after a crash.\n//!\n//!\n//! ## Ownership\n//! Quark allows players to have at most one active session at a time,\n//! regardless of the actual node thay are connected to at any given time. This\n//! means that if we are getting replication data from another node about a\n//! player then we are guaranteed that the local player does not have an active\n//! session for that player and thus the replication system will have the\n//! exclusive write access to the player.\n//!\n//! Objects on the other hand can be manupulated by many players at the same\n//! time, and authority is decided at the time of write. Whenever an update\n//! happens to an object on a remote node and that change gets replicated\n//! to the current node,\n\nuse {\n\tcrate::{\n\t\tevents::Event,\n\t\tglobal::GlobalState,\n\t\tstate::{\n\t\t\tentity::{Entity, EntityChanges},\n\t\t\tplayer::PlayerId,\n\t\t\tDespawnedEntity,\n\t\t\tEntityId,\n\t\t},\n\t},\n\titertools::Itertools,\n\tquark_client_sdk::Recipient,\n\tstd::sync::Arc,\n\turl::Url,\n};\n\nmod file;\nmod udp;\n\n// -----------------------\n// Replication public API\n// -----------------------\npub struct Producers(Vec\u003cBox\u003cdyn Producer\u003e\u003e);\n\nimpl Producers {\n\t/// Creates replication producers instances from a list of endpoints.\n\t///\n\t/// The list of endpoints is a list of urls that are passed to the server\n\t/// during startup using the `--replicate-to` command line option.\n\t///\n\t/// All urls with the same scheme are groupped together and passed to\n\t/// one producer instance. This allows us to significantly reduce\n\t/// duplicated work when multiple endpoints share the same scheme.\n\tpub fn new(endpoints: \u0026[Url]) -\u003e anyhow::Result\u003cSelf\u003e {\n\t\tlet mut instances =\n\t\t\tVec::\u003cBox\u003cdyn Producer\u003e\u003e::with_capacity(endpoints.len());\n\t\tfor (scheme, urls) in endpoints\n\t\t\t.iter()\n\t\t\t.group_by(|c| c.scheme().to_string())\n\t\t\t.into_iter()\n\t\t{\n\t\t\tlet urls: Vec\u003c_\u003e = urls.cloned().collect();\n\t\t\tmatch scheme.as_str() {\n\t\t\t\t\"udp\" =\u003e instances.push(Box::new(udp::Producer::new(\u0026urls)?)),\n\t\t\t\t\"file\" =\u003e instances.push(Box::new(file::Producer::new(\u0026urls)?)),\n\t\t\t\t_ =\u003e panic!(\"unknown replication producer url scheme: {scheme}\"),\n\t\t\t};\n\t\t}\n\n\t\tOk(Self(instances))\n\t}\n\n\t/// Replicates changes to a player or object to all consumers\n\tpub fn entity(\n\t\t\u0026self,\n\t\tid: EntityId,\n\t\tchanges: \u0026EntityChanges,\n\t\tentity: \u0026Entity,\n\t\tauthor: PlayerId,\n\t) {\n\t\tfor producer in \u0026self.0 {\n\t\t\tproducer.entity(id, changes, entity, author);\n\t\t}\n\t}\n\n\t/// Some consumers and some producers support replicating events, if so\n\t/// this is called whenever a client produces an event in a tick.\n\t///\n\t/// This will only replicate application level events (i.e. class \u003e= 1000).\n\tpub fn app_event(\u0026self, event: \u0026Event, recipient: \u0026Recipient) {\n\t\tfor producer in \u0026self.0 {\n\t\t\tproducer.event(event, recipient);\n\t\t}\n\t}\n\n\t/// Replicates that an entity was spawned on this node to all consumers\n\tpub fn spawn(\u0026self, entity_id: EntityId, entity: \u0026Entity) {\n\t\tfor producer in \u0026self.0 {\n\t\t\tproducer.spawn(entity_id, entity);\n\t\t}\n\t}\n\n\t/// Replicates that an entity was despawned on this node to all consumers\n\tpub fn despawn(\u0026self, entity: DespawnedEntity) {\n\t\tfor producer in \u0026self.0 {\n\t\t\tproducer.despawn(entity.clone());\n\t\t}\n\t}\n}\n\n/// Represents a list of all replication consumers that are enabled on this\n/// node. This type is responsible for starting all consumers and managing their\n/// lifetimes. It takes a reference to the global state and is responsible for\n/// ingesting all changes that are received from the producers and applying them\n/// to the local global state.\npub struct Consumers;\n\nimpl Consumers {\n\t/// Creates replication consumer instances from a list of endpoints.\n\t///\n\t/// The list of endpoints is a list of urls that are passed to the server\n\t/// during startup using the `--replicate-from` command line option.\n\t///\n\t/// All urls with the same scheme are groupped together and passed to\n\t/// one consumer instance. This allows us to significantly reduce\n\t/// duplicated work when multiple endpoints share the same scheme.\n\tpub fn start(endpoints: Vec\u003cUrl\u003e, global: Arc\u003cGlobalState\u003e) {\n\t\tfor endpoint in endpoints {\n\t\t\tmatch endpoint.scheme() {\n\t\t\t\t\"udp\" =\u003e udp::Consumer::start(endpoint, Arc::clone(\u0026global)),\n\t\t\t\t\"file\" =\u003e file::Consumer::start(endpoint.clone(), Arc::clone(\u0026global)),\n\t\t\t\tscheme =\u003e panic!(\"unknown replication consumer url scheme: {scheme}\"),\n\t\t\t};\n\t\t}\n\t}\n}\n\n// ------------------------\n// Replication internal API\n// ------------------------\n\n/// This trait is implemented by all replication producers that are responsible\n/// for propagating changes that happen to the game state on this node to other\n/// nodes or consumer types.\n///\n/// This trait makes no assumptions about the inner workings of the producer\n/// and its threading model. It is recommended that each implementation of this\n/// trait implements its own batching and background worker logic.\n///\n/// Methods of this trait are called in critical code paths and should not block\n/// or perform any long running operations, but rather schedule work to be done\n/// in the background.\n///\n/// Replicaton producers are configured using a URL that is passed to the server\n/// on startup, e.g. udp://host:port. The system will instantiate only one\n/// producer per url scheme and pass all endpoints that share the same url\n/// scheme to the producer in the constructor.\ntrait Producer: Send + Sync {\n\t/// Replicate a change that happened to an entity on this node to all\n\t/// publishing endpoints.\n\tfn entity(\n\t\t\u0026self,\n\t\tid: EntityId,\n\t\tchanges: \u0026EntityChanges,\n\t\tentity: \u0026Entity,\n\t\tauthor: PlayerId,\n\t);\n\n\t/// Replicate an event that happened on this node to all publishing\n\t/// endpoints.\n\tfn event(\u0026self, event: \u0026Event, recipient: \u0026Recipient);\n\n\t/// Replicates that an entity was spawned on this node to all publishing\n\t/// In case if EntityId::Player this means that a new player has connected\n\t/// to the server and this server owns the player. In some implementations,\n\t/// this will immediately disconnect and terminate any session for a player\n\t/// with this Id on all other consumers.\n\t///\n\t/// In case of EntityId::Object this means that a new object has been\n\t/// created on this server for the first time. In most implementations\n\t/// this will be a noop.\n\tfn spawn(\u0026self, entity_id: EntityId, entity: \u0026Entity);\n\n\t/// Replicates that an entity was despawned on this node to all publishing\n\t/// endpoints. In case of EntityId::Player this means that a player has\n\t/// disconnected from the server and this server no longer owns the player.\n\t/// In some implementations this will send a event to all other players that\n\t/// are aware of this player about its disconnect.\n\t///\n\t/// In case of EntityId::Object this means that an object has been removed\n\t/// from the server. In most implementations this will send an event to all\n\t/// other players that are aware of this object about its despawn.\n\tfn despawn(\u0026self, entity: DespawnedEntity);\n}\n","traces":[{"line":84,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":152},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":271},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":1283},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":1529},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":82},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":870},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":1101},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":77},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":71},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":167},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":28,"coverable":30},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","replication","udp","consumer.rs"],"content":"use {\n\tsuper::{\n\t\tcontrol::Control,\n\t\tevents::EventDatum,\n\t\tmacros::for_each_type,\n\t\tpacket::{MTUBytes, Packet, Payload},\n\t\tDatum,\n\t},\n\tcrate::{\n\t\tglobal::GlobalState,\n\t\treplication::udp::{\n\t\t\tentities::{ObjectUpdate, PlayerUpdate},\n\t\t\tpacket::UpdateType,\n\t\t},\n\t},\n\tarrayvec::{ArrayString, ArrayVec},\n\tget_if_addrs::{get_if_addrs, IfAddr},\n\tmetrics::{histogram, increment_counter},\n\tquark_client_sdk::{AttributeType, MAX_PAYLOAD_LEN, MAX_SEQUENCE_LENGTH},\n\tseq_macro::seq,\n\tsocket2::{Domain, Protocol, Socket, Type},\n\tstd::{\n\t\tnet::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6},\n\t\tsync::Arc,\n\t},\n\ttokio::net::UdpSocket,\n\ttracing::{info, trace, warn},\n\turl::Url,\n};\n\n#[derive(Default, Debug, Clone)]\nstruct ConsumerOpts {\n\tignore: Vec\u003cIpAddr\u003e,\n\taccept_own_addr: bool,\n}\n\npub struct Consumer {}\n\nimpl Consumer {\n\tpub fn start(url: Url, global: Arc\u003cGlobalState\u003e) {\n\t\tlet Ok(listen_addrs) = url.socket_addrs(|| Some(5671)) else {\n\t\t\tpanic!(\"failed to parse udp replication client socket address {url}\");\n\t\t};\n\t\tlet mut opts = ConsumerOpts::default();\n\n\t\turl\n\t\t\t.query_pairs()\n\t\t\t.for_each(|(k, v)| match (k.as_ref(), v.as_ref()) {\n\t\t\t\t// When set to true, the consumer will accept packets from its own\n\t\t\t\t// address. This is useful for testing and debugging when running\n\t\t\t\t// multiple instances of the server on the same machine.\n\t\t\t\t(\"accept_own_addr\", \"true\") =\u003e opts.accept_own_addr = true,\n\n\t\t\t\t// When set to ignore, the consumer will ignore packets from the\n\t\t\t\t// specified address.\n\t\t\t\t(\"ignore\", addr) =\u003e {\n\t\t\t\t\tif let Ok(addr) = addr.parse() {\n\t\t\t\t\t\topts.ignore.push(addr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_ =\u003e {}\n\t\t\t});\n\n\t\tfor addr in listen_addrs {\n\t\t\tinfo!(\"udp replication client listening on {addr}, opts: {opts:?}\");\n\t\t\ttokio::spawn(receive_loop(addr, Arc::clone(\u0026global), opts.clone()));\n\t\t}\n\t}\n}\n\n/// Awaits new UDP packets and dispatches them to the appropriate handler\n/// based on the packet type and its metadata.\nasync fn receive_loop(\n\tendpoint: SocketAddr,\n\tglobal: Arc\u003cGlobalState\u003e,\n\topts: ConsumerOpts,\n) {\n\tlet ignore_list = create_ignore_list(\u0026opts);\n\tlet socket = UdpSocket::from_std(create_listen_socket(endpoint).into())\n\t\t.expect(\"failed to convert udp socket to tokio udp socket\");\n\n\tlet mut recv_buffer = MTUBytes::default();\n\n\tloop {\n\t\tlet (len, addr) = match socket.recv_from(recv_buffer.as_mut()).await {\n\t\t\tOk((len, addr)) =\u003e (len, addr),\n\t\t\tErr(e) =\u003e {\n\t\t\t\twarn!(\"failed to receive from udp socket ({endpoint}): {e}\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t};\n\n\t\t// move the received buffer into the scope of this loop\n\t\t// and reset the original receive buffer to the default state\n\t\tlet recv_buffer = std::mem::take(\u0026mut recv_buffer);\n\n\t\t// skip packets from our own addresses\n\t\tif ignore_list.contains(\u0026addr.ip()) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tincrement_counter!(\"udp_replication_packets_received_count\");\n\t\thistogram!(\"udp_replication_received_packet_size\", len as f64);\n\n\t\t// peek at the packet header to determine the packet type\n\t\tlet Some(header) = recv_buffer.header() else {\n\t\t\twarn!(\"received invalid udp replciation packet from {addr}\");\n\t\t\tcontinue;\n\t\t};\n\n\t\t// validate the packet size against the header's packet size\n\t\t// this is a quick sanity check to ensure the packet is not corrupted\n\t\tif header.packet_size() != len {\n\t\t\twarn!(\n\t\t\t\t\"received udp replication packet with invalid length: expected {} but \\\n\t\t\t\t got {len}\",\n\t\t\t\theader.packet_size()\n\t\t\t);\n\t\t\tincrement_counter!(\"udp_replication_packets_received_invalid_count\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tmatch recv_buffer.header().unwrap().update_type() {\n\t\t\tUpdateType::Invalid =\u003e {\n\t\t\t\ttrace!(\"received invalid udp replication packet from {addr}\");\n\t\t\t\tincrement_counter!(\"udp_replication_packets_received_invalid_count\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tUpdateType::Control =\u003e {\n\t\t\t\tlet packet = Packet::\u003cControl\u003e::from(recv_buffer);\n\t\t\t\tapply_packet(packet, \u0026global);\n\t\t\t}\n\t\t\tUpdateType::Event(n) =\u003e {\n\t\t\t\tseq!(N in 0..256 {\n\t\t\t\t\tstatic DISPATCH_FN: [fn(\u0026Arc\u003cGlobalState\u003e, MTUBytes); MAX_PAYLOAD_LEN] = [\n\t\t\t\t\t\t#(\n\t\t\t\t\t\t\t|global, recv_buffer| {\n\t\t\t\t\t\t\t\tlet packet = Packet::\u003cEventDatum\u003cN\u003e\u003e::from(recv_buffer);\n\t\t\t\t\t\t\t\tapply_packet(packet, global);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t)*\n\t\t\t\t\t];\n\t\t\t\t});\n\n\t\t\t\tlet dispatch_fn = DISPATCH_FN[*n as usize];\n\t\t\t\tdispatch_fn(\u0026global, recv_buffer);\n\t\t\t}\n\t\t\tUpdateType::Entity(e) =\u003e {\n\t\t\t\t// invoke the strongly-typed handler based on the data encoded in its\n\t\t\t\t// packet header.\n\t\t\t\tmacro_rules! process_entity_packet {\n\t\t\t\t\t($rust_type:ty, $value_type:ident, $packet_type:tt) =\u003e {\n\t\t\t\t\t\tif let Ok(AttributeType::$value_type) = e.attribute_type() {\n\t\t\t\t\t\t\tlet packet =\n\t\t\t\t\t\t\t\tPacket::\u003c$packet_type\u003c$rust_type\u003e\u003e::from(recv_buffer);\n\t\t\t\t\t\t\tapply_packet(packet, \u0026global);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// route the packet to the appropriate handler based on the attribute\n\t\t\t\t// type of the packet and its metadata.\n\t\t\t\tif e.is_player() {\n\t\t\t\t\tfor_each_type!(process_entity_packet, PlayerUpdate);\n\t\t\t\t} else {\n\t\t\t\t\tfor_each_type!(process_entity_packet, ObjectUpdate);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfn apply_packet\u003cP: Payload\u003e(packet: Packet\u003cP\u003e, global: \u0026Arc\u003cGlobalState\u003e) {\n\ttrace!(\"received: {packet:?}\");\n\n\tfor datum in packet.datums() {\n\t\tdatum.apply(global);\n\t}\n}\n\nfn create_listen_socket(endpoint: SocketAddr) -\u003e Socket {\n\tlet socket = if endpoint.ip().is_multicast() {\n\t\tmatch endpoint.ip() {\n\t\t\tstd::net::IpAddr::V4(ip) =\u003e {\n\t\t\t\tlet s = Socket::new(Domain::IPV4, Type::DGRAM, Some(Protocol::UDP))\n\t\t\t\t\t.expect(\"failed to create udp socket for replication consumer\");\n\t\t\t\ts.join_multicast_v4(\u0026ip, \u0026Ipv4Addr::UNSPECIFIED)\n\t\t\t\t\t.expect(\"Failed to join IP4 multicast group\");\n\t\t\t\ttrace!(\"joined multicast group {}\", endpoint.ip());\n\t\t\t\ts.bind(\n\t\t\t\t\t\u0026SocketAddr::V4(SocketAddrV4::new(\n\t\t\t\t\t\tIpv4Addr::UNSPECIFIED,\n\t\t\t\t\t\tendpoint.port(),\n\t\t\t\t\t))\n\t\t\t\t\t.into(),\n\t\t\t\t)\n\t\t\t\t.expect(\"failed to bind udp socket in multicast group {endpoint}\");\n\t\t\t\ts\n\t\t\t}\n\t\t\tstd::net::IpAddr::V6(ip) =\u003e {\n\t\t\t\tlet s = Socket::new(Domain::IPV6, Type::DGRAM, Some(Protocol::UDP))\n\t\t\t\t\t.expect(\"failed to create udp socket for replication consumer\");\n\t\t\t\ts.join_multicast_v6(\u0026ip, 0)\n\t\t\t\t\t.expect(\"Failed to join IP6 multicast group\");\n\t\t\t\ttrace!(\"joined multicast group {}\", endpoint.ip());\n\t\t\t\ts.bind(\n\t\t\t\t\t\u0026SocketAddr::V6(SocketAddrV6::new(\n\t\t\t\t\t\tIpv6Addr::UNSPECIFIED,\n\t\t\t\t\t\tendpoint.port(),\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t0,\n\t\t\t\t\t))\n\t\t\t\t\t.into(),\n\t\t\t\t)\n\t\t\t\t.expect(\"failed to bind udp socket in multicast group {endpoint}\");\n\t\t\t\ts\n\t\t\t}\n\t\t}\n\t} else if endpoint.ip().is_ipv4() {\n\t\tlet s = Socket::new(Domain::IPV4, Type::DGRAM, Some(Protocol::UDP))\n\t\t\t.expect(\"failed to create udp socket for replication consumer\");\n\t\ts.bind(\u0026endpoint.into())\n\t\t\t.expect(\"failed to bind udp socket {endpoint}\");\n\t\ttrace!(\"created ipv4 udp socket {endpoint} for replication consumer\");\n\t\ts\n\t} else {\n\t\tlet s = Socket::new(Domain::IPV6, Type::DGRAM, Some(Protocol::UDP))\n\t\t\t.expect(\"failed to create udp socket for replication consumer\");\n\t\ts.bind(\u0026endpoint.into())\n\t\t\t.expect(\"failed to bind udp socket {endpoint}\");\n\t\ttrace!(\"created ipv6 udp socket {endpoint} for replication consumer\");\n\t\ts\n\t};\n\n\tsocket\n\t\t.set_nonblocking(true)\n\t\t.expect(\"failed to set udp socket to non-blocking mode\");\n\tsocket\n\t\t.set_reuse_address(true)\n\t\t.expect(\"failed to set udp socket to reuse address mode\");\n\n\tsocket\n}\n\nfn create_ignore_list(opts: \u0026ConsumerOpts) -\u003e Vec\u003cIpAddr\u003e {\n\tlet mut ignore_list = opts.ignore.clone();\n\n\tif !opts.accept_own_addr {\n\t\tignore_list.extend(\n\t\t\tget_if_addrs()\n\t\t\t\t.expect(\"failed to get local network interfaces\")\n\t\t\t\t.into_iter()\n\t\t\t\t.map(|iface| match iface.addr {\n\t\t\t\t\tIfAddr::V4(addr) =\u003e IpAddr::V4(addr.ip),\n\t\t\t\t\tIfAddr::V6(addr) =\u003e IpAddr::V6(addr.ip),\n\t\t\t\t}),\n\t\t);\n\t}\n\n\tignore_list\n}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":92},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":92},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":92},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":174},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":58},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":267},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":259},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":257},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":21},"fn_name":null}],"covered":65,"coverable":112},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","replication","udp","control.rs"],"content":"use {\n\tsuper::{\n\t\tpacket::{Payload, UpdateType},\n\t\tDatum,\n\t},\n\tcrate::{\n\t\tglobal::GlobalState,\n\t\tsession::command::Command,\n\t\tstate::{object::ObjectId, player::PlayerId},\n\t},\n\tstd::sync::Arc,\n};\n\n#[derive(Debug, Clone, PartialEq)]\n#[repr(C)]\npub enum Control {\n\tPlayerConnected(PlayerId),\n\tPlayerDisconnected(PlayerId, [u8; 16]),\n\tObjectDespawned(ObjectId),\n}\n\nimpl Payload for Control {\n\ttype Item = Self;\n\n\tfn kind() -\u003e UpdateType {\n\t\tUpdateType::Control\n\t}\n}\n\nimpl Datum for Control {\n\tfn apply(\u0026self, global: \u0026Arc\u003cGlobalState\u003e) {\n\t\tmatch self {\n\t\t\tControl::PlayerConnected(player_id) =\u003e {\n\t\t\t\ton_player_connected(*player_id, global);\n\t\t\t}\n\t\t\tControl::PlayerDisconnected(player_id, resume_token) =\u003e {\n\t\t\t\ton_player_disconnected(*player_id, resume_token, global);\n\t\t\t}\n\t\t\tControl::ObjectDespawned(object_id) =\u003e {\n\t\t\t\ton_object_despawned(*object_id, global);\n\t\t\t}\n\t\t};\n\t}\n}\n\n/// Triggered when a player connectes to a different machine in the same\n/// cluster. This is used to ensure that a player is only connected to one\n/// server at a time.\nfn on_player_connected(player_id: PlayerId, global: \u0026GlobalState) {\n\tif global.players().get(\u0026player_id).is_some() {\n\t\ttracing::trace!(\n\t\t\t\"disconnecting player {player_id} from server because it has connected \\\n\t\t\t to another server in the same cluster\",\n\t\t);\n\n\t\t// terminate any possible session for this user on this server\n\t\tglobal.commands().send_to(\u0026player_id, Command::Terminate);\n\t}\n}\n\nfn on_player_disconnected(\n\tplayer_id: PlayerId,\n\tresume_token: \u0026[u8; 16],\n\tglobal: \u0026Arc\u003cGlobalState\u003e,\n) {\n\tlet resume_token =\n\t\tString::from_utf8(resume_token.to_vec()).unwrap_or_default();\n\ttokio::spawn({\n\t\tlet global = Arc::clone(global);\n\t\tlet Some(entity) =\n\t\t\tglobal.players().get(\u0026player_id).map(|p| p.value().clone())\n\t\telse {\n\t\t\treturn;\n\t\t};\n\n\t\tasync move {\n\t\t\tglobal.despawn_player(player_id, resume_token.clone());\n\t\t\tif !resume_token.is_empty() {\n\t\t\t\tglobal\n\t\t\t\t\t.resumes()\n\t\t\t\t\t.park_raw_session(player_id, resume_token, entity);\n\t\t\t}\n\t\t}\n\t});\n}\n\nfn on_object_despawned(object_id: ObjectId, global: \u0026Arc\u003cGlobalState\u003e) {\n\tglobal.objects().system_despawn(object_id, global);\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":27,"coverable":32},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","replication","udp","entities.rs"],"content":"use {\n\tsuper::Datum,\n\tcrate::{\n\t\tglobal::GlobalState,\n\t\tstate::{\n\t\t\tentity::{AttributeChange, AttributeId, Entity, EntityChanges},\n\t\t\tobject::ObjectId,\n\t\t\tplayer::PlayerId,\n\t\t\trules,\n\t\t\tEntityId,\n\t\t},\n\t},\n\tquark_client_sdk::Value,\n\tstd::{fmt::Debug, sync::Arc},\n\ttracing::trace,\n};\n\n#[derive(Debug, Clone, PartialEq)]\n#[repr(C)]\npub struct PlayerUpdate\u003cD: Debug + Clone\u003e {\n\tpub player_id: PlayerId,\n\tpub attribute_id: AttributeId,\n\tpub update: AttributeChange,\n\tpub value: D,\n}\n\n/// When updating a player as opposed to objects, we know that there is only one\n/// writer at a time because the cluster allows a player to be connected to only\n/// one server at a time. This means that we can safely assume that the version\n/// of the attribute is always increasing only in one place and that the update\n/// with the highest version is the most relevant one.\nimpl\u003cD: TryInto\u003cValue\u003e + Debug + Clone\u003e Datum for PlayerUpdate\u003cD\u003e {\n\tfn apply(\u0026self, global: \u0026Arc\u003cGlobalState\u003e) {\n\t\tlet version = match self.update {\n\t\t\tAttributeChange::None =\u003e return,\n\t\t\tAttributeChange::Deleted =\u003e {\n\t\t\t\tif let Some(player) = global.players().get(\u0026self.player_id) {\n\t\t\t\t\tplayer.attributes().try_access(self.attribute_id, |v| {\n\t\t\t\t\t\tv.set(Value::None, Default::default())\n\t\t\t\t\t});\n\n\t\t\t\t\trules::apply_post_update_rules(\n\t\t\t\t\t\t\u0026self.player_id,\n\t\t\t\t\t\t\u0026player,\n\t\t\t\t\t\t\u0026EntityChanges {\n\t\t\t\t\t\t\tattributes: [(self.attribute_id, AttributeChange::Deleted)]\n\t\t\t\t\t\t\t\t.into_iter()\n\t\t\t\t\t\t\t\t.collect(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tglobal,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tAttributeChange::Updated(v) =\u003e v,\n\t\t\tAttributeChange::Created(v) =\u003e v,\n\t\t};\n\n\t\tlet Ok(value) = self.value.clone().try_into() else {\n\t\t\treturn;\n\t\t};\n\n\t\t// in the most common case, the player will already exist\n\t\t// and we are replacing an attribute, use `get` instad of `entry`\n\t\t// to avoid taking a write lock on the entity.\n\t\tif let Some(player) = global.players().get(\u0026self.player_id) {\n\t\t\tmatch player\n\t\t\t\t.attributes()\n\t\t\t\t.try_set(self.attribute_id, value, version)\n\t\t\t{\n\t\t\t\tOk(AttributeChange::Created(v)) =\u003e {\n\t\t\t\t\trules::apply_post_update_rules(\n\t\t\t\t\t\t\u0026self.player_id,\n\t\t\t\t\t\t\u0026player,\n\t\t\t\t\t\t\u0026EntityChanges {\n\t\t\t\t\t\t\tattributes: [(self.attribute_id, AttributeChange::Created(v))]\n\t\t\t\t\t\t\t\t.into_iter()\n\t\t\t\t\t\t\t\t.collect(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tglobal,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tErr(e) =\u003e {\n\t\t\t\t\ttrace!(\n\t\t\t\t\t\t\"failed to set attribute {} for player {}: {e:?}\",\n\t\t\t\t\t\tself.attribute_id,\n\t\t\t\t\t\tself.player_id\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\t_ =\u003e {}\n\t\t\t};\n\t\t} else {\n\t\t\t// otherwise (less likely case) we need to take a write lock\n\t\t\t// on the entity to create it and set the attribute.\n\t\t\tlet _ = global\n\t\t\t\t.players()\n\t\t\t\t.entry(self.player_id)\n\t\t\t\t.or_insert_with(|| Entity::new(EntityId::Player(self.player_id)))\n\t\t\t\t.downgrade()\n\t\t\t\t.attributes()\n\t\t\t\t.try_set(self.attribute_id, value, version);\n\t\t}\n\t}\n}\n\n#[derive(Debug, Clone, PartialEq)]\n#[repr(C)]\npub struct ObjectUpdate\u003cD: Clone\u003e {\n\tpub object_id: ObjectId,\n\tpub attribute_id: AttributeId,\n\tpub author: PlayerId,\n\tpub update: AttributeChange,\n\tpub value: D,\n}\n\nimpl\u003cD: TryInto\u003cValue\u003e + Debug + Clone\u003e Datum for ObjectUpdate\u003cD\u003e {\n\tfn apply(\u0026self, global: \u0026Arc\u003cGlobalState\u003e) {\n\t\tlet version = match self.update {\n\t\t\tAttributeChange::None =\u003e return,\n\t\t\tAttributeChange::Deleted =\u003e {\n\t\t\t\tif let Some(object) = global.objects().get(\u0026self.object_id) {\n\t\t\t\t\tobject.attributes().try_access(self.attribute_id, |v| {\n\t\t\t\t\t\tv.set(Value::None, Default::default())\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tAttributeChange::Updated(v) =\u003e v,\n\t\t\tAttributeChange::Created(v) =\u003e v,\n\t\t};\n\n\t\tlet Ok(value) = self.value.clone().try_into() else {\n\t\t\treturn;\n\t\t};\n\n\t\t// in the most common case, the player will already exist\n\t\t// and we are replacing an attribute, use `get` instad of `entry`\n\t\t// to avoid taking a write lock on the entity.\n\t\tif let Some(object) = global.objects().get(\u0026self.object_id) {\n\t\t\tlet Ok(changes) =\n\t\t\t\tobject\n\t\t\t\t\t.attributes()\n\t\t\t\t\t.try_set(self.attribute_id, value, version)\n\t\t\telse {\n\t\t\t\treturn;\n\t\t\t};\n\n\t\t\trules::apply_post_update_rules(\n\t\t\t\t\u0026self.author,\n\t\t\t\t\u0026object,\n\t\t\t\t\u0026EntityChanges {\n\t\t\t\t\tattributes: [(self.attribute_id, changes)].into_iter().collect(),\n\t\t\t\t},\n\t\t\t\tglobal,\n\t\t\t);\n\t\t} else {\n\t\t\t// otherwise (less likely case) we need to take a write lock\n\t\t\t// on the entity to create it and set the attribute.\n\t\t\tlet object = global\n\t\t\t\t.objects()\n\t\t\t\t.entry(self.object_id)\n\t\t\t\t.or_insert(Entity::new(EntityId::Object(self.object_id)))\n\t\t\t\t.downgrade();\n\n\t\t\tlet Ok(changes) =\n\t\t\t\tobject\n\t\t\t\t\t.attributes()\n\t\t\t\t\t.try_set(self.attribute_id, value, version)\n\t\t\telse {\n\t\t\t\treturn;\n\t\t\t};\n\n\t\t\trules::apply_post_update_rules(\n\t\t\t\t\u0026self.author,\n\t\t\t\t\u0026object,\n\t\t\t\t\u0026EntityChanges {\n\t\t\t\t\tattributes: [(self.attribute_id, changes)].into_iter().collect(),\n\t\t\t\t},\n\t\t\t\tglobal,\n\t\t\t);\n\t\t}\n\t}\n}\n\n#[cfg(test)]\nmod test {\n\tuse {super::*, std::mem::size_of};\n\n\t#[test]\n\tfn datum_sizes() {\n\t\tassert_eq!(size_of::\u003cPlayerUpdate\u003cu32\u003e\u003e(), 32);\n\t\tassert_eq!(size_of::\u003cPlayerUpdate\u003c(f32, f32, f32)\u003e\u003e(), 40);\n\n\t\tassert_eq!(size_of::\u003cObjectUpdate\u003cu32\u003e\u003e(), 40);\n\t\tassert_eq!(size_of::\u003cObjectUpdate\u003c(f32, f32, f32)\u003e\u003e(), 48);\n\t}\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":59},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":118},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":59},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":41,"coverable":77},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","replication","udp","events.rs"],"content":"use {\n\tsuper::{\n\t\tpacket::{Payload, UpdateType},\n\t\tDatum,\n\t},\n\tcrate::{\n\t\tevents::{self, Event},\n\t\tglobal::GlobalState,\n\t\tstate::EntityId,\n\t},\n\tquark_client_sdk::{EventClass, Recipient, Timestamp},\n\tstd::{fmt::Debug, sync::Arc},\n};\n\n#[derive(Clone, PartialEq)]\n#[repr(C)]\npub struct EventDatum\u003cconst N: usize\u003e {\n\tpub class: EventClass,\n\tpub sender: EntityId,\n\tpub recipient: Recipient,\n\tpub payload: [u8; N],\n\tpub timestamp: Timestamp,\n}\n\nimpl\u003cconst N: usize\u003e Debug for EventDatum\u003cN\u003e {\n\tfn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n\t\tf.debug_struct(\"EventDatum\")\n\t\t\t.field(\"class\", \u0026self.class)\n\t\t\t.field(\"sender\", \u0026self.sender)\n\t\t\t.field(\"recipient\", \u0026self.recipient)\n\t\t\t.field(\"payload\", \u0026format!(\"{} bytes\", \u0026self.payload.len()))\n\t\t\t.field(\"timestamp\", \u0026self.timestamp)\n\t\t\t.finish()\n\t}\n}\n\nimpl\u003cconst N: usize\u003e EventDatum\u003cN\u003e {\n\tpub fn from(value: \u0026Event, recipient: \u0026Recipient) -\u003e Self {\n\t\tassert_eq!(value.payload.len(), N);\n\t\tlet mut payload = [0; N];\n\t\tpayload.copy_from_slice(\u0026value.payload);\n\t\tSelf {\n\t\t\tclass: value.class,\n\t\t\tsender: value.sender,\n\t\t\tpayload,\n\t\t\trecipient: *recipient,\n\t\t\ttimestamp: value.timestamp,\n\t\t}\n\t}\n}\n\nimpl\u003cconst N: usize\u003e Payload for EventDatum\u003cN\u003e {\n\ttype Item = EventDatum\u003cN\u003e;\n\n\tfn kind() -\u003e UpdateType {\n\t\tUpdateType::event(N as u8)\n\t}\n}\n\nimpl\u003cconst N: usize\u003e Datum for EventDatum\u003cN\u003e {\n\tfn apply(\u0026self, global: \u0026Arc\u003cGlobalState\u003e) {\n\t\tlet global = Arc::clone(global);\n\t\tlet event = Event {\n\t\t\tclass: self.class,\n\t\t\tsender: self.sender,\n\t\t\tpayload: self.payload[..].try_into().unwrap(),\n\t\t\ttimestamp: self.timestamp,\n\t\t};\n\t\tlet recipient = self.recipient;\n\t\ttokio::spawn(async move {\n\t\t\tevents::propagate::process(event, recipient, \u0026global)\n\t\t});\n\t}\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":19,"coverable":26},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","replication","udp","macros.rs"],"content":"use {\n\tsuper::{\n\t\tentities::{ObjectUpdate, PlayerUpdate},\n\t\tpacket::{Payload, UpdateType},\n\t},\n\tarrayvec::{ArrayString, ArrayVec},\n\tquark_client_sdk::{AttributeType, MAX_SEQUENCE_LENGTH},\n};\n\n#[macro_export]\nmacro_rules! for_each_type {\n\t($exp:ident) =\u003e {\n\t\t$exp!(bool, Bool);\n\t\t$exp!(u8, Uint8);\n\t\t$exp!(u16, Uint16);\n\t\t$exp!(u32, Uint32);\n\t\t$exp!(u64, Uint64);\n\t\t$exp!(i8, Int8);\n\t\t$exp!(i16, Int16);\n\t\t$exp!(i32, Int32);\n\t\t$exp!(i64, Int64);\n\t\t$exp!(f32, Float32);\n\t\t$exp!(f64, Float64);\n\t\t$exp!((f32, f32), Vec2);\n\t\t$exp!((f32, f32, f32), Vec3);\n\t\t$exp!((f64, f64), Vec2d);\n\t\t$exp!((f64, f64, f64), Vec3d);\n\t\t$exp!((f32, f32, f32, f32), Vec4);\n\t\t$exp!((f64, f64, f64, f64), Vec4d);\n\t\t$exp!(ArrayString\u003cMAX_SEQUENCE_LENGTH\u003e, String);\n    \t$exp!(ArrayVec\u003cu8, MAX_SEQUENCE_LENGTH\u003e, Bytes);\n\t};\n\t($exp:ident, $context:tt) =\u003e {\n\t\t$exp!(bool, Bool, $context);\n\t\t$exp!(u8, Uint8, $context);\n\t\t$exp!(u16, Uint16, $context);\n\t\t$exp!(u32, Uint32, $context);\n\t\t$exp!(u64, Uint64, $context);\n\t\t$exp!(i8, Int8, $context);\n\t\t$exp!(i16, Int16, $context);\n\t\t$exp!(i32, Int32, $context);\n\t\t$exp!(i64, Int64, $context);\n\t\t$exp!(f32, Float32, $context);\n\t\t$exp!(f64, Float64, $context);\n\t\t$exp!((f32, f32), Vec2, $context);\n\t\t$exp!((f32, f32, f32), Vec3, $context);\n\t\t$exp!((f64, f64), Vec2d, $context);\n\t\t$exp!((f64, f64, f64), Vec3d, $context);\n\t\t$exp!((f32, f32, f32, f32), Vec4, $context);\n\t\t$exp!((f64, f64, f64, f64), Vec4d, $context);\n\t\t$exp!(ArrayString\u003cMAX_SEQUENCE_LENGTH\u003e, String, $context);\n    \t$exp!(ArrayVec\u003cu8, MAX_SEQUENCE_LENGTH\u003e, Bytes, $context);\n\t};\n}\n\n#[macro_export]\nmacro_rules! make_payload {\n\t($container:tt, $is_player:expr, $type:ty, $attrib_type:expr) =\u003e {\n\t\timpl Payload for $container\u003c$type\u003e {\n\t\t\ttype Item = Self;\n\n\t\t\tfn kind() -\u003e UpdateType {\n\t\t\t\tUpdateType::entity($is_player, $attrib_type)\n\t\t\t}\n\t\t}\n\t};\n}\n\nmacro_rules! make_player_update_payload {\n\t($type:ty, $attrib_type:ident) =\u003e {\n\t\tmake_payload!(PlayerUpdate, true, $type, AttributeType::$attrib_type);\n\t};\n}\n\nmacro_rules! make_object_update_payload {\n\t($type:ty, $attrib_type:ident) =\u003e {\n\t\tmake_payload!(ObjectUpdate, false, $type, AttributeType::$attrib_type);\n\t};\n}\n\nfor_each_type!(make_player_update_payload);\nfor_each_type!(make_object_update_payload);\n\npub use for_each_type;\n","traces":[{"line":62,"address":[],"length":0,"stats":{"Line":363},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":363},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","replication","udp","mod.rs"],"content":"mod consumer;\nmod control;\nmod entities;\nmod events;\nmod macros;\nmod packet;\nmod producer;\n\npub use {consumer::Consumer, producer::Producer};\n\n/// A trait that describes a single item of replication data.\npub trait Datum: std::fmt::Debug + Clone {\n\tfn apply(\u0026self, global: \u0026std::sync::Arc\u003ccrate::global::GlobalState\u003e);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","replication","udp","packet.rs"],"content":"use {\n\tsuper::Datum,\n\tquark_client_sdk::{AttributeIndexError, AttributeType},\n\tstd::{fmt::Debug, marker::PhantomData, mem::size_of},\n};\n\n/// Maximum Transmission Unit\n///\n/// This is the maximum payload size of a UDP packet that guarantees\n/// that it will not be fragmented by the network.\nconst MTU_PAYLOAD_LEN: usize = 1400;\n\n/// A raw static buffer that can hold a single unfragmented UDP packet.\n#[repr(align(8))]\n#[derive(Debug)]\npub struct MTUBytes([u8; MTU_PAYLOAD_LEN]);\n\nimpl MTUBytes {\n\tpub const fn header(\u0026self) -\u003e Option\u003c\u0026PacketHeader\u003e {\n\t\tPacketHeader::peek(\u0026self.0)\n\t}\n}\n\nimpl Default for MTUBytes {\n\tfn default() -\u003e Self {\n\t\tlet mut buffer = [0; MTU_PAYLOAD_LEN];\n\t\tlet header = PacketHeader::peek_mut(\u0026mut buffer).unwrap();\n\t\theader.update_type = UpdateType::Invalid;\n\t\theader.packet_size = size_of::\u003cPacketHeader\u003e() as u16;\n\t\tSelf(buffer)\n\t}\n}\n\n/// Gets the raw bytes representation of the MTU buffer for sending it over the\n/// wire.\nimpl AsRef\u003c[u8]\u003e for MTUBytes {\n\tfn as_ref(\u0026self) -\u003e \u0026[u8] {\n\t\tlet Some(header) = PacketHeader::peek(\u0026self.0) else {\n\t\t\treturn \u0026[];\n\t\t};\n\n\t\t\u0026self.0[0..header.packet_size as usize]\n\t}\n}\n\nimpl AsMut\u003c[u8]\u003e for MTUBytes {\n\tfn as_mut(\u0026mut self) -\u003e \u0026mut [u8] {\n\t\t\u0026mut self.0[..]\n\t}\n}\n\nimpl\u003cP: Payload\u003e From\u003cPacket\u003cP\u003e\u003e for MTUBytes {\n\tfn from(packet: Packet\u003cP\u003e) -\u003e Self {\n\t\tpacket.payload\n\t}\n}\n\n/// Specifies what the packet is carrying.\n///\n/// Real world observations show that the majority of updates are streams of\n/// updates to similar attributes of the same entity, such as thousands of\n/// players updating their position at the same time few times a second.\n///\n/// This means that we can optimize the packet format to be able to pack\n/// multiple updates of the same type into a single packet and know their\n/// size in advance.\n///\n/// For sporadic updates that are not of the same type, we can still pack them\n/// into a single packet, but we are also ok with using a single packet for\n/// each update. Those cases represent a small percentage of the total updates\n/// and are not worth optimizing for.\n#[repr(C)]\npub enum UpdateType {\n\t/// This type of updates is used to indicate that the packet is\n\t/// invalid and should be ignored.\n\tInvalid,\n\n\t/// Control updates are used internally by the replication system to indicate\n\t/// things like a player connecting or disconnecting to a node, heartbeats,\n\t/// or quality control messages.\n\tControl,\n\n\t/// This type of updates carries events emitted by players or the system.\n\t/// Events sent to a node must be published to all players that are relevant\n\t/// to the player that emitted the event.\n\t///\n\t/// The parameter is the length of the event payload.\n\tEvent(u8),\n\n\t/// This type of updates carries changes to attributes of either players or\n\t/// objects.\n\t///\n\t/// This field encodes three pieces of information:\n\t/// - The type of the entity that is being updated (object or player). This\n\t///   is represents by the highest bit of the field. If it is a player then\n\t///   the bit is set to 1, if it is an object then the bit is set to 0. This\n\t///   information determines the length of the entity ID that follows.\n\t/// - The type of the attributes that are being updated. This is represented\n\t///   by the lower 6 bits of the field. The type of the attributes determines\n\t///   the size of the attribute values that follow.\n\tEntity(EntityUpdateMeta),\n}\n\nimpl UpdateType {\n\tpub const fn _control() -\u003e Self {\n\t\tSelf::Control\n\t}\n\n\tpub const fn event(len: u8) -\u003e Self {\n\t\tSelf::Event(len)\n\t}\n\n\tpub const fn entity(is_player: bool, attribute_type: AttributeType) -\u003e Self {\n\t\tlet mut meta = 0;\n\t\tif is_player {\n\t\t\tmeta |= 0b1000_0000;\n\t\t}\n\t\tmeta |= attribute_type as u8;\n\t\tSelf::Entity(EntityUpdateMeta(meta))\n\t}\n}\n\n/// Encodes details about the entity that is being updated.\n#[repr(transparent)]\npub struct EntityUpdateMeta(u8);\n\nimpl EntityUpdateMeta {\n\t/// The type of the entity that is being updated.\n\t///\n\t/// If it is a player then the bit is set to 1, if it is an object then the\n\t/// bit is set to 0. This information determines the length of the entity ID\n\t/// that follows.\n\t#[inline(always)]\n\tpub const fn is_player(\u0026self) -\u003e bool {\n\t\tself.0 \u0026 0b1000_0000 != 0\n\t}\n\n\t/// The type of the attributes that are being updated.\n\t///\n\t/// This is represented by the lower 6 bits of the field. The type of the\n\t/// attributes determines the size of the attribute values that follow.\n\t#[inline(always)]\n\tpub fn attribute_type(\u0026self) -\u003e Result\u003cAttributeType, AttributeIndexError\u003e {\n\t\tlet unmask: u8 = self.0 \u0026 0b0011_1111;\n\t\tunmask.try_into()\n\t}\n}\n\nimpl Debug for UpdateType {\n\tfn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n\t\tmatch self {\n\t\t\tSelf::Invalid =\u003e write!(f, \"Invalid\"),\n\t\t\tSelf::Control =\u003e write!(f, \"Control\"),\n\t\t\tSelf::Event(n) =\u003e write!(f, \"Event({n})\"),\n\t\t\tSelf::Entity(meta) =\u003e {\n\t\t\t\twrite!(\n\t\t\t\t\tf,\n\t\t\t\t\t\"Entity {{ is_player: {}, attribute_type: {:?} }}\",\n\t\t\t\t\tmeta.is_player(),\n\t\t\t\t\tmeta.attribute_type()\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t}\n}\n\n/// A packet header that is prepended to the payload.\n///\n/// It contains the type of the updates that are stored in the packet,\n/// Updates inside one packet are always of the same size to make packing\n/// them into a single UDP packet easier, and to allow safe concurrent\n/// access to the packet data and safe casting of the data.\n#[repr(align(8))]\npub struct PacketHeader {\n\tupdate_type: UpdateType,\n\tpacket_size: u16,\n}\n\nimpl Debug for PacketHeader {\n\tfn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n\t\twrite!(f, \"{:?}[{}]\", self.update_type, self.packet_size)\n\t}\n}\n\nimpl PacketHeader {\n\t/// The type of the updates that are stored in the packet.\n\tpub const fn update_type(\u0026self) -\u003e \u0026UpdateType {\n\t\t\u0026self.update_type\n\t}\n\n\t/// The number of bytes actually used in the packet.\n\tpub const fn packet_size(\u0026self) -\u003e usize {\n\t\tself.packet_size as usize\n\t}\n\n\t/// Gets a byte representation of the header.\n\tconst fn as_bytes(\u0026self) -\u003e \u0026[u8] {\n\t\t// SAFETY: this is safe because the header is always initialized\n\t\t// during packet construction and the address is within the memory\n\t\t// address of the containing MTBytes buffer.\n\t\tunsafe {\n\t\t\tlet ptr = self as *const Self as *const u8;\n\t\t\tcore::slice::from_raw_parts(ptr, size_of::\u003cSelf\u003e())\n\t\t}\n\t}\n\n\t/// Tries to decode a header from a buffer.\n\t/// Fails if the buffer is not large enough to hold the header,\n\t/// or if the header is invalid.\n\t///\n\t/// It is up to the caller to ensure that the buffer is a valid\n\t/// UDP replication packet.\n\tpub const fn peek(buffer: \u0026[u8]) -\u003e Option\u003c\u0026Self\u003e {\n\t\tif buffer.len() \u003c size_of::\u003cSelf\u003e() {\n\t\t\treturn None;\n\t\t}\n\n\t\t// SAFETY: We've already checked that the buffer is large enough\n\t\tSome(unsafe { \u0026*(buffer.as_ptr() as *const Self) })\n\t}\n\n\t/// Tries to decode a header from a buffer.\n\t/// Fails if the buffer is not large enough to hold the header,\n\t/// or if the header is invalid.\n\t///\n\t/// It is up to the caller to ensure that the buffer is a valid\n\t/// UDP replication packet.\n\tpub fn peek_mut(buffer: \u0026mut [u8]) -\u003e Option\u003c\u0026mut Self\u003e {\n\t\tif buffer.len() \u003c size_of::\u003cSelf\u003e() {\n\t\t\treturn None;\n\t\t}\n\n\t\t// SAFETY: We've already checked that the buffer is large enough\n\t\tSome(unsafe { \u0026mut *(buffer.as_ptr() as *mut Self) })\n\t}\n}\n\n/// A datum is a single update to an attribute of an entity.\n/// Things that are considered datums are:\n/// - An update of a an entity of a known type (player/object) to a known\n///   attribute of a known type (entity attrib vs conponent attrib) with a value\n///   of a known type.\n/// - An event emitted by a player or the system.\n/// - A control message (heartbeat, etc).\npub trait Payload: Sized {\n\t/// A single datum that can be stored in a packet.\n\ttype Item: Datum + Sized;\n\n\t/// The header that describes what kind of payload this packet is carrying,\n\t/// and how to process it.\n\tfn kind() -\u003e UpdateType;\n}\n\n/// A packet buffer that can be used to construct a packet\n/// The buffer is initialized with a header and storage for datums of given\n/// type. It is used to accumulate and batch datums before they are sent over\n/// the network up to the MTU size.\n///\n/// A packet buffer always has a fixed capacity and holds datums of equal sizes.\n/// One packet can hold up to `PacketBuf::capacity()` datums, and can update\n/// either player or object entities.\n#[repr(transparent)]\npub struct Packet\u003cP: Payload\u003e {\n\tpayload: MTUBytes,\n\t_p: PhantomData\u003cP\u003e,\n}\n\nimpl\u003cP: Payload\u003e AsRef\u003c[u8]\u003e for Packet\u003cP\u003e {\n\tfn as_ref(\u0026self) -\u003e \u0026[u8] {\n\t\tself.bytes()\n\t}\n}\n\nimpl\u003cP: Payload\u003e Default for Packet\u003cP\u003e {\n\tfn default() -\u003e Self {\n\t\tlet mut payload = MTUBytes([0; MTU_PAYLOAD_LEN]);\n\n\t\tlet header = PacketHeader {\n\t\t\tupdate_type: P::kind(),\n\t\t\tpacket_size: size_of::\u003cPacketHeader\u003e() as u16,\n\t\t};\n\n\t\tpayload.as_mut()[0..header.as_bytes().len()]\n\t\t\t.copy_from_slice(header.as_bytes());\n\n\t\tSelf {\n\t\t\tpayload,\n\t\t\t_p: PhantomData,\n\t\t}\n\t}\n}\n\nimpl\u003cP: Payload\u003e Packet\u003cP\u003e {\n\tconst LAST_WRITE_POS: usize =\n\t\t((Self::MAX_PAYLOAD_LEN / size_of::\u003cP::Item\u003e()) * size_of::\u003cP::Item\u003e())\n\t\t\t+ size_of::\u003cPacketHeader\u003e();\n\tconst MAX_PAYLOAD_LEN: usize = MTU_PAYLOAD_LEN - size_of::\u003cPacketHeader\u003e();\n\n\t/// Attempts to put a datum into the packet buffer.\n\t/// Fails if the packet buffer is already full.\n\tpub fn try_push(\u0026mut self, datum: P::Item) -\u003e Result\u003c(), P::Item\u003e {\n\t\tlet ptr = self.payload.0.as_ptr();\n\t\tlet buffer = \u0026mut self.payload.0;\n\t\tlet Some(header) = PacketHeader::peek_mut(buffer) else {\n\t\t\treturn Err(datum);\n\t\t};\n\n\t\tif header.packet_size as usize == Self::LAST_WRITE_POS {\n\t\t\treturn Err(datum);\n\t\t}\n\n\t\tunsafe {\n\t\t\tlet slot = ptr.add(header.packet_size as usize) as *mut P::Item;\n\t\t\t*slot = datum;\n\t\t}\n\n\t\theader.packet_size += size_of::\u003cP::Item\u003e() as u16;\n\t\tOk(())\n\t}\n\n\t/// Returns the number of datums stored in the packet.\n\tpub fn len(\u0026self) -\u003e usize {\n\t\tself.datums().len()\n\t}\n\n\t/// Returns true if the packet is empty and does not contain any datums.\n\tpub fn is_empty(\u0026self) -\u003e bool {\n\t\tself.len() == 0\n\t}\n\n\t/// Returns the raw bytes of the packet payload.\n\t/// This includes the header and the datums.\n\t///\n\t/// This buffer can be sent over the wire as is.\n\tpub fn bytes(\u0026self) -\u003e \u0026[u8] {\n\t\tlet Some(header) = PacketHeader::peek(\u0026self.payload.0) else {\n\t\t\treturn \u0026[];\n\t\t};\n\n\t\t\u0026self.payload.as_ref()[0..header.packet_size as usize]\n\t}\n\n\t/// Returns the datums stored in the packet.\n\t/// This does not include the header.\n\t/// This is useful for iterating over the datums without incurring copies.\n\tpub fn datums(\u0026self) -\u003e \u0026[P::Item] {\n\t\t// SAFETY: this is safe because the packet is guaranteed to be\n\t\t// initialized as long as its index is less than writepos\n\t\t// and the writepos is guaranteed to be within bounds.\n\t\tunsafe {\n\t\t\tlet ptr = self.payload.as_ref().as_ptr();\n\t\t\tlet packet_header = \u0026*(ptr as *const PacketHeader);\n\t\t\tlet data_start_ptr = ptr.add(size_of::\u003cPacketHeader\u003e());\n\t\t\tlet data_end_ptr = ptr.add(packet_header.packet_size as usize);\n\t\t\tlet data_len = data_end_ptr as usize - data_start_ptr as usize;\n\t\t\tlet datum_count = data_len / core::mem::size_of::\u003cP::Item\u003e();\n\t\t\tcore::slice::from_raw_parts(data_start_ptr as *const P::Item, datum_count)\n\t\t}\n\t}\n\n\t/// Removes the last datum from the packet and returns it.\n\t///\n\t/// This is used when compacting datums that are fragmented across\n\t/// multiple packets. The space left by the removed datum is zeroed out.\n\tpub fn pop(\u0026mut self) -\u003e Option\u003cP::Item\u003e {\n\t\tif self.is_empty() {\n\t\t\treturn None;\n\t\t}\n\n\t\tlet ptr = self.payload.0.as_ptr();\n\t\tlet buffer = \u0026mut self.payload.0;\n\n\t\tlet header = PacketHeader::peek_mut(buffer)?;\n\n\t\t// SAFETY: this is safe because the packet is guaranteed to be\n\t\t// initialized and the writepos is guaranteed to be within bounds.\n\t\tunsafe {\n\t\t\tlet last_datum_offset =\n\t\t\t\t(header.packet_size as usize) - core::mem::size_of::\u003cP::Item\u003e();\n\n\t\t\tlet datum = ptr.add(last_datum_offset) as *const P::Item;\n\n\t\t\tlet mut_datum = datum as *mut P::Item;\n\t\t\tlet datum = datum.read();\n\n\t\t\t// zero out the removed datum\n\t\t\tmut_datum.write_bytes(0, 1);\n\n\t\t\theader.packet_size -= size_of::\u003cP::Item\u003e() as u16;\n\n\t\t\tSome(datum)\n\t\t}\n\t}\n}\n\nimpl\u003cP: Payload\u003e Debug for Packet\u003cP\u003e {\n\tfn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n\t\twrite!(f, \"UDP Packet({:?})\", self.datums())\n\t}\n}\n\nimpl\u003cP: Payload\u003e From\u003cMTUBytes\u003e for Packet\u003cP\u003e {\n\tfn from(payload: MTUBytes) -\u003e Self {\n\t\tSelf {\n\t\t\tpayload,\n\t\t\t_p: PhantomData,\n\t\t}\n\t}\n}\n\n#[cfg(test)]\nimpl\u003cP: Payload\u003e Packet\u003cP\u003e {\n\t/// Returns the maximum number of datums of given paramters that can be stored\n\t/// in a packet.\n\tpub const fn capacity(\u0026self) -\u003e usize {\n\t\tSelf::MAX_PAYLOAD_LEN / size_of::\u003cP::Item\u003e()\n\t}\n\n\t/// Returns true if the packet is full and cannot accept any more datums.\n\tpub fn full(\u0026self) -\u003e bool {\n\t\tself.len() == self.capacity()\n\t}\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":174},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":174},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":113},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":113},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":113},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":113},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":113},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":113},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":2063},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":4126},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":501},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":501},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":387},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":387},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":363},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":363},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":721},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":358},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":363},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":363},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":776},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":776},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":776},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":2237},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":2237},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":2237},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":10540},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":10540},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":10540},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":388},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":388},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":388},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":388},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":388},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":388},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":10408},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":10408},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":10408},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":20816},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":294},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":10114},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":10114},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":10114},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":10114},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":999},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":999},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":115},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":115},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":1971},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":1971},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":1971},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":1971},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":1971},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":1971},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":1971},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":1971},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":382},"fn_name":null}],"covered":76,"coverable":109},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","replication","udp","producer.rs"],"content":"use {\n\tsuper::{\n\t\tcontrol::Control,\n\t\tentities::{ObjectUpdate, PlayerUpdate},\n\t\tpacket::{MTUBytes, Packet, Payload},\n\t},\n\tcrate::{\n\t\tevents::Event,\n\t\tfor_each_type,\n\t\treplication::{self, udp::events::EventDatum},\n\t\tstate::{\n\t\t\tentity::{Entity, EntityChanges},\n\t\t\tplayer::PlayerId,\n\t\t\tDespawnedEntity,\n\t\t\tEntityId,\n\t\t},\n\t},\n\tarrayvec::{ArrayString, ArrayVec},\n\tcrossbeam::queue::SegQueue,\n\tdashmap::DashMap,\n\tfxhash::FxBuildHasher,\n\tmetrics::{histogram, increment_counter},\n\tquark_client_sdk::{Recipient, MAX_PAYLOAD_LEN, MAX_SEQUENCE_LENGTH},\n\tseq_macro::seq,\n\tstd::{\n\t\tany::{Any, TypeId},\n\t\tnet::SocketAddr,\n\t\tsync::Arc,\n\t},\n\tthiserror::Error,\n\ttracing::info,\n\turl::Url,\n};\n\n#[derive(Debug, Error)]\npub enum Error {}\n\npub struct Producer {\n\tqueues: Arc\u003cPacketQueues\u003e,\n}\n\nimpl Producer {\n\tpub fn new(endpoints: \u0026[Url]) -\u003e Result\u003cSelf, Error\u003e {\n\t\tlet endpoints: Vec\u003cSocketAddr\u003e = endpoints\n\t\t\t.iter()\n\t\t\t.flat_map(|url| {\n\t\t\t\turl\n\t\t\t\t\t.socket_addrs(|| Some(5671))\n\t\t\t\t\t.expect(\"failed to parse udp replication target address\")\n\t\t\t})\n\t\t\t.collect();\n\n\t\tinfo!(\"udp state replication to {endpoints:?}\");\n\n\t\tlet queues = Arc::new(PacketQueues::default());\n\t\t// start the publish loop on the background\n\t\ttokio::spawn(publish_loop(endpoints, Arc::clone(\u0026queues)));\n\n\t\tOk(Self { queues })\n\t}\n}\n\nimpl replication::Producer for Producer {\n\tfn entity(\n\t\t\u0026self,\n\t\tid: EntityId,\n\t\tchanges: \u0026EntityChanges,\n\t\tentity: \u0026Entity,\n\t\tauthor: PlayerId,\n\t) {\n\t\t// push changes on direct attributes\n\t\tfor (attribute_id, change) in changes.attributes.iter() {\n\t\t\tlet Some(value) = entity.attributes().get(*attribute_id) else {\n\t\t\t\tcontinue;\n\t\t\t};\n\n\t\t\tmatch id {\n\t\t\t\tEntityId::Player(id) =\u003e {\n\t\t\t\t\tmacro_rules! push_player_update {\n\t\t\t\t\t\t($type:ty, $attrib_type:ident) =\u003e {\n\t\t\t\t\t\t\tif let quark_client_sdk::Value::$attrib_type(v) = value {\n\t\t\t\t\t\t\t\tlet update = PlayerUpdate {\n\t\t\t\t\t\t\t\t\tplayer_id: id,\n\t\t\t\t\t\t\t\t\tattribute_id: *attribute_id,\n\t\t\t\t\t\t\t\t\tupdate: *change,\n\t\t\t\t\t\t\t\t\tvalue: v,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tself.queues.push::\u003cPlayerUpdate\u003c$type\u003e\u003e(update);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tfor_each_type!(push_player_update);\n\t\t\t\t}\n\t\t\t\tEntityId::Object(id) =\u003e {\n\t\t\t\t\tmacro_rules! push_object_update {\n\t\t\t\t\t\t($type:ty, $attrib_type:ident) =\u003e {\n\t\t\t\t\t\t\tif let quark_client_sdk::Value::$attrib_type(v) = value {\n\t\t\t\t\t\t\t\tlet update = ObjectUpdate {\n\t\t\t\t\t\t\t\t\tobject_id: id,\n\t\t\t\t\t\t\t\t\tauthor,\n\t\t\t\t\t\t\t\t\tattribute_id: *attribute_id,\n\t\t\t\t\t\t\t\t\tupdate: *change,\n\t\t\t\t\t\t\t\t\tvalue: v,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tself.queues.push::\u003cObjectUpdate\u003c$type\u003e\u003e(update);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tfor_each_type!(push_object_update);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\tfn event(\u0026self, event: \u0026Event, recipient: \u0026Recipient) {\n\t\tlet payload_len = event.payload.len();\n\t\tassert!(payload_len \u003c= MAX_PAYLOAD_LEN);\n\n\t\tseq!(N in 0..256 {\n\t\t\tstatic DISPATCH_FN: [fn(\u0026Producer, \u0026Event, \u0026Recipient); MAX_PAYLOAD_LEN] = [\n\t\t\t\t#(\n\t\t\t\t\t|this, event, recipient| {\n\t\t\t\t\t\tlet datum = EventDatum::\u003cN\u003e::from(event, recipient);\n\t\t\t\t\t\tthis.queues.push::\u003cEventDatum\u003cN\u003e\u003e(datum);\n\t\t\t\t\t},\n\t\t\t\t)*\n\t\t\t];\n\t\t});\n\n\t\tDISPATCH_FN[payload_len](self, event, recipient);\n\t}\n\n\tfn spawn(\u0026self, id: EntityId, _entity: \u0026Entity) {\n\t\tif let EntityId::Player(id) = id {\n\t\t\tself.queues.push::\u003cControl\u003e(Control::PlayerConnected(id));\n\t\t}\n\n\t\t// object despawns are not replicated through UDP.\n\t}\n\n\tfn despawn(\u0026self, id: DespawnedEntity) {\n\t\tmatch id {\n\t\t\tDespawnedEntity::Player(id, resume_token) =\u003e {\n\t\t\t\tself.queues.push::\u003cControl\u003e(Control::PlayerDisconnected(\n\t\t\t\t\tid,\n\t\t\t\t\tresume_token.as_bytes().try_into().unwrap_or_default(),\n\t\t\t\t));\n\t\t\t}\n\t\t\tDespawnedEntity::Object(id) =\u003e {\n\t\t\t\tself.queues.push::\u003cControl\u003e(Control::ObjectDespawned(id));\n\t\t\t}\n\t\t};\n\t}\n}\n\nasync fn publish_loop(endpoints: Vec\u003cSocketAddr\u003e, queues: Arc\u003cPacketQueues\u003e) {\n\tlet socket = tokio::net::UdpSocket::bind(\"0.0.0.0:0\")\n\t\t.await\n\t\t.expect(\"failed to bind udp replication socket\");\n\n\tlet mut packets = Vec::\u003cMTUBytes\u003e::default();\n\n\tmacro_rules! pop_player_update_packet {\n\t\t($datum:ty, $attrib_type:expr) =\u003e {\n\t\t\tif let Some(packet) = queues.pop::\u003cPlayerUpdate\u003c$datum\u003e\u003e() {\n\t\t\t\thistogram!(\n\t\t\t\t\t\"udp_replication_produced_packets_datum_count\",\n\t\t\t\t\tpacket.datums().len() as f64\n\t\t\t\t);\n\t\t\t\tincrement_counter!(\"udp_replication_entity_packets\");\n\t\t\t\tpackets.push((*packet).into());\n\t\t\t}\n\t\t};\n\t}\n\n\tmacro_rules! pop_object_update_packet {\n\t\t($datum:ty, $attrib_type:expr) =\u003e {\n\t\t\tif let Some(packet) = queues.pop::\u003cObjectUpdate\u003c$datum\u003e\u003e() {\n\t\t\t\thistogram!(\n\t\t\t\t\t\"udp_replication_produced_packets_datum_count\",\n\t\t\t\t\tpacket.datums().len() as f64\n\t\t\t\t);\n\t\t\t\tincrement_counter!(\"udp_replication_entity_packets\");\n\t\t\t\tpackets.push((*packet).into());\n\t\t\t}\n\t\t};\n\t}\n\n\tloop {\n\t\t// pop all entity update packets from the queues\n\t\tfor_each_type!(pop_player_update_packet);\n\t\tfor_each_type!(pop_object_update_packet);\n\n\t\t// pop all event packets from the queues\n\t\tseq!(N in 0..256 {\n\t\t\tif let Some(packet) = queues.pop::\u003cEventDatum\u003cN\u003e\u003e() {\n\t\t\t\thistogram!(\n\t\t\t\t\t\"udp_replication_produced_packets_datum_count\",\n\t\t\t\t\tpacket.datums().len() as f64\n\t\t\t\t);\n\t\t\t\tincrement_counter!(\"udp_replication_event_packets\");\n\t\t\t\tpackets.push((*packet).into());\n\t\t\t}\n\t\t});\n\n\t\t// pop all control packets from the queues\n\t\tif let Some(packet) = queues.pop::\u003cControl\u003e() {\n\t\t\thistogram!(\n\t\t\t\t\"udp_replication_produced_packets_datum_count\",\n\t\t\t\tpacket.datums().len() as f64\n\t\t\t);\n\t\t\tincrement_counter!(\"udp_replication_control_packets\");\n\t\t\tpackets.push((*packet).into());\n\t\t}\n\n\t\tif packets.is_empty() {\n\t\t\ttokio::task::yield_now().await;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor packet in \u0026packets {\n\t\t\tfor endpoint in \u0026endpoints {\n\t\t\t\tsocket\n\t\t\t\t\t.send_to(packet.as_ref(), endpoint)\n\t\t\t\t\t.await\n\t\t\t\t\t.expect(\"failed to send udp packet\");\n\n\t\t\t\tincrement_counter!(\"udp_replication_packets_sent_count\");\n\t\t\t\thistogram!(\n\t\t\t\t\t\"udp_replication_sent_packet_size\",\n\t\t\t\t\tpacket.as_ref().len() as f64\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tpackets.clear();\n\t}\n}\n\n/// This type holds collections of MTU-sized packets that are ready to be sent\n/// or are being filled with datums. It guarantees that a datum pushed to this\n/// queue will be placed in some output packet at some point.\n///\n/// There is no guarantee on the order of datums in the output packets or\n/// the order of output packets themselves.\n///\n/// This queue will attempt to accumulate as many datums as possible into\n/// as few packets as possible to reduce network bandwidth usage.\npub struct PacketQueue\u003cP: Payload\u003e {\n\t/// A list of packets that are sill being filled with datums.\n\tinqueue: SegQueue\u003cBox\u003cPacket\u003cP\u003e\u003e\u003e,\n\n\t/// A list of packets that are ready to be sent.\n\toutqueue: SegQueue\u003cBox\u003cPacket\u003cP\u003e\u003e\u003e,\n}\n\nimpl\u003cP: Payload\u003e Default for PacketQueue\u003cP\u003e {\n\tfn default() -\u003e Self {\n\t\tSelf {\n\t\t\tinqueue: SegQueue::default(),\n\t\t\toutqueue: SegQueue::default(),\n\t\t}\n\t}\n}\n\nimpl\u003cP: Payload\u003e PacketQueue\u003cP\u003e {\n\t#[cfg(test)]\n\tpub fn is_empty(\u0026self) -\u003e bool {\n\t\tself.inqueue.is_empty() \u0026\u0026 self.outqueue.is_empty()\n\t}\n\n\t/// Pops a packet from the queue that is ready to be sent over the network.\n\t/// If there are no packets in the queue, returns `None`.\n\t///\n\t/// This function will try to accumulate datums from multiple packets\n\t/// into a single packet if packets are not full.\n\tpub fn pop(\u0026self) -\u003e Option\u003cBox\u003cPacket\u003cP\u003e\u003e\u003e {\n\t\tloop {\n\t\t\tmatch self.outqueue.pop() {\n\t\t\t\tSome(packet) =\u003e {\n\t\t\t\t\treturn Some(packet);\n\t\t\t\t}\n\t\t\t\tNone =\u003e {\n\t\t\t\t\tlet Some(packet) = self.inqueue.pop() else {\n\t\t\t\t\t\t// no packets left in the inqueue, return None\n\t\t\t\t\t\treturn None;\n\t\t\t\t\t};\n\n\t\t\t\t\tif packet.is_empty() {\n\t\t\t\t\t\t// this packet is empty, drop it anyway and\n\t\t\t\t\t\t// try to pop another one\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// This is temporarily leaked on purpose.\n\t\t\t\t\t// The leaked reference does not leave this function without\n\t\t\t\t\t// being wrapped in a Box again, so it is safe to do so.\n\t\t\t\t\t// it is done hear to get a mutable reference to the packet\n\t\t\t\t\t// and we know that here we are the only ones that have a\n\t\t\t\t\t// reference to it.\n\t\t\t\t\tlet packet = Box::leak(packet);\n\n\t\t\t\t\t// we have a packet with some data in it but it is not full\n\t\t\t\t\t// try to accumulate more data from the inqueue into this packet\n\t\t\t\t\t// until it is full to increase batching and save network bandwidth\n\t\t\t\t\t'accum: loop {\n\t\t\t\t\t\tlet Some(mut next_packet) = self.inqueue.pop() else {\n\t\t\t\t\t\t\t// we don't have any more packets, return the one we\n\t\t\t\t\t\t\t// have with at least some data in it.\n\t\t\t\t\t\t\treturn Some(unsafe { Box::from_raw(packet as *mut Packet\u003cP\u003e) });\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tif next_packet.is_empty() {\n\t\t\t\t\t\t\t// this packet is empty, free it and try to pop another one\n\t\t\t\t\t\t\tunsafe { drop(Box::from_raw(packet as *mut Packet\u003cP\u003e)) };\n\t\t\t\t\t\t\tcontinue 'accum;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twhile let Some(datum) = next_packet.pop() {\n\t\t\t\t\t\t\tif let Err(d) = packet.try_push(datum) {\n\t\t\t\t\t\t\t\t// accumulated enough datums from next packets to fill\n\t\t\t\t\t\t\t\t// the outgoing packet, push it to the outqueue and\n\t\t\t\t\t\t\t\t// put the current packet back in the inqueue\n\t\t\t\t\t\t\t\tself\n\t\t\t\t\t\t\t\t\t.outqueue\n\t\t\t\t\t\t\t\t\t.push(unsafe { Box::from_raw(packet as *mut Packet\u003cP\u003e) });\n\n\t\t\t\t\t\t\t\t// return the datum that didn't fit in the packet\n\t\t\t\t\t\t\t\t// back to the inqueue\n\t\t\t\t\t\t\t\tif next_packet.try_push(d).is_err() {\n\t\t\t\t\t\t\t\t\t// not using .expect() or .unwrap() to not require\n\t\t\t\t\t\t\t\t\t// P::Item to implement Debug.\n\t\t\t\t\t\t\t\t\tunreachable!(\"returning item to a packet failed\");\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tself.inqueue.push(next_packet);\n\t\t\t\t\t\t\t\tbreak 'accum;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/// Pushes a datum to a packet that will be sent over the network.\n\t///\n\t/// This function will keep trying to push the datum to the next packet\n\t/// if the current packet is full until it finds an empty slot.\n\tpub fn push(\u0026self, datum: P::Item) {\n\t\tlet mut datum = datum;\n\t\tloop {\n\t\t\tlet Some(packet) = self.inqueue.pop() else {\n\t\t\t\t// no packets in the inqueue, create a new one\n\t\t\t\t// push this datum to it and put it in the inqueue\n\t\t\t\tlet mut packet = Packet::\u003cP\u003e::default();\n\n\t\t\t\t// not using .expect() or .unwrap() to not require\n\t\t\t\t// P::Item to implement Debug.\n\t\t\t\tif packet.try_push(datum).is_err() {\n\t\t\t\t\tunreachable!(\"pushing to an empty packet failed\");\n\t\t\t\t}\n\n\t\t\t\tself.inqueue.push(Box::new(packet));\n\t\t\t\treturn;\n\t\t\t};\n\n\t\t\t// This is temporarily leaked on purpose.\n\t\t\t// we are the only ones that have a reference to it\n\t\t\t// and we need to get a mutable reference to it.\n\t\t\tlet packet = Box::leak(packet);\n\n\t\t\tmatch packet.try_push(datum) {\n\t\t\t\tOk(()) =\u003e {\n\t\t\t\t\t// successfully pushed the datum to a packet\n\t\t\t\t\t// put the packet in the inqueue again and return\n\t\t\t\t\tself\n\t\t\t\t\t\t.inqueue\n\t\t\t\t\t\t.push(unsafe { Box::from_raw(packet as *mut Packet\u003cP\u003e) });\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tErr(datum_) =\u003e {\n\t\t\t\t\t// this packet is full, push it to the outqueue\n\t\t\t\t\t// and keep trying to push the datum to the next packet\n\t\t\t\t\t// it will be sent over the network, then reset and returned to the\n\t\t\t\t\t// inqueue\n\t\t\t\t\tdatum = datum_;\n\t\t\t\t\tself\n\t\t\t\t\t\t.outqueue\n\t\t\t\t\t\t.push(unsafe { Box::from_raw(packet as *mut Packet\u003cP\u003e) });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/// Aggregator of packet queues for different payload types.\n#[derive(Default)]\nstruct PacketQueues {\n\t/// A map of packet queues for each payload type.\n\tqueues: DashMap\u003cTypeId, Box\u003cdyn Any + Send + Sync\u003e, FxBuildHasher\u003e,\n}\n\nimpl PacketQueues {\n\t/// Routes a datum to the appropriate packet queue.\n\tpub fn push\u003cP: Payload + Send + Sync + 'static\u003e(\u0026self, datum: P::Item) {\n\t\t// we're using get/match/insert/get instead of entry API\n\t\t// to avoid getting a RefMut which holds a lock on the\n\t\t// entry. PacketQueue is thread safe and we don't need\n\t\t// an extra layer of synchronization here.\n\t\tlet id = TypeId::of::\u003cP\u003e();\n\t\tlet packet_queue = match self.queues.get(\u0026id) {\n\t\t\tSome(packet_queue) =\u003e packet_queue,\n\t\t\tNone =\u003e {\n\t\t\t\tlet packet_queue = Box::\u003cPacketQueue\u003cP\u003e\u003e::default();\n\t\t\t\tself.queues.insert(id, packet_queue);\n\t\t\t\tself.queues.get(\u0026id).unwrap()\n\t\t\t}\n\t\t};\n\n\t\t// convert the opaque pointer to a concrete queue type\n\t\tlet packet_queue = packet_queue\n\t\t\t.value()\n\t\t\t.downcast_ref::\u003cPacketQueue\u003cP\u003e\u003e()\n\t\t\t.expect(\"bug: queues map contains a wrong type\");\n\n\t\t// push the datum to the queue\n\t\tpacket_queue.push(datum);\n\t}\n\n\t/// Pops a packet from the appropriate packet queue if available.\n\tpub fn pop\u003cP: Payload + Send + Sync + 'static\u003e(\n\t\t\u0026self,\n\t) -\u003e Option\u003cBox\u003cPacket\u003cP\u003e\u003e\u003e {\n\t\tlet id = TypeId::of::\u003cP\u003e();\n\n\t\tlet packet_queue = self.queues.get(\u0026id)?;\n\n\t\t// convert the opaque pointer to a concrete queue type\n\t\tlet packet_queue = packet_queue\n\t\t\t.value()\n\t\t\t.downcast_ref::\u003cPacketQueue\u003cP\u003e\u003e()\n\t\t\t.expect(\"bug: queues map contains a wrong type\");\n\n\t\thistogram!(\n\t\t\t\"udp_replication_produced_packets_backlog_count\",\n\t\t\tpacket_queue.outqueue.len() as f64\n\t\t);\n\n\t\t// pop a packet from the queue\n\t\tpacket_queue.pop()\n\t}\n}\n\n#[cfg(test)]\nmod test {\n\tuse {\n\t\tsuper::*,\n\t\tcrate::state::{\n\t\t\tentity::{AttributeChange, AttributeId},\n\t\t\tTimestamp,\n\t\t},\n\t\trayon::iter::{IntoParallelIterator, ParallelIterator},\n\t};\n\n\t#[test]\n\tfn packetqueue_smoke() {\n\t\tconst TEST_SIZE: usize = 10000;\n\n\t\tlet packetqueue =\n\t\t\tsuper::PacketQueue::\u003cPlayerUpdate\u003c(f32, f32, f32)\u003e\u003e::default();\n\n\t\tassert!(packetqueue.pop().is_none());\n\n\t\t(0..TEST_SIZE).into_par_iter().for_each(|i| {\n\t\t\tpacketqueue.push(PlayerUpdate {\n\t\t\t\tplayer_id: i as PlayerId,\n\t\t\t\tattribute_id: i as AttributeId,\n\t\t\t\tupdate: AttributeChange::Updated(i as Timestamp),\n\t\t\t\tvalue: (i as f32, i as f32, i as f32),\n\t\t\t});\n\t\t});\n\n\t\tlet mut num = 0;\n\t\tlet mut seen = [false; TEST_SIZE];\n\t\twhile let Some(packet) = packetqueue.pop() {\n\t\t\t// if this is not the last packet, make sure that is it full\n\t\t\t// otherwise it is allowed to be partially full\n\t\t\t// this tests the batching logic\n\t\t\tif packetqueue.is_empty() {\n\t\t\t\tassert!(!packet.is_empty());\n\t\t\t} else {\n\t\t\t\tassert!(packet.full());\n\t\t\t}\n\n\t\t\tfor datum in packet.datums().iter() {\n\t\t\t\tlet id = datum.player_id as usize;\n\n\t\t\t\tassert!(!seen[id]);\n\t\t\t\tseen[id] = true;\n\n\t\t\t\tassert_eq!(datum.player_id, id as PlayerId);\n\t\t\t\tassert_eq!(datum.attribute_id, id as AttributeId);\n\t\t\t\tassert_eq!(datum.update, AttributeChange::Updated(id as Timestamp));\n\t\t\t\tassert_eq!(datum.value, (id as f32, id as f32, id as f32));\n\t\t\t}\n\t\t\tnum += 1;\n\n\t\t\tlet packet_len = packet.len();\n\t\t\tlet datums_copy = packet.datums().to_vec();\n\t\t\tlet mtu_bytes: MTUBytes = (*packet).into();\n\t\t\tlet restored_packet: Packet\u003cPlayerUpdate\u003c(f32, f32, f32)\u003e\u003e =\n\t\t\t\tmtu_bytes.into();\n\n\t\t\tassert_eq!(packet_len, restored_packet.len());\n\n\t\t\tfor (restored, original) in\n\t\t\t\trestored_packet.datums().iter().zip(datums_copy.iter())\n\t\t\t{\n\t\t\t\tassert_eq!(restored, original);\n\t\t\t}\n\t\t}\n\n\t\tassert!(seen.iter().all(|s| *s));\n\n\t\tassert_eq!(\n\t\t\t(TEST_SIZE as f32\n\t\t\t\t/ Packet::\u003cPlayerUpdate\u003c(f32, f32, f32)\u003e\u003e::default().capacity() as f32)\n\t\t\t\t.ceil() as usize,\n\t\t\tnum\n\t\t);\n\n\t\tassert!(seen.iter().all(|\u0026s| s));\n\t}\n}\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":116},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":140},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":1372165},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":1372165},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":1372165},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":1372189},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":1372165},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":2744179},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":1372079},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":249},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":276},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":92},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":92},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":65},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":295},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":296},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":4198169},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":4198170},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":4198170},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":294},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":294},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":10095},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":10095},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":20389},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":387},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":387},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":387},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":9708},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":9708},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":9708},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":9708},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":293},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":293},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":293},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":293},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":293},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":95},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":95},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":190},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":71},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":71},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":71},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":404788675},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":404788675},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":809577350},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":4197872},"fn_name":null}],"covered":106,"coverable":126},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","schema","ensure.rs"],"content":"use {\n\tsuper::{Blend, Error, Schema},\n\tcrate::objects::{AverageParams, AVERAGING_MAX_CAPACITY},\n\tsemver::Version,\n\tstd::collections::HashSet,\n};\n\npub(super) fn minimum_server_version(schema: \u0026Schema) -\u003e Result\u003c(), Error\u003e {\n\tlet version: Version = env!(\"CARGO_PKG_VERSION\").parse().unwrap();\n\n\tif !schema.meta.server_version.matches(\u0026version) {\n\t\treturn Err(Error::IncompatibleServerVersion(\n\t\t\tversion.clone(),\n\t\t\tschema.meta.server_version.clone(),\n\t\t));\n\t}\n\n\tOk(())\n}\n\n/// Ensures that no two entities in the schema have the same class ID.\npub(super) fn no_duplicate_class_ids(schema: \u0026Schema) -\u003e Result\u003c(), Error\u003e {\n\tlet mut class_ids = HashSet::new();\n\n\tfor player in \u0026schema.players {\n\t\tif !class_ids.insert(player.class_id) {\n\t\t\treturn Err(Error::DuplicateClassId(player.class_id));\n\t\t}\n\t}\n\n\tfor object in \u0026schema.objects {\n\t\tif !class_ids.insert(object.class_id) {\n\t\t\treturn Err(Error::DuplicateClassId(object.class_id));\n\t\t}\n\t}\n\n\tOk(())\n}\n\npub(super) fn no_duplicate_attribute_ids(schema: \u0026Schema) -\u003e Result\u003c(), Error\u003e {\n\tfor player in \u0026schema.players {\n\t\tlet mut attribute_ids = HashSet::new();\n\t\tfor attribute in \u0026player.attributes {\n\t\t\tif !attribute_ids.insert(attribute.key) {\n\t\t\t\treturn Err(Error::DuplicateAttributeId(\n\t\t\t\t\tplayer.class_id,\n\t\t\t\t\tattribute.key,\n\t\t\t\t));\n\t\t\t}\n\t\t}\n\t}\n\n\tfor object in \u0026schema.objects {\n\t\tlet mut attribute_ids = HashSet::new();\n\t\tfor attribute in \u0026object.attributes {\n\t\t\tif !attribute_ids.insert(attribute.key) {\n\t\t\t\treturn Err(Error::DuplicateAttributeId(\n\t\t\t\t\tobject.class_id,\n\t\t\t\t\tattribute.key,\n\t\t\t\t));\n\t\t\t}\n\t\t}\n\t}\n\n\tOk(())\n}\n\npub(super) fn average_blending_must_specify_type(\n\tschema: \u0026Schema,\n) -\u003e Result\u003c(), Error\u003e {\n\tfor object in \u0026schema.objects {\n\t\tfor attribute in \u0026object.attributes {\n\t\t\tif matches!(attribute.blend, Blend::Average { .. })\n\t\t\t\t\u0026\u0026 attribute.r#type.is_none()\n\t\t\t{\n\t\t\t\treturn Err(Error::RequiresAveragableAttributeType(\n\t\t\t\t\tobject.class_id,\n\t\t\t\t\tattribute.key,\n\t\t\t\t));\n\t\t\t}\n\t\t}\n\t}\n\n\tOk(())\n}\n\npub(super) fn average_blending_params_within_range(\n\tschema: \u0026Schema,\n) -\u003e Result\u003c(), Error\u003e {\n\tfor object in \u0026schema.objects {\n\t\tfor attribute in \u0026object.attributes {\n\t\t\tif let Blend::Average(AverageParams {\n\t\t\t\tperiod, samples, ..\n\t\t\t}) = attribute.blend\n\t\t\t{\n\t\t\t\tif period.is_zero() {\n\t\t\t\t\treturn Err(Error::InvalidAveragingPeriod(\n\t\t\t\t\t\tobject.class_id,\n\t\t\t\t\t\tattribute.key,\n\t\t\t\t\t));\n\t\t\t\t}\n\n\t\t\t\tif !(2..=AVERAGING_MAX_CAPACITY).contains(\u0026samples) {\n\t\t\t\t\treturn Err(Error::InvalidAveragingSampleCount(\n\t\t\t\t\t\tobject.class_id,\n\t\t\t\t\t\tattribute.key,\n\t\t\t\t\t));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tOk(())\n}\n\npub(super) fn correct_authority_inheritance(\n\tschema: \u0026mut Schema,\n) -\u003e Result\u003c(), Error\u003e {\n\t// set the default authority for object attributes\n\t// that do not have an authority set.\n\tfor object in schema.objects.iter_mut() {\n\t\tlet default_blend = \u0026object.blend;\n\t\tfor attr in object.attributes.iter_mut() {\n\t\t\tif *default_blend == Blend::Owner {\n\t\t\t\tif attr.blend != Blend::Owner \u0026\u0026 attr.blend != Blend::default() {\n\t\t\t\t\treturn Err(Error::IncompatibleBlending(object.class_id, attr.key));\n\t\t\t\t}\n\t\t\t\tattr.blend = Blend::Owner;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// check if attribute type is interpolable and\n\t\t\t// if its authority is aggregated\n\t\t\tif matches!(attr.blend, Blend::Average { .. })\n\t\t\t\t\u0026\u0026 !attr.r#type.map(|t| t.is_interpolable()).unwrap_or(false)\n\t\t\t{\n\t\t\t\treturn Err(Error::RequiresAveragableAttributeType(\n\t\t\t\t\tobject.class_id,\n\t\t\t\t\tattr.key,\n\t\t\t\t));\n\t\t\t}\n\n\t\t\t// otherwise if the authority is not set, or set\n\t\t\t// to default then use object's default authority.\n\t\t\tif attr.blend == Blend::default() {\n\t\t\t\tattr.blend = match default_blend {\n\t\t\t\t\tBlend::Select =\u003e Blend::default(),\n\t\t\t\t\tBlend::Owner =\u003e Blend::Owner,\n\t\t\t\t\tb @ Blend::Average { .. } =\u003e match attr.r#type {\n\t\t\t\t\t\tSome(ty) =\u003e match ty.is_interpolable() {\n\t\t\t\t\t\t\ttrue =\u003e *b,\n\t\t\t\t\t\t\tfalse =\u003e Blend::default(),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tNone =\u003e Blend::default(),\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\t// all attributes on players always have owner authority\n\tfor player in schema.players.iter_mut() {\n\t\tfor attr in player.attributes.iter_mut() {\n\t\t\tattr.blend = Blend::Owner;\n\t\t}\n\t}\n\n\tOk(())\n}\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":82},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":82},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":206},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":134},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":134},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":134},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":86},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":95},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":39},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":206},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":30},"fn_name":null}],"covered":47,"coverable":74},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","schema","get.rs"],"content":"use {\n\tsuper::{spec::AttributeSpec, Attribute, ClassId, Event, Object, Player},\n\tcrate::state::entity::AttributeId,\n};\n\npub trait GetByKey\u003cK, T\u003e {\n\tfn get_by_key(\u0026self, key: \u0026K) -\u003e Option\u003c\u0026T\u003e;\n}\n\nimpl GetByKey\u003cClassId, Player\u003e for Vec\u003cPlayer\u003e {\n\tfn get_by_key(\u0026self, key: \u0026ClassId) -\u003e Option\u003c\u0026Player\u003e {\n\t\tself\n\t\t\t.binary_search_by_key(key, |p| p.class_id)\n\t\t\t.map(|i| \u0026self[i])\n\t\t\t.ok()\n\t}\n}\n\nimpl GetByKey\u003cClassId, Object\u003e for Vec\u003cObject\u003e {\n\tfn get_by_key(\u0026self, key: \u0026ClassId) -\u003e Option\u003c\u0026Object\u003e {\n\t\tself\n\t\t\t.binary_search_by_key(key, |o| o.class_id)\n\t\t\t.map(|i| \u0026self[i])\n\t\t\t.ok()\n\t}\n}\n\nimpl GetByKey\u003cClassId, Event\u003e for Vec\u003cEvent\u003e {\n\tfn get_by_key(\u0026self, key: \u0026ClassId) -\u003e Option\u003c\u0026Event\u003e {\n\t\tself\n\t\t\t.binary_search_by_key(key, |e| e.class_id)\n\t\t\t.map(|i| \u0026self[i])\n\t\t\t.ok()\n\t}\n}\n\nimpl GetByKey\u003cAttributeId, Attribute\u003e for \u0026[Attribute] {\n\tfn get_by_key(\u0026self, key: \u0026AttributeId) -\u003e Option\u003c\u0026Attribute\u003e {\n\t\tself\n\t\t\t.binary_search_by_key(key, |a| a.key)\n\t\t\t.map(|i| \u0026self[i])\n\t\t\t.ok()\n\t}\n}\n\nimpl GetByKey\u003cAttributeId, AttributeSpec\u003e for \u0026[AttributeSpec] {\n\tfn get_by_key(\u0026self, key: \u0026AttributeId) -\u003e Option\u003c\u0026AttributeSpec\u003e {\n\t\tself\n\t\t\t.binary_search_by_key(key, |a| a.key)\n\t\t\t.map(|i| \u0026self[i])\n\t\t\t.ok()\n\t}\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":5273},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":5273},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":10556},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":10550},"fn_name":null}],"covered":20,"coverable":20},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","schema","meta.rs"],"content":"use {\n\tsuper::{Attribute, Blend, ClassId, Lifetime, Meta, Object, Ownership},\n\tcrate::objects::{AverageMethod, AverageParams},\n\tquark_client_sdk::AttributeType,\n\tschemars::{\n\t\tgen::SchemaGenerator,\n\t\tschema::{InstanceType, Schema, SchemaObject},\n\t\tJsonSchema,\n\t},\n};\n\nimpl JsonSchema for Meta {\n\tfn schema_name() -\u003e String {\n\t\t\"Meta\".into()\n\t}\n\n\tfn json_schema(gen: \u0026mut SchemaGenerator) -\u003e Schema {\n\t\tlet mut schema = SchemaObject {\n\t\t\tinstance_type: Some(InstanceType::Object.into()),\n\t\t\t..Default::default()\n\t\t};\n\t\tlet obj = schema.object();\n\t\tlet default_meta = Meta::default();\n\t\t{\n\t\t\tlet mut name_obj = \u003cString\u003e::json_schema(gen).into_object();\n\t\t\tname_obj.metadata().description = Some(\"Game world name\".into());\n\t\t\tname_obj.metadata().default = Some(default_meta.name.to_string().into());\n\t\t\tobj.properties.insert(\"name\".to_owned(), name_obj.into());\n\t\t}\n\t\t{\n\t\t\tlet mut server_version_schema_obj =\n\t\t\t\t\u003cString\u003e::json_schema(gen).into_object();\n\t\t\tserver_version_schema_obj.metadata().default =\n\t\t\t\tSome(default_meta.server_version.to_string().into());\n\t\t\tobj.properties.insert(\n\t\t\t\t\"server_version\".to_owned(),\n\t\t\t\tserver_version_schema_obj.into(),\n\t\t\t);\n\t\t}\n\n\t\tschema.into()\n\t}\n}\n\nimpl JsonSchema for Attribute {\n\tfn schema_name() -\u003e String {\n\t\t\"Attribute\".into()\n\t}\n\n\tfn json_schema(gen: \u0026mut SchemaGenerator) -\u003e Schema {\n\t\tlet mut schema = SchemaObject {\n\t\t\tinstance_type: Some(InstanceType::Object.into()),\n\t\t\t..Default::default()\n\t\t};\n\t\tlet obj = schema.object();\n\t\t{\n\t\t\tlet mut name_obj = \u003cString\u003e::json_schema(gen).into_object();\n\t\t\tname_obj.metadata().description = Some(\"Attribute's name\".into());\n\t\t\tobj.properties.insert(\"name\".to_owned(), name_obj.into());\n\t\t}\n\t\t{\n\t\t\tlet mut key_obj = SchemaObject::default();\n\t\t\tkey_obj.metadata().description = Some(\n\t\t\t\t\"Unique attribute identifier. Can have either a well known string \\\n\t\t\t\t value or integer value starting from 1000\"\n\t\t\t\t\t.into(),\n\t\t\t);\n\t\t\tlet mut builtin_keys = \u003cString\u003e::json_schema(gen).into_object();\n\t\t\tbuiltin_keys.enum_values = Some(vec![\n\t\t\t\t\"builtin.position\".into(),\n\t\t\t\t\"builtin.rotation\".into(),\n\t\t\t\t\"builtin.scale\".into(),\n\t\t\t\t\"builtin.display_name\".into(),\n\t\t\t]);\n\t\t\tlet mut integer_keys = \u003cu16\u003e::json_schema(gen).into_object();\n\t\t\tinteger_keys.number().minimum = Some(1000.0);\n\n\t\t\tkey_obj.subschemas().one_of =\n\t\t\t\tSome(vec![builtin_keys.into(), integer_keys.into()]);\n\t\t\tobj.properties.insert(\"key\".to_owned(), key_obj.into());\n\t\t}\n\n\t\t{\n\t\t\tlet mut stream_obj = \u003cString\u003e::json_schema(gen).into_object();\n\t\t\tstream_obj.metadata().description = Some(\n\t\t\t\t\"Streaming (passing over TCP required). If set to true, the parameter \\\n\t\t\t\t is guaranteedly passed through TCP channel. Otherwise, it can be \\\n\t\t\t\t passed through UDP channel\"\n\t\t\t\t\t.into(),\n\t\t\t);\n\t\t\tobj\n\t\t\t\t.properties\n\t\t\t\t.insert(\"stream\".to_owned(), stream_obj.into());\n\t\t}\n\n\t\tobj\n\t\t\t.properties\n\t\t\t.insert(\"blend\".to_owned(), \u003cBlend\u003e::json_schema(gen));\n\t\tobj\n\t\t\t.properties\n\t\t\t.insert(\"type\".to_owned(), \u003cAttributeType\u003e::json_schema(gen));\n\t\tschema.into()\n\t}\n}\n\nimpl JsonSchema for Object {\n\tfn schema_name() -\u003e String {\n\t\t\"Object\".into()\n\t}\n\n\tfn json_schema(gen: \u0026mut SchemaGenerator) -\u003e Schema {\n\t\tlet mut schema = SchemaObject {\n\t\t\tinstance_type: Some(InstanceType::Object.into()),\n\t\t\t..Default::default()\n\t\t};\n\t\tlet obj = schema.object();\n\n\t\tobj\n\t\t\t.properties\n\t\t\t.insert(\"name\".to_owned(), \u003cString\u003e::json_schema(gen));\n\n\t\t{\n\t\t\tlet mut class_id_obj = \u003cClassId\u003e::json_schema(gen).into_object();\n\t\t\tclass_id_obj.metadata().description = Some(\n\t\t\t\t\"Unique class ID identifying the object (cannot match any other \\\n\t\t\t\t player's or object's class ID)\"\n\t\t\t\t\t.into(),\n\t\t\t);\n\t\t\tobj\n\t\t\t\t.properties\n\t\t\t\t.insert(\"class_id\".to_owned(), class_id_obj.into());\n\t\t}\n\n\t\tobj\n\t\t\t.properties\n\t\t\t.insert(\"strict\".to_owned(), \u003cbool\u003e::json_schema(gen));\n\t\tobj\n\t\t\t.properties\n\t\t\t.insert(\"global\".to_owned(), \u003cbool\u003e::json_schema(gen));\n\t\tobj\n\t\t\t.properties\n\t\t\t.insert(\"ownership\".to_owned(), \u003cOwnership\u003e::json_schema(gen));\n\t\tobj\n\t\t\t.properties\n\t\t\t.insert(\"lifetime\".to_owned(), \u003cLifetime\u003e::json_schema(gen));\n\t\tobj\n\t\t\t.properties\n\t\t\t.insert(\"blend\".to_owned(), \u003cBlend\u003e::json_schema(gen));\n\t\tobj\n\t\t\t.properties\n\t\t\t.insert(\"tags\".to_owned(), \u003cVec\u003cString\u003e\u003e::json_schema(gen));\n\t\tobj\n\t\t\t.properties\n\t\t\t.insert(\"attributes\".to_owned(), \u003cVec\u003cAttribute\u003e\u003e::json_schema(gen));\n\t\tschema.into()\n\t}\n}\n\nimpl JsonSchema for AverageParams {\n\tfn schema_name() -\u003e String {\n\t\t\"AverageParams\".into()\n\t}\n\n\tfn json_schema(gen: \u0026mut SchemaGenerator) -\u003e Schema {\n\t\tlet mut schema = SchemaObject {\n\t\t\tinstance_type: Some(InstanceType::Object.into()),\n\t\t\t..Default::default()\n\t\t};\n\t\tlet obj = schema.object();\n\t\tobj\n\t\t\t.properties\n\t\t\t.insert(\"samples\".to_owned(), \u003cusize\u003e::json_schema(gen));\n\t\tobj\n\t\t\t.properties\n\t\t\t.insert(\"period\".to_owned(), \u003cString\u003e::json_schema(gen));\n\t\tobj\n\t\t\t.properties\n\t\t\t.insert(\"method\".to_owned(), \u003cAverageMethod\u003e::json_schema(gen));\n\t\tschema.into()\n\t}\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":111,"coverable":111},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","schema","mod.rs"],"content":"use {\n\tcrate::{\n\t\tobjects::{AverageParams, AVERAGING_MAX_CAPACITY},\n\t\trelevance::Relevance,\n\t\tstate::entity::Entity,\n\t},\n\tfxhash::FxHashMap,\n\tquark_client_sdk::{AttributeId, AttributeType},\n\tschemars::JsonSchema,\n\tsemver::{Version, VersionReq},\n\tserde::{Deserialize, Serialize},\n\tstd::{\n\t\tcollections::{hash_map::Entry, HashMap, HashSet},\n\t\tfs::File,\n\t\tio::Read,\n\t\tpath::{Path, PathBuf},\n\t\ttime::Duration,\n\t},\n\tthiserror::Error,\n};\n\nmod ensure;\nmod get;\nmod meta;\nmod read;\nmod spec;\n\npub use {get::GetByKey, spec::Spec};\n\n#[derive(Debug, Error)]\npub enum Error {\n\t#[error(\"duplicate class id: {0}\")]\n\tDuplicateClassId(ClassId),\n\n\t#[error(\"missing field: {0}\")]\n\tSyntax(#[from] serde_yaml::Error),\n\n\t#[error(\"duplicate attribute id: {1} on entity with class id {0}\")]\n\tDuplicateAttributeId(ClassId, AttributeId),\n\n\t#[error(\"incompatible server version: {0} required: {1}\")]\n\tIncompatibleServerVersion(Version, VersionReq),\n\n\t#[error(\n\t\t\"attribute {1} of class {0} requires an averagable attribute type, but it \\\n\t\t is not set or is cannot be averaged\"\n\t)]\n\tRequiresAveragableAttributeType(ClassId, AttributeId),\n\n\t#[error(\n\t\t\"attribute {1} of class {0} has an blending mode that is incompatible \\\n\t\t with the object blending type\"\n\t)]\n\tIncompatibleBlending(ClassId, AttributeId),\n\n\t#[error(\"attribute {1} of class {0} has zero averaging period\")]\n\tInvalidAveragingPeriod(ClassId, AttributeId),\n\n\t#[error(\n\t\t\"attribute {1} of class {0} has an invalid averaging sample count. Must \\\n\t\t be between 2 and {}\",\n\t\tAVERAGING_MAX_CAPACITY\n\t)]\n\tInvalidAveragingSampleCount(ClassId, AttributeId),\n\n\t#[error(\"unresolved schema file '{0}': {1}\")]\n\tUnresolvedFile(PathBuf, std::io::Error),\n\n\t#[error(\"duplicate schema import file '{0}'\")]\n\tDuplicateImportFile(PathBuf),\n}\n\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\n#[serde(default, rename_all = \"snake_case\")]\npub struct Meta {\n\tpub name: String,\n\tpub server_version: VersionReq,\n}\n\nimpl Default for Meta {\n\tfn default() -\u003e Self {\n\t\tSelf {\n\t\t\tname: String::new(),\n\t\t\tserver_version: env!(\"CARGO_PKG_VERSION\").parse().unwrap(),\n\t\t}\n\t}\n}\n\npub type ClassId = u64;\n\n/// Ownership at the moment of creation (can be either \\\"creator\\\" or\n/// \\\"detached\\\")\n#[derive(\n\tDebug, Clone, Default, PartialEq, JsonSchema, Serialize, Deserialize,\n)]\n#[serde(rename_all = \"snake_case\")]\npub enum Ownership {\n\t#[default]\n\tCreator,\n\tDetached,\n}\n\n/// Object's lifetime (can be specified as an \\\"owner\\\" string or as an object\n/// with timeout field)\n#[derive(Debug, Clone, Default, PartialEq, JsonSchema)]\npub enum Lifetime {\n\tDetached,\n\t#[default]\n\tOwner,\n\tTimeout(Duration),\n}\n\n#[derive(Debug, Copy, Clone, Default, PartialEq, JsonSchema)]\npub enum Blend {\n\t#[default]\n\tSelect,\n\tOwner,\n\tAverage(AverageParams),\n}\n\nimpl Blend {\n\tpub fn default_average() -\u003e Self {\n\t\tSelf::Average(AverageParams::default())\n\t}\n}\n\n#[derive(Debug, Clone, Default, PartialEq, Serialize, Deserialize)]\n#[serde(default, rename_all = \"snake_case\")]\npub struct Attribute {\n\tpub name: String,\n\t#[serde(with = \"read::attribute_id\")]\n\tpub key: AttributeId,\n\tpub stream: bool,\n\t#[serde(with = \"read::blend\")]\n\tpub blend: Blend,\n\tpub r#type: Option\u003cAttributeType\u003e,\n}\n\n/// Player's definition\n#[derive(\n\tDebug, Clone, Default, PartialEq, JsonSchema, Serialize, Deserialize,\n)]\n#[serde(default, rename_all = \"snake_case\")]\npub struct Player {\n\t/// Character type name\n\tpub name: String,\n\t/// Unique class ID identifying the character (cannot match any other\n\t/// player's or object's class ID)\n\tpub class_id: ClassId,\n\tpub strict: bool,\n\t#[serde(default, skip_serializing_if = \"Vec::is_empty\")]\n\tpub tags: Vec\u003cString\u003e,\n\t/// Player's atttributes\n\t#[serde(default, skip_serializing_if = \"Vec::is_empty\")]\n\tpub attributes: Vec\u003cAttribute\u003e,\n}\n\n#[derive(Debug, Clone, Default, PartialEq, Serialize, Deserialize)]\n#[serde(default, rename_all = \"snake_case\")]\npub struct Object {\n\tpub name: String,\n\tpub class_id: ClassId,\n\tpub strict: bool,\n\tpub global: bool,\n\tpub ownership: Ownership,\n\t#[serde(with = \"read::lifetime\")]\n\tpub lifetime: Lifetime,\n\t#[serde(with = \"read::blend\")]\n\tpub blend: Blend,\n\t#[serde(default, skip_serializing_if = \"Vec::is_empty\")]\n\tpub tags: Vec\u003cString\u003e,\n\t#[serde(default, skip_serializing_if = \"Vec::is_empty\")]\n\tpub attributes: Vec\u003cAttribute\u003e,\n}\n\n/// Event specification\n#[derive(\n\tDebug, Clone, Default, PartialEq, JsonSchema, Serialize, Deserialize,\n)]\n#[serde(default, rename_all = \"snake_case\")]\npub struct Event {\n\t/// Event name\n\tpub name: String,\n\t/// Unique event ID (integer; must start from 1000 - lower values reserved\n\t/// for system events)\n\tpub class_id: ClassId,\n\t/// Volatile event.\n\t/// If set to true, the event can be propagated through UDP channel\n\t/// (therefore, its delivery is not guaranteed).\n\tpub volatile: bool,\n\t/// Relevancy radius in which the event is relevant to the nearby entities\n\tpub radius: Relevance,\n}\n\n#[derive(Debug, Default, Clone, JsonSchema, Serialize)]\npub struct Schema {\n\t/// Meta section containing schema metadata(e.g. name, server version)\n\tpub meta: Meta,\n\t/// Players definition; each player is defined with unique class ID\n\t#[serde(skip_serializing_if = \"Vec::is_empty\")]\n\tpub players: Vec\u003cPlayer\u003e,\n\t#[serde(skip_serializing_if = \"Vec::is_empty\")]\n\tpub objects: Vec\u003cObject\u003e,\n\t#[allow(dead_code)]\n\t#[serde(skip_serializing_if = \"Vec::is_empty\")]\n\tpub events: Vec\u003cEvent\u003e,\n\t#[serde(skip)]\n\tcache: FxHashMap\u003cClassId, Spec\u003e,\n\t#[serde(skip)]\n\tdefault_spec: Spec,\n}\n\nimpl PartialEq for Schema {\n\tfn eq(\u0026self, other: \u0026Self) -\u003e bool {\n\t\tself.meta == other.meta\n\t\t\t\u0026\u0026 self.players == other.players\n\t\t\t\u0026\u0026 self.objects == other.objects\n\t\t\t\u0026\u0026 self.events == other.events\n\t}\n}\n\n#[derive(Debug)]\npub(super) struct RawSchema {\n\tmeta: Meta,\n\timport: Vec\u003cPathBuf\u003e,\n\tplayers: Vec\u003cPlayer\u003e,\n\tobjects: Vec\u003cObject\u003e,\n\tevents: Vec\u003cEvent\u003e,\n}\n\nmacro_rules! merge_from_vec {\n\t($map:ident, $vec:expr) =\u003e {\n\t\tfor entity in $vec {\n\t\t\tmatch $map.entry(entity.class_id) {\n\t\t\t\tEntry::Occupied(e) =\u003e {\n\t\t\t\t\tif !e.get().eq(\u0026entity) {\n\t\t\t\t\t\treturn Err(Error::DuplicateClassId(*e.key()));\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tEntry::Vacant(e) =\u003e {\n\t\t\t\t\te.insert(entity);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\nimpl Schema {\n\tpub fn spec_of(\u0026self, entity: \u0026Entity) -\u003e \u0026Spec {\n\t\tlet Some(class_id) = entity.class_id() else {\n\t\t\treturn \u0026self.default_spec;\n\t\t};\n\n\t\tself.cache.get(\u0026class_id).unwrap_or(self.default_spec())\n\t}\n\n\tpub const fn default_spec(\u0026self) -\u003e \u0026Spec {\n\t\t\u0026self.default_spec\n\t}\n\n\tfn new(\n\t\tmeta: Meta,\n\t\tplayers: Vec\u003cPlayer\u003e,\n\t\tobjects: Vec\u003cObject\u003e,\n\t\tevents: Vec\u003cEvent\u003e,\n\t) -\u003e Result\u003cSelf, Error\u003e {\n\t\tlet mut players = players;\n\t\tlet mut objects = objects;\n\t\tlet mut events = events;\n\n\t\tplayers.sort_by_key(|p| p.class_id);\n\t\tobjects.sort_by_key(|o| o.class_id);\n\t\tevents.sort_by_key(|e| e.class_id);\n\n\t\tplayers.iter_mut().for_each(|p| {\n\t\t\tp.attributes.sort_by_key(|a| a.key);\n\t\t});\n\n\t\tobjects.iter_mut().for_each(|o| {\n\t\t\to.attributes.sort_by_key(|a| a.key);\n\t\t});\n\n\t\tlet mut cache: FxHashMap\u003cClassId, Spec\u003e = players\n\t\t\t.iter()\n\t\t\t.map(|entity| (entity.class_id, Spec::from(entity)))\n\t\t\t.collect();\n\n\t\tcache.extend(\n\t\t\tobjects\n\t\t\t\t.iter()\n\t\t\t\t.map(|entity| (entity.class_id, Spec::from(entity))),\n\t\t);\n\n\t\tlet default_spec = Spec::default();\n\n\t\tlet mut schema = Self {\n\t\t\tmeta,\n\t\t\tplayers,\n\t\t\tobjects,\n\t\t\tevents,\n\t\t\tcache,\n\t\t\tdefault_spec,\n\t\t};\n\n\t\tensure::minimum_server_version(\u0026schema)?;\n\t\tensure::no_duplicate_class_ids(\u0026schema)?;\n\t\tensure::no_duplicate_attribute_ids(\u0026schema)?;\n\t\tensure::correct_authority_inheritance(\u0026mut schema)?;\n\t\tensure::average_blending_must_specify_type(\u0026schema)?;\n\t\tensure::average_blending_params_within_range(\u0026schema)?;\n\n\t\tOk(schema)\n\t}\n\n\tpub fn from_yaml_file(path: impl AsRef\u003cPath\u003e) -\u003e Result\u003cSelf, Error\u003e {\n\t\tlet path = path.as_ref();\n\t\tSelf::from_yaml_reader(\n\t\t\tFile::open(path)\n\t\t\t\t.map_err(|e| Error::UnresolvedFile(path.to_path_buf(), e))?,\n\t\t\tpath.parent().unwrap_or(Path::new(\".\")),\n\t\t)\n\t}\n\n\t#[cfg(test)]\n\tpub fn from_yaml_str(str: \u0026str) -\u003e Result\u003cSelf, Error\u003e {\n\t\tSelf::from_yaml_reader(std::io::Cursor::new(str), Path::new(\".\"))\n\t}\n\n\tfn from_yaml_reader(\n\t\treader: impl Read,\n\t\timports_path: impl AsRef\u003cPath\u003e,\n\t) -\u003e Result\u003cSelf, Error\u003e {\n\t\tlet raw: RawSchema =\n\t\t\tserde_yaml::from_reader(reader).map_err(Error::Syntax)?;\n\n\t\tlet mut players: HashMap\u003cClassId, Player\u003e = Default::default();\n\t\tlet mut objects: HashMap\u003cClassId, Object\u003e = Default::default();\n\t\tlet mut events: HashMap\u003cClassId, Event\u003e = Default::default();\n\t\tlet mut visited_paths = Default::default();\n\n\t\tmerge_from_vec!(players, raw.players);\n\t\tmerge_from_vec!(objects, raw.objects);\n\t\tmerge_from_vec!(events, raw.events);\n\n\t\tfor path in raw.import {\n\t\t\tlet path = if path.is_absolute() {\n\t\t\t\tpath\n\t\t\t} else {\n\t\t\t\timports_path.as_ref().join(path)\n\t\t\t};\n\n\t\t\tmerge_import_recursively(\n\t\t\t\t\u0026mut players,\n\t\t\t\t\u0026mut objects,\n\t\t\t\t\u0026mut events,\n\t\t\t\t\u0026mut visited_paths,\n\t\t\t\tpath,\n\t\t\t)?;\n\t\t}\n\t\tSelf::new(\n\t\t\traw.meta,\n\t\t\tplayers.into_values().collect(),\n\t\t\tobjects.into_values().collect(),\n\t\t\tevents.into_values().collect(),\n\t\t)\n\t}\n}\n\nfn merge_import_recursively(\n\tplayers: \u0026mut HashMap\u003cClassId, Player\u003e,\n\tobjects: \u0026mut HashMap\u003cClassId, Object\u003e,\n\tevents: \u0026mut HashMap\u003cClassId, Event\u003e,\n\tvisited_paths: \u0026mut HashSet\u003cPathBuf\u003e,\n\tpath: PathBuf,\n) -\u003e Result\u003c(), Error\u003e {\n\tif !visited_paths.insert(path.clone()) {\n\t\treturn Err(Error::DuplicateImportFile(path));\n\t}\n\tlet file =\n\t\tFile::open(\u0026path).map_err(|e| Error::UnresolvedFile(path.clone(), e))?;\n\n\tlet import: RawSchema =\n\t\tserde_yaml::from_reader(\u0026file).map_err(Error::Syntax)?;\n\n\tmerge_from_vec!(players, import.players);\n\tmerge_from_vec!(objects, import.objects);\n\tmerge_from_vec!(events, import.events);\n\n\tfor import_path in import.import {\n\t\tlet import_path = if import_path.is_absolute() {\n\t\t\timport_path\n\t\t} else {\n\t\t\tpath.parent().unwrap_or(Path::new(\".\")).join(\u0026import_path)\n\t\t};\n\n\t\tmerge_import_recursively(\n\t\t\tplayers,\n\t\t\tobjects,\n\t\t\tevents,\n\t\t\tvisited_paths,\n\t\t\timport_path,\n\t\t)?;\n\t}\n\n\tOk(())\n}\n\n#[cfg(test)]\nimpl Schema {\n\tpub fn with_players(players: Vec\u003cPlayer\u003e) -\u003e Result\u003cSelf, Error\u003e {\n\t\tSelf::new(Meta::default(), players, Vec::new(), Vec::new())\n\t}\n\n\tpub fn with_objects(objects: Vec\u003cObject\u003e) -\u003e Result\u003cSelf, Error\u003e {\n\t\tSelf::new(Meta::default(), Vec::new(), objects, Vec::new())\n\t}\n\n\tpub fn with_players_and_objects(\n\t\tplayers: Vec\u003cPlayer\u003e,\n\t\tobjects: Vec\u003cObject\u003e,\n\t) -\u003e Result\u003cSelf, Error\u003e {\n\t\tSelf::new(Meta::default(), players, objects, Vec::new())\n\t}\n\n\tpub fn _with_events(events: Vec\u003cEvent\u003e) -\u003e Result\u003cSelf, Error\u003e {\n\t\tSelf::new(Meta::default(), Vec::new(), Vec::new(), events)\n\t}\n}\n\n#[cfg(test)]\nmod tests {\n\tuse super::*;\n\n\t#[test]\n\tfn test_raw_schema_deser_without_imports() {\n\t\t// given\n\t\tlet input_yaml = r#\"\nmeta:\n  minimum_server_version: 1.2\nplayers:\n  - name: Human Character\nobjects:\n  - name: Pet\n    class_id: 3001\n    ownership: creator\n    lifetime: owner\n\"#;\n\n\t\t// when\n\t\tlet raw_deser = Schema::from_yaml_str(input_yaml)\n\t\t\t.expect(\"parsed with raw schema deserializer\");\n\t\tlet deser: Schema =\n\t\t\tserde_yaml::from_str(input_yaml).expect(\"parsed directly\");\n\n\t\t// then\n\t\tassert_eq!(raw_deser, deser)\n\t}\n\n\t#[test]\n\tfn test_unresolved_import() {\n\t\t// given\n\t\tlet input_yaml_relative_import = r#\"\nimport:\n  - non_existing.yaml\n\"#;\n\t\tlet input_yaml_abs_import = r#\"\nimport:\n  - /tmp/non_existing.yaml\n\"#;\n\t\t// when\n\t\tlet schema_rel_import = Schema::from_yaml_str(input_yaml_relative_import);\n\t\tlet schema_abs_import = Schema::from_yaml_str(input_yaml_abs_import);\n\n\t\t// then\n\t\tassert!(\n\t\t\tmatches!(schema_rel_import, Err(Error::UnresolvedFile(path, _)) if path.eq(Path::new(\"./non_existing.yaml\")))\n\t\t);\n\t\tassert!(\n\t\t\tmatches!(schema_abs_import, Err(Error::UnresolvedFile(path, _)) if path.eq(Path::new(\"/tmp/non_existing.yaml\")))\n\t\t);\n\t}\n\n\t#[test]\n\tfn test_empty_schema_ser_to_yaml() {\n\t\t// given\n\t\tlet schema = Schema::default();\n\n\t\t// when\n\t\tlet ser = serde_yaml::to_string(\u0026schema).expect(\"serialized\");\n\n\t\t// then\n\t\tassert_eq!(ser, \"meta:\\n  name: ''\\n  server_version: ^2.0.0\\n\");\n\t}\n\n\t#[test]\n\tfn test_schema_ser_to_yaml() {\n\t\t// given\n\t\tlet schema = Schema {\n\t\t\tmeta: Meta {\n\t\t\t\tname: \"schema name\".to_string(),\n\t\t\t\tserver_version: VersionReq::parse(\"\u003e=1.2.3\").unwrap(),\n\t\t\t},\n\t\t\tplayers: vec![test_player()],\n\t\t\t..Default::default()\n\t\t};\n\n\t\t// when\n\t\tlet ser = serde_yaml::to_string(\u0026schema).expect(\"serialized\");\n\n\t\t// then\n\t\tassert_eq!(\n\t\t\tser,\n\t\t\tr#\"meta:\n  name: schema name\n  server_version: '\u003e=1.2.3'\nplayers:\n- name: Human Character\n  class_id: 2001\n  strict: true\n  attributes:\n  - name: Position\n    key: 22\n    stream: true\n    blend: owner\n    type: vec3\n  - name: Velocity\n    key: builtin.position\n    stream: true\n    blend:\n      average:\n        samples: 8\n        period: 20ms\n        method: mean\n    type: vec3\n\"#\n\t\t);\n\t}\n\n\t#[test]\n\tfn test_player_ser_to_yaml() {\n\t\t// given\n\t\tlet player = test_player();\n\n\t\t// when\n\t\tlet ser = serde_yaml::to_string(\u0026player).expect(\"serialized\");\n\n\t\t// then\n\t\tassert_eq!(\n\t\t\tser,\n\t\t\tr#\"name: Human Character\nclass_id: 2001\nstrict: true\nattributes:\n- name: Position\n  key: 22\n  stream: true\n  blend: owner\n  type: vec3\n- name: Velocity\n  key: builtin.position\n  stream: true\n  blend:\n    average:\n      samples: 8\n      period: 20ms\n      method: mean\n  type: vec3\n\"#\n\t\t);\n\t}\n\n\t#[test]\n\tfn test_objects_ser_to_yaml() {\n\t\t// given\n\t\tlet objects = test_objects();\n\n\t\t// when\n\t\tlet ser = serde_yaml::to_string(\u0026objects).expect(\"serialized\");\n\n\t\t// then\n\t\tassert_eq!(\n\t\t\tser,\n\t\t\tr#\"- name: Pet\n  class_id: 3001\n  strict: true\n  global: false\n  ownership: creator\n  lifetime: owner\n  blend: owner\n  tags:\n  - animals\n  - summary\n  - high-distance\n  attributes:\n  - name: Position\n    key: builtin.position\n    stream: true\n    blend: owner\n    type: vec3\n- name: Projectile1\n  class_id: 3002\n  strict: false\n  global: true\n  ownership: detached\n  lifetime:\n    timeout: 5s\n  blend:\n    average:\n      samples: 8\n      period: 20ms\n      method: mean\n  tags:\n  - summary\n\"#\n\t\t);\n\t}\n\n\t#[test]\n\tfn test_event_ser_to_yaml() {\n\t\t// given\n\t\tlet event = test_event();\n\n\t\t// when\n\t\tlet ser = serde_yaml::to_string(\u0026event).expect(\"serialized\");\n\n\t\t// then\n\t\tassert_eq!(\n\t\t\tser,\n\t\t\tr#\"name: Shoot\nclass_id: 4001\nvolatile: true\nradius: 0.3\n\"#\n\t\t);\n\t}\n\n\tfn test_player() -\u003e Player {\n\t\tPlayer {\n\t\t\tname: \"Human Character\".to_string(),\n\t\t\tclass_id: 2001,\n\t\t\tstrict: true,\n\t\t\ttags: vec![],\n\t\t\tattributes: vec![\n\t\t\t\tAttribute {\n\t\t\t\t\tname: \"Position\".to_string(),\n\t\t\t\t\tkey: 22,\n\t\t\t\t\tstream: true,\n\t\t\t\t\tblend: Blend::Owner,\n\t\t\t\t\tr#type: Some(AttributeType::Vec3),\n\t\t\t\t},\n\t\t\t\tAttribute {\n\t\t\t\t\tname: \"Velocity\".to_string(),\n\t\t\t\t\tkey: 1,\n\t\t\t\t\tstream: true,\n\t\t\t\t\tblend: Blend::Average(AverageParams {\n\t\t\t\t\t\tsamples: 8,\n\t\t\t\t\t\tperiod: Duration::from_millis(20),\n\t\t\t\t\t\tmethod: crate::objects::AverageMethod::Mean,\n\t\t\t\t\t}),\n\t\t\t\t\tr#type: Some(AttributeType::Vec3),\n\t\t\t\t},\n\t\t\t],\n\t\t}\n\t}\n\n\tfn test_objects() -\u003e [Object; 2] {\n\t\t[\n\t\t\tObject {\n\t\t\t\tname: \"Pet\".to_string(),\n\t\t\t\tclass_id: 3001,\n\t\t\t\tstrict: true,\n\t\t\t\tglobal: false,\n\t\t\t\townership: Ownership::Creator,\n\t\t\t\tlifetime: Lifetime::Owner,\n\t\t\t\tblend: Blend::Owner,\n\t\t\t\ttags: vec![\n\t\t\t\t\t\"animals\".to_string(),\n\t\t\t\t\t\"summary\".to_string(),\n\t\t\t\t\t\"high-distance\".to_string(),\n\t\t\t\t],\n\t\t\t\tattributes: vec![Attribute {\n\t\t\t\t\tname: \"Position\".to_string(),\n\t\t\t\t\tkey: 1,\n\t\t\t\t\tstream: true,\n\t\t\t\t\tblend: Blend::Owner,\n\t\t\t\t\tr#type: Some(AttributeType::Vec3),\n\t\t\t\t}],\n\t\t\t},\n\t\t\tObject {\n\t\t\t\tname: \"Projectile1\".to_string(),\n\t\t\t\tclass_id: 3002,\n\t\t\t\tstrict: false,\n\t\t\t\tglobal: true,\n\t\t\t\townership: Ownership::Detached,\n\t\t\t\tlifetime: Lifetime::Timeout(Duration::from_secs(5)),\n\t\t\t\tblend: Blend::Average(AverageParams {\n\t\t\t\t\tsamples: 8,\n\t\t\t\t\tperiod: Duration::from_millis(20),\n\t\t\t\t\tmethod: crate::objects::AverageMethod::Mean,\n\t\t\t\t}),\n\t\t\t\ttags: vec![\"summary\".to_string()],\n\t\t\t\tattributes: vec![],\n\t\t\t},\n\t\t]\n\t}\n\n\tfn test_event() -\u003e Event {\n\t\tEvent {\n\t\t\tname: \"Shoot\".to_string(),\n\t\t\tclass_id: 4001,\n\t\t\tvolatile: true,\n\t\t\tradius: 0.3.into(),\n\t\t}\n\t}\n}\n","traces":[{"line":81,"address":[],"length":0,"stats":{"Line":151},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":151},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":151},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":1133},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":1356},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":910},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":223},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":223},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":80},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":126},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":86},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":228},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":86},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":176},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":86},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":116},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":74,"coverable":85},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","schema","read.rs"],"content":"//! This module contains the deserialization implementation for the `Schema`\n//! struct. It also validates the schema object to ensure that it is\n//! well-formed.\n//!\n//! There are some quality of life heuristics in place to improve\n//! dev experience working with the schema. For example, the `AttributeId`\n//! enum can be deserialized from a string that represents a builtin attribute\n//! key.\n\nuse {\n\tsuper::{Object, Player, RawSchema, Schema},\n\tserde::{de::Error as _, Deserialize},\n\tstd::path::PathBuf,\n};\n\nstruct SchemaVistitor;\n\nimpl\u003c'de\u003e serde::de::Visitor\u003c'de\u003e for SchemaVistitor {\n\ttype Value = Schema;\n\n\tfn expecting(\u0026self, formatter: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\n\t\tformatter.write_str(\"expecting a Schema object\")\n\t}\n\n\tfn visit_map\u003cV\u003e(self, mut map: V) -\u003e Result\u003cSelf::Value, V::Error\u003e\n\twhere\n\t\tV: serde::de::MapAccess\u003c'de\u003e,\n\t{\n\t\tlet mut meta = None;\n\t\tlet mut events = None;\n\t\tlet mut players: Option\u003cVec\u003cPlayer\u003e\u003e = None;\n\t\tlet mut objects: Option\u003cVec\u003cObject\u003e\u003e = None;\n\n\t\twhile let Some(key) = map.next_key::\u003cString\u003e()? {\n\t\t\tmatch key.as_str() {\n\t\t\t\t\"meta\" =\u003e {\n\t\t\t\t\tif meta.is_some() {\n\t\t\t\t\t\treturn Err(serde::de::Error::duplicate_field(\"meta\"));\n\t\t\t\t\t}\n\t\t\t\t\tmeta = Some(map.next_value()?);\n\t\t\t\t}\n\t\t\t\t\"players\" =\u003e {\n\t\t\t\t\tif players.is_some() {\n\t\t\t\t\t\treturn Err(serde::de::Error::duplicate_field(\"players\"));\n\t\t\t\t\t}\n\t\t\t\t\tplayers = Some(map.next_value()?);\n\t\t\t\t}\n\t\t\t\t\"objects\" =\u003e {\n\t\t\t\t\tif objects.is_some() {\n\t\t\t\t\t\treturn Err(serde::de::Error::duplicate_field(\"objects\"));\n\t\t\t\t\t}\n\t\t\t\t\tobjects = Some(map.next_value()?);\n\t\t\t\t}\n\t\t\t\t\"events\" =\u003e {\n\t\t\t\t\tif events.is_some() {\n\t\t\t\t\t\treturn Err(serde::de::Error::duplicate_field(\"events\"));\n\t\t\t\t\t}\n\t\t\t\t\tevents = Some(map.next_value()?);\n\t\t\t\t}\n\t\t\t\t_ =\u003e {\n\t\t\t\t\treturn Err(serde::de::Error::unknown_field(\u0026key, \u0026[\n\t\t\t\t\t\t\"meta\", \"players\", \"objects\", \"events\",\n\t\t\t\t\t]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet meta = meta.unwrap_or_default();\n\t\tlet players = players.unwrap_or_default();\n\t\tlet objects = objects.unwrap_or_default();\n\t\tlet events = events.unwrap_or_default();\n\n\t\tSchema::new(meta, players, objects, events).map_err(V::Error::custom)\n\t}\n}\n\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for Schema {\n\tfn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n\twhere\n\t\tD: serde::Deserializer\u003c'de\u003e,\n\t{\n\t\tdeserializer.deserialize_map(SchemaVistitor)\n\t}\n}\n\nstruct RawSchemaVistitor;\n\nimpl\u003c'de\u003e serde::de::Visitor\u003c'de\u003e for RawSchemaVistitor {\n\ttype Value = RawSchema;\n\n\tfn expecting(\u0026self, formatter: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\n\t\tformatter.write_str(\"expecting a RawSchema object\")\n\t}\n\n\tfn visit_map\u003cV\u003e(self, mut map: V) -\u003e Result\u003cSelf::Value, V::Error\u003e\n\twhere\n\t\tV: serde::de::MapAccess\u003c'de\u003e,\n\t{\n\t\tlet mut meta = None;\n\t\tlet mut events = None;\n\t\tlet mut players: Option\u003cVec\u003cPlayer\u003e\u003e = None;\n\t\tlet mut objects: Option\u003cVec\u003cObject\u003e\u003e = None;\n\t\tlet mut import: Option\u003cVec\u003cPathBuf\u003e\u003e = None;\n\n\t\twhile let Some(key) = map.next_key::\u003cString\u003e()? {\n\t\t\tmatch key.as_str() {\n\t\t\t\t\"meta\" =\u003e {\n\t\t\t\t\tif meta.is_some() {\n\t\t\t\t\t\treturn Err(serde::de::Error::duplicate_field(\"meta\"));\n\t\t\t\t\t}\n\t\t\t\t\tmeta = Some(map.next_value()?);\n\t\t\t\t}\n\t\t\t\t\"players\" =\u003e {\n\t\t\t\t\tif players.is_some() {\n\t\t\t\t\t\treturn Err(serde::de::Error::duplicate_field(\"players\"));\n\t\t\t\t\t}\n\t\t\t\t\tplayers = Some(map.next_value()?);\n\t\t\t\t}\n\t\t\t\t\"objects\" =\u003e {\n\t\t\t\t\tif objects.is_some() {\n\t\t\t\t\t\treturn Err(serde::de::Error::duplicate_field(\"objects\"));\n\t\t\t\t\t}\n\t\t\t\t\tobjects = Some(map.next_value()?);\n\t\t\t\t}\n\t\t\t\t\"events\" =\u003e {\n\t\t\t\t\tif events.is_some() {\n\t\t\t\t\t\treturn Err(serde::de::Error::duplicate_field(\"events\"));\n\t\t\t\t\t}\n\t\t\t\t\tevents = Some(map.next_value()?);\n\t\t\t\t}\n\t\t\t\t\"import\" =\u003e {\n\t\t\t\t\tif import.is_some() {\n\t\t\t\t\t\treturn Err(serde::de::Error::duplicate_field(\"import\"));\n\t\t\t\t\t}\n\t\t\t\t\timport = Some(map.next_value()?);\n\t\t\t\t}\n\t\t\t\t_ =\u003e {\n\t\t\t\t\treturn Err(serde::de::Error::unknown_field(\u0026key, \u0026[\n\t\t\t\t\t\t\"meta\", \"players\", \"objects\", \"events\", \"import\",\n\t\t\t\t\t]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet meta = meta.unwrap_or_default();\n\t\tlet players = players.unwrap_or_default();\n\t\tlet objects = objects.unwrap_or_default();\n\t\tlet events = events.unwrap_or_default();\n\t\tlet import = import.unwrap_or_default();\n\n\t\tOk(RawSchema {\n\t\t\tmeta,\n\t\t\timport,\n\t\t\tplayers,\n\t\t\tobjects,\n\t\t\tevents,\n\t\t})\n\t}\n}\n\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for RawSchema {\n\tfn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n\twhere\n\t\tD: serde::Deserializer\u003c'de\u003e,\n\t{\n\t\tdeserializer.deserialize_map(RawSchemaVistitor)\n\t}\n}\n\npub mod attribute_id {\n\tuse {quark_client_sdk::AttributeId, serde::Serializer};\n\n\tstruct AttributeIdVisiter;\n\n\timpl\u003c'de\u003e serde::de::Visitor\u003c'de\u003e for AttributeIdVisiter {\n\t\ttype Value = AttributeId;\n\n\t\tfn expecting(\n\t\t\t\u0026self,\n\t\t\tformatter: \u0026mut std::fmt::Formatter,\n\t\t) -\u003e std::fmt::Result {\n\t\t\tformatter.write_str(\"str or integer\")\n\t\t}\n\n\t\tfn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n\t\twhere\n\t\t\tE: serde::de::Error,\n\t\t{\n\t\t\tmatch v {\n\t\t\t\t\"builtin.position\" =\u003e Ok(1),\n\t\t\t\t\"builtin.rotation\" =\u003e Ok(2),\n\t\t\t\t\"builtin.scale\" =\u003e Ok(3),\n\t\t\t\t\"builtin.display_name\" =\u003e Ok(4),\n\t\t\t\t\"builtin.group_id\" =\u003e Ok(5),\n\t\t\t\t\"builtin.class_id\" =\u003e Ok(6),\n\t\t\t\t\"builtin.owner_id\" =\u003e Ok(7),\n\t\t\t\tk =\u003e Err(serde::de::Error::custom(format!(\n\t\t\t\t\t\"unrecognized attribute key '{k}'\"\n\t\t\t\t))),\n\t\t\t}\n\t\t}\n\n\t\tfn visit_u64\u003cE\u003e(self, v: u64) -\u003e Result\u003cSelf::Value, E\u003e\n\t\twhere\n\t\t\tE: serde::de::Error,\n\t\t{\n\t\t\tv.try_into().map_err(|_| {\n\t\t\t\tserde::de::Error::custom(\"unable to convert value to u16\".to_string())\n\t\t\t})\n\t\t}\n\t}\n\n\tpub fn deserialize\u003c'de, D\u003e(deserializer: D) -\u003e Result\u003cu16, D::Error\u003e\n\twhere\n\t\tD: serde::Deserializer\u003c'de\u003e,\n\t{\n\t\tdeserializer.deserialize_any(AttributeIdVisiter)\n\t}\n\n\tpub fn serialize\u003cS\u003e(attr: \u0026AttributeId, ser: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n\twhere\n\t\tS: Serializer,\n\t{\n\t\tmatch attr {\n\t\t\t1 =\u003e ser.serialize_str(\"builtin.position\"),\n\t\t\t2 =\u003e ser.serialize_str(\"builtin.rotation\"),\n\t\t\t3 =\u003e ser.serialize_str(\"builtin.scale\"),\n\t\t\t4 =\u003e ser.serialize_str(\"builtin.display_name\"),\n\t\t\t5 =\u003e ser.serialize_str(\"builtin.group_id\"),\n\t\t\t6 =\u003e ser.serialize_str(\"builtin.class_id\"),\n\t\t\t7 =\u003e ser.serialize_str(\"builtin.owner_id\"),\n\t\t\tother =\u003e ser.serialize_u16(*other),\n\t\t}\n\t}\n}\n\npub mod lifetime {\n\tuse {\n\t\tcrate::schema::Lifetime,\n\t\tserde::{de::Error as _, ser::SerializeMap, Serializer},\n\t\tstd::str::FromStr,\n\t};\n\n\tstruct LifetimeVisitor;\n\n\timpl\u003c'de\u003e serde::de::Visitor\u003c'de\u003e for LifetimeVisitor {\n\t\ttype Value = crate::schema::Lifetime;\n\n\t\tfn expecting(\n\t\t\t\u0026self,\n\t\t\tformatter: \u0026mut std::fmt::Formatter,\n\t\t) -\u003e std::fmt::Result {\n\t\t\tformatter.write_str(\"expecting a Lifetime object\")\n\t\t}\n\n\t\tfn visit_map\u003cA\u003e(self, mut map: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n\t\twhere\n\t\t\tA: serde::de::MapAccess\u003c'de\u003e,\n\t\t{\n\t\t\tlet mut timeout = None;\n\n\t\t\twhile let Some(key) = map.next_key::\u003cString\u003e()? {\n\t\t\t\tmatch key.as_str() {\n\t\t\t\t\t\"timeout\" =\u003e {\n\t\t\t\t\t\tif timeout.is_some() {\n\t\t\t\t\t\t\treturn Err(serde::de::Error::duplicate_field(\"timeout\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttimeout = Some(\n\t\t\t\t\t\t\thumantime::Duration::from_str(\n\t\t\t\t\t\t\t\tmap.next_value::\u003cString\u003e()?.as_str(),\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.map_err(A::Error::custom)?,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\t_ =\u003e {\n\t\t\t\t\t\treturn Err(serde::de::Error::unknown_field(\u0026key, \u0026[\"timeout\"]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif let Some(timeout) = timeout {\n\t\t\t\tOk(crate::schema::Lifetime::Timeout(timeout.into()))\n\t\t\t} else {\n\t\t\t\tErr(serde::de::Error::missing_field(\"timeout\"))\n\t\t\t}\n\t\t}\n\n\t\tfn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n\t\twhere\n\t\t\tE: serde::de::Error,\n\t\t{\n\t\t\tmatch v {\n\t\t\t\t\"owner\" =\u003e Ok(crate::schema::Lifetime::Owner),\n\t\t\t\t\"detached\" =\u003e Ok(crate::schema::Lifetime::Detached),\n\t\t\t\t_ =\u003e Err(E::custom(format!(\"unknown lifetime value: {v}\"))),\n\t\t\t}\n\t\t}\n\t}\n\n\tpub fn deserialize\u003c'de, D\u003e(\n\t\tdeserializer: D,\n\t) -\u003e Result\u003ccrate::schema::Lifetime, D::Error\u003e\n\twhere\n\t\tD: serde::Deserializer\u003c'de\u003e,\n\t{\n\t\tdeserializer.deserialize_any(LifetimeVisitor)\n\t}\n\n\tpub fn serialize\u003cS\u003e(lifetime: \u0026Lifetime, ser: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n\twhere\n\t\tS: Serializer,\n\t{\n\t\tmatch lifetime {\n\t\t\tLifetime::Owner =\u003e ser.serialize_str(\"owner\"),\n\t\t\tLifetime::Detached =\u003e ser.serialize_str(\"detached\"),\n\t\t\tLifetime::Timeout(timeout) =\u003e {\n\t\t\t\tlet mut map = ser.serialize_map(Some(1))?;\n\t\t\t\tlet human_str = humantime::format_duration(*timeout).to_string();\n\t\t\t\tmap.serialize_entry(\"timeout\", \u0026human_str)?;\n\t\t\t\tmap.end()\n\t\t\t}\n\t\t}\n\t}\n}\n\npub mod blend {\n\tuse {\n\t\tcrate::{objects::AverageParams, schema::Blend},\n\t\tserde::{ser::SerializeMap, Serializer},\n\t};\n\n\tpub fn deserialize\u003c'de, D\u003e(\n\t\tdeserializer: D,\n\t) -\u003e Result\u003ccrate::schema::Blend, D::Error\u003e\n\twhere\n\t\tD: serde::Deserializer\u003c'de\u003e,\n\t{\n\t\tstruct BlendVisitor;\n\n\t\timpl\u003c'de\u003e serde::de::Visitor\u003c'de\u003e for BlendVisitor {\n\t\t\ttype Value = crate::schema::Blend;\n\n\t\t\tfn expecting(\n\t\t\t\t\u0026self,\n\t\t\t\tformatter: \u0026mut std::fmt::Formatter,\n\t\t\t) -\u003e std::fmt::Result {\n\t\t\t\tformatter.write_str(\"expecting a Blend object\")\n\t\t\t}\n\n\t\t\tfn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n\t\t\twhere\n\t\t\t\tE: serde::de::Error,\n\t\t\t{\n\t\t\t\tmatch v {\n\t\t\t\t\t\"select\" =\u003e Ok(crate::schema::Blend::Select),\n\t\t\t\t\t\"owner\" =\u003e Ok(crate::schema::Blend::Owner),\n\t\t\t\t\t\"average\" =\u003e Ok(crate::schema::Blend::default_average()),\n\t\t\t\t\t_ =\u003e Err(E::custom(format!(\"invalid blend value: {v}\"))),\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfn visit_map\u003cA\u003e(self, mut map: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n\t\t\twhere\n\t\t\t\tA: serde::de::MapAccess\u003c'de\u003e,\n\t\t\t{\n\t\t\t\tlet mut average = None;\n\t\t\t\twhile let Some(key) = map.next_key::\u003cString\u003e()? {\n\t\t\t\t\tmatch key.as_str() {\n\t\t\t\t\t\t\"average\" =\u003e {\n\t\t\t\t\t\t\tif average.is_some() {\n\t\t\t\t\t\t\t\treturn Err(serde::de::Error::duplicate_field(\"average\"));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlet avg_config: AverageParams = map.next_value()?;\n\t\t\t\t\t\t\taverage = Some(avg_config);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_ =\u003e {\n\t\t\t\t\t\t\treturn Err(serde::de::Error::unknown_field(\u0026key, \u0026[\"average\"]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif let Some(params) = average {\n\t\t\t\t\tOk(crate::schema::Blend::Average(params))\n\t\t\t\t} else {\n\t\t\t\t\tErr(serde::de::Error::missing_field(\"average\"))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdeserializer.deserialize_any(BlendVisitor)\n\t}\n\n\tpub fn serialize\u003cS\u003e(blend: \u0026Blend, ser: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n\twhere\n\t\tS: Serializer,\n\t{\n\t\tmatch blend {\n\t\t\tBlend::Select =\u003e ser.serialize_str(\"select\"),\n\t\t\tBlend::Owner =\u003e ser.serialize_str(\"owner\"),\n\t\t\tBlend::Average(avg_params) =\u003e {\n\t\t\t\tlet mut map = ser.serialize_map(Some(1))?;\n\t\t\t\tmap.serialize_entry(\"average\", \u0026avg_params)?;\n\t\t\t\tmap.end()\n\t\t\t}\n\t\t}\n\t}\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":39},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":169},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":71},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":71},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":49},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":53},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":53},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":75},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":75},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":75},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":128},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":128},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":95},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":95},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":99},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":127},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":59},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":58},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":58},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":58},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":58},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":58},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":58},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":58},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":65},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":58},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":6},"fn_name":null}],"covered":133,"coverable":176},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","schema","spec.rs"],"content":"use {\n\tsuper::{Attribute, Blend, Lifetime, Object, Ownership, Player},\n\tcrate::state::entity::AttributeId,\n\tinlinable_string::InlinableString,\n\tquark_client_sdk::AttributeType,\n\tsmallvec::SmallVec,\n};\n\n#[derive(Default, Debug, Clone, PartialEq)]\npub struct AttributeSpec {\n\t#[allow(dead_code)]\n\tpub name: InlinableString,\n\tpub key: AttributeId,\n\t#[allow(dead_code)]\n\tpub stream: bool,\n\tpub r#type: Option\u003cAttributeType\u003e,\n\tpub blend: Blend,\n}\n\nimpl From\u003cAttribute\u003e for AttributeSpec {\n\tfn from(attr: Attribute) -\u003e Self {\n\t\tSelf {\n\t\t\tname: attr.name.into(),\n\t\t\tkey: attr.key,\n\t\t\tstream: attr.stream,\n\t\t\tblend: attr.blend,\n\t\t\tr#type: attr.r#type,\n\t\t}\n\t}\n}\n\n#[derive(Default, Debug, Clone, PartialEq)]\npub struct Spec {\n\townership: Ownership,\n\tlifetime: Lifetime,\n\tblend: Blend,\n\tstrict: bool,\n\ttags: SmallVec\u003c[InlinableString; 5]\u003e,\n\tattributes: SmallVec\u003c[AttributeSpec; 32]\u003e,\n}\n\nimpl From\u003c\u0026Player\u003e for Spec {\n\tfn from(player: \u0026Player) -\u003e Self {\n\t\tSelf {\n\t\t\tlifetime: Lifetime::Owner,\n\t\t\townership: Ownership::Creator,\n\t\t\tblend: Blend::Owner,\n\t\t\tstrict: player.strict,\n\t\t\ttags: player.tags.iter().cloned().map(|tag| tag.into()).collect(),\n\t\t\tattributes: player\n\t\t\t\t.attributes\n\t\t\t\t.iter()\n\t\t\t\t.map(|attr| attr.clone().into())\n\t\t\t\t.collect(),\n\t\t}\n\t}\n}\n\nimpl From\u003c\u0026Object\u003e for Spec {\n\tfn from(object: \u0026Object) -\u003e Self {\n\t\tSelf {\n\t\t\tlifetime: object.lifetime.clone(),\n\t\t\townership: object.ownership.clone(),\n\t\t\tblend: object.blend,\n\t\t\tstrict: object.strict,\n\t\t\ttags: object.tags.iter().cloned().map(|tag| tag.into()).collect(),\n\t\t\tattributes: object\n\t\t\t\t.attributes\n\t\t\t\t.iter()\n\t\t\t\t.map(|attr| attr.clone().into())\n\t\t\t\t.collect(),\n\t\t}\n\t}\n}\n\nimpl Spec {\n\tpub const fn lifetime(\u0026self) -\u003e \u0026Lifetime {\n\t\t\u0026self.lifetime\n\t}\n\n\tpub const fn ownership(\u0026self) -\u003e \u0026Ownership {\n\t\t\u0026self.ownership\n\t}\n\n\tpub const fn blend(\u0026self) -\u003e \u0026Blend {\n\t\t\u0026self.blend\n\t}\n\n\tpub fn tags(\u0026self) -\u003e \u0026[InlinableString] {\n\t\t\u0026self.tags\n\t}\n\n\tpub fn attributes(\u0026self) -\u003e \u0026[AttributeSpec] {\n\t\t\u0026self.attributes\n\t}\n\n\tpub fn strict(\u0026self) -\u003e bool {\n\t\tself.strict\n\t}\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":129},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":129},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":129},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":129},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":129},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":129},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":136},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":632},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":632},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":5278},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":5278},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":299},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":299},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":5273},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":5273},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":5269},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":5269},"fn_name":null}],"covered":29,"coverable":29},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","server.rs"],"content":"use {\n\tcrate::{\n\t\tadmin::AdminApiService,\n\t\tglobal::GlobalState,\n\t\topts::ServerOptions,\n\t\treplication,\n\t\tsession::{\n\t\t\tcommand::Command,\n\t\t\tevent_loop::spawn_event_loop,\n\t\t\thandshake::handshake,\n\t\t},\n\t\ttopology::Topology,\n\t},\n\tmetrics::histogram,\n\tquark_client_sdk::{MTUBytes, Packet},\n\tstd::{sync::Arc, time::Duration},\n\ttokio::net::{TcpListener, TcpStream},\n\ttokio_util::codec::{Framed, LengthDelimitedCodec},\n\ttracing::{error, info, trace},\n};\n\npub async fn run(\n\topts: ServerOptions,\n\ttopology: Arc\u003cTopology\u003e,\n) -\u003e anyhow::Result\u003c()\u003e {\n\tinfo!(\"Server started with opts: {opts:#?}\");\n\tinfo!(\"Using schema: {:#?}\", opts.schema());\n\n\tlet profile = Arc::new(opts.profile());\n\tinfo!(\"Loaded profile: {profile:#?}\");\n\n\tlet listen_addr = opts.listen_addr;\n\tlet admin_addr = opts.admin_api;\n\tlet replicate_from = opts.replicate_from.clone();\n\tlet listener = TcpListener::bind(listen_addr).await?;\n\n\t// This is the global state that will be shared by all sessions.\n\t// most of the global system configuration is configured through\n\t// the profile object. The profile object can be loaded from a\n\t// file or it can be configured through command line arguments.\n\tlet global = GlobalState::new(opts, topology).await?;\n\n\t// start replication consumers loop\n\treplication::Consumers::start(\n\t\treplicate_from.clone(), //\n\t\tArc::clone(\u0026global),\n\t);\n\n\t// gather metrics about the state of the server\n\ttokio::spawn(stats_loop(Arc::clone(\u0026global)));\n\n\t// start udp listener\n\ttokio::spawn(udp_loop(Arc::clone(\u0026global)));\n\n\t// check if we want to start a http endpoint for administrative apis.\n\tif let Some(admin_addr) = admin_addr {\n\t\tAdminApiService::start(admin_addr, Arc::clone(\u0026global))\n\t\t\t.await\n\t\t\t.expect(\"failed to start admin api service\");\n\t\tinfo!(\"Admin API listening on {admin_addr}\");\n\t};\n\n\tloop {\n\t\tif let Ok((stream, from)) = listener.accept().await {\n\t\t\tlet state = Arc::clone(\u0026global);\n\t\t\ttrace!(\"accepting new connection from {from}\");\n\t\t\ttokio::spawn(accept_new_client(from, stream, state));\n\t\t}\n\t}\n}\n\n/// Handle newly accepted client. Check in profile if tls is enabled.\n/// If tls is enabled, do a tls handhsake and create tls stream.\n/// Use codec::Framed to encode/decode the tcp/tls stream.\n/// Once framed tls/tcp stream is available, do a session handhsake with client\n/// and create a new session for the client. Ultimately spawn event loop which\n/// will handle the events sent by client.\n///\n/// Parameters:\n///     from: IP and port address of the client\n///     tcp_stream: TCP stream to communicate with client\n///     state: Global state maintained across the server\n/// Return:\n///     In case handshake fails, return and exit the tokio thread.\nasync fn accept_new_client(\n\tfrom: std::net::SocketAddr,\n\ttcp_stream: TcpStream,\n\tstate: Arc\u003cGlobalState\u003e,\n) {\n\tlet sock_ref = socket2::SockRef::from(\u0026tcp_stream);\n\n\tlet mut ka = socket2::TcpKeepalive::new();\n\tka = ka.with_time(Duration::from_secs(20));\n\tka = ka.with_interval(Duration::from_secs(20));\n\n\tsock_ref.set_tcp_keepalive(\u0026ka).unwrap_or_else(|_| {\n\t\terror!(\"failed to set tcp keepalive for {from}\");\n\t});\n\n\tsock_ref.set_nodelay(true).unwrap_or_else(|e| {\n\t\terror!(\"failed to set nodelay for {from}: {e:?}\");\n\t});\n\n\tlet stream = Framed::new(tcp_stream, LengthDelimitedCodec::new());\n\tmatch handshake(stream, from, Arc::clone(\u0026state)).await {\n\t\tOk(session) =\u003e {\n\t\t\tspawn_event_loop(session);\n\t\t}\n\t\tErr(e) =\u003e error!(\"Handshake failed for {from}: {e}\"),\n\t}\n}\n\nasync fn stats_loop(state: Arc\u003cGlobalState\u003e) {\n\tlet mut timer = tokio::time::interval(Duration::from_secs(1));\n\tloop {\n\t\ttimer.tick().await;\n\t\thistogram!(\"state_active_player_count\", state.players().len() as f64);\n\t\thistogram!(\"state_active_object_count\", state.objects().len() as f64);\n\t}\n}\n\n/// UDP listener loop. Bind to the same endpoint as the TCP listener.\n/// Receive UDP packets and forward them to the player session.\nasync fn udp_loop(global: Arc\u003cGlobalState\u003e) {\n\tlet mut recv_buffer = MTUBytes::default();\n\twhile let Ok((_, from)) = global.udp().recv_from(recv_buffer.as_mut()).await {\n\t\t// try to reinterpret the received bytes as a packet\n\t\tlet Ok(packet): Result\u003c\u0026Packet, _\u003e = (\u0026recv_buffer).try_into() else {\n\t\t\ttrace!(\"received invalid UDP packet from {from}\");\n\t\t\trecv_buffer.clear();\n\t\t\tcontinue;\n\t\t};\n\n\t\t// forward the packet to the player session\n\t\tglobal.commands().send_to(\n\t\t\t\u0026packet.header().player_id(),\n\t\t\tCommand::ReceiveUDPStream(from, Box::new(packet.clone())),\n\t\t);\n\n\t\t// zero out the buffer for next packet\n\t\trecv_buffer.clear();\n\t}\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":238},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":124},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":839},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":480},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":238},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":1737},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":809},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":809},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":238},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":906},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":492},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":246},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":246},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":246},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":246},"fn_name":null}],"covered":45,"coverable":51},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","session","command.rs"],"content":"use {\n\tcrate::{\n\t\tevents::Event,\n\t\tstate::{object::ObjectId, player::PlayerId},\n\t},\n\tdashmap::DashMap,\n\tfxhash::FxBuildHasher,\n\tquark_client_sdk::Packet,\n\tstd::{net::SocketAddr, sync::Arc},\n\ttokio::sync::mpsc::{unbounded_channel, UnboundedReceiver, UnboundedSender},\n};\n\npub struct Channel\u003cT\u003e {\n\tpub(crate) sender: UnboundedSender\u003cT\u003e,\n\tpub(crate) receiver: UnboundedReceiver\u003cT\u003e,\n}\n\nimpl\u003cT\u003e Default for Channel\u003cT\u003e {\n\tfn default() -\u003e Self {\n\t\tlet (sender, receiver) = unbounded_channel();\n\t\tSelf { sender, receiver }\n\t}\n}\nimpl\u003cT\u003e Channel\u003cT\u003e {\n\tpub fn sender(\u0026self) -\u003e \u0026UnboundedSender\u003cT\u003e {\n\t\t\u0026self.sender\n\t}\n\n\tpub fn receiver(\u0026mut self) -\u003e \u0026mut UnboundedReceiver\u003cT\u003e {\n\t\t\u0026mut self.receiver\n\t}\n}\n\n/// Those are internal commands sent by various parts of the system to the\n/// session event loop.\n#[derive(Debug, PartialEq, Eq)]\npub enum Command {\n\t/// Instructs the session to terminate.\n\t/// This is not implemented yet, but will be used to kick players out.\n\tTerminate,\n\n\t/// Instructs the session to remove the given object from the session\n\t/// cache of sent objects. This is used when the object is despawned\n\t/// by its owner.\n\tDespawnObject(ObjectId),\n\n\t/// Instructs the session to remove the given player from the session\n\t/// cache of sent players. This is used when the player disconnects.\n\tPlayerDisconnected(PlayerId),\n\n\t/// Instructs the session to forget about the given object.\n\t/// Next time this object becomes relevant, then all its data will be sent.\n\tForgetObject(ObjectId),\n\n\t/// Instructs the session to forget about the given player.\n\t/// Next time this player becomes relevant, then all its data will be sent.\n\tForgetPlayer(PlayerId),\n\n\t/// Instructs the session to apply incoming stream packet with new update\n\t/// from player. It also passes the last socket address from which the\n\t/// packet was received.\n\tReceiveUDPStream(SocketAddr, Box\u003cPacket\u003e),\n\n\t/// Sent when a new event is sent to this player.\n\t/// This session may chose to accept it or ignore it based on its\n\t/// event filter settings.\n\tReceiveEvent(Arc\u003cEvent\u003e),\n}\n\n#[derive(Default, Debug)]\npub struct Commands {\n\tplayers_channels: DashMap\u003cPlayerId, UnboundedSender\u003cCommand\u003e, FxBuildHasher\u003e,\n}\n\nimpl Commands {\n\tpub fn register(\u0026self, player: PlayerId, channel: \u0026UnboundedSender\u003cCommand\u003e) {\n\t\tself.players_channels.insert(player, channel.clone());\n\t}\n\n\tpub fn unregister(\u0026self, player: \u0026PlayerId) {\n\t\tself.players_channels.remove(player);\n\t}\n\n\tpub fn send_to(\u0026self, player: \u0026PlayerId, command: Command) {\n\t\tif let Some(channel) = self.players_channels.get(player) {\n\t\t\tlet _ = channel.send(command);\n\t\t}\n\t}\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":15864},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":15864},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":318},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":624},"fn_name":null}],"covered":12,"coverable":12},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","session","event_loop.rs"],"content":"use {\n\tsuper::{command::Command, streams, unreliable, Session},\n\tcrate::{\n\t\trelevance::Relevance,\n\t\tsession::reliable,\n\t\tstate::{current_timestamp, EntityId},\n\t},\n\tbytes::{BufMut, BytesMut},\n\tcapnp::{\n\t\tmessage::{ReaderOptions, ScratchSpaceHeapAllocator},\n\t\tserialize_packed::{read_message, write_message},\n\t},\n\tfutures::{SinkExt, StreamExt},\n\tmetrics::{histogram, increment_counter},\n\tquark_client_sdk::protocol::{\n\t\thandshake::session_handshake_response,\n\t\tinbound::inbound,\n\t\toutbound::outbound,\n\t\tBuilderExt,\n\t},\n\tstd::{ops::ControlFlow, time::Instant},\n\ttokio::time::{interval, MissedTickBehavior},\n\ttracing::{trace, warn},\n};\n\n/// The most interesting code is in `event_loop.rs`,\n/// that is where the session loop is implemented and\n/// where the inbound messages are parsed and dispatched\n/// to their respective handlers.\npub fn spawn_event_loop(session: Session) {\n\ttokio::spawn(event_loop(session));\n}\n\n/// the event loop for a session processes incoming messages in a FIFO loop\n/// until the connection is dropped or some other fatal error occurs.\n///\n/// When the connection is dropped, the session is parked for resuming later,\n/// it can be resumed within a certain time limit by sending a resume request\n/// with the resume token that was provided at the beginning of the session.\n///\n/// If the session is not resumed within the time limit, it is dropped and\n/// the player state is deleted forever.\n///\n/// The session event loop processes inbound messages one by one and doesn't\n/// process the next message until the previous one has been fully processed\n/// and a response has been sent to the client. This sequential model helps\n/// with having an upper bound on the size of the inbound and outbound\n/// buffers and helps correlating requests and responses by the client.\npub async fn event_loop(mut session: Session) {\n\tlet session_start = Instant::now();\n\n\t// register a commands sender to this session in the global state\n\tsession\n\t\t.global\n\t\t.commands()\n\t\t.register(session.public_id, session.commands.sender());\n\n\t// immediately propagate to all machines in the cluster\n\t// that this player has connected to this server.\n\tsession.global.replicate().spawn(\n\t\tEntityId::Player(session.public_id),\n\t\t\u0026session\n\t\t\t.global\n\t\t\t.players()\n\t\t\t.get(\u0026session.public_id)\n\t\t\t.expect(\"just inserted\"),\n\t);\n\n\t// first confirm to the client that the session has started\n\tif let Err(e) = send_session_handshake_response(\u0026mut session).await {\n\t\twarn!(\"Failed to send handshake response: {e}\");\n\t\treturn;\n\t}\n\n\tlet mut remote_view_prune = remove_view_prune_interval(\u0026session).await;\n\n\tlet session_id = session.public_id;\n\tlet try_ = |result, counter| match result {\n\t\tOk(()) =\u003e ControlFlow::Continue(()),\n\t\tErr(e) =\u003e {\n\t\t\twarn!(session = session_id, \"Error {counter}: {e:}\");\n\t\t\tincrement_counter!(counter);\n\t\t\tControlFlow::Break(())\n\t\t}\n\t};\n\n\t// then start event loop\n\tloop {\n\t\tlet flow = tokio::select! {\n\t\t\t// external message from the client\n\t\t\tmessage = session.tcplink.next() =\u003e try_(\n\t\t\t\ttcp_message(message, \u0026mut session).await,\n\t\t\t\t\"session_tcp_message_processing_error\"),\n\n\t\t\t// internal commands from the system\n\t\t\tSome(command) = session.commands.receiver().recv() =\u003e try_(\n\t\t\t\tinternal_command(command, \u0026mut session).await,\n\t\t\t\t\"session_internal_command_processing_error\"),\n\n\t\t\t// Triggered when it is time to serve the next query\n\t\t\t// subscription to this client\n\t\t\tSome(tick) = session.streams.next() =\u003e\n\t\t\t\ttry_(\n\t\t\t\t\ttick.send(\u0026mut session).await,\n\t\t\t\t\t\"session_query_subscription_processing_error\"),\n\n\t\t\t// Triggered periodically when we need to clean non-relevant entities\n\t\t\t// from the remote view of this session. This is to prevent unbounded\n\t\t\t// growth of the remote view if too many entities were relevant to this\n\t\t\t// session at some point but are no longer relevant.\n\t\t\t_ = remote_view_prune.tick() =\u003e try_(\n\t\t\t\tprune_remote_view(\u0026mut session),\n\t\t\t\t\"session_remote_view_prune_error\"),\n\n\t\t\telse =\u003e ControlFlow::Break(())\n\t\t};\n\n\t\tif flow.is_break() {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// park the session for resuming later,\n\t// if not resumed within the graca period,\n\t// dispose of it, delete the in-memory player state\n\t// and unmap its public id to slot id.\n\tsession.global.resumes().park(\u0026session, |s| {\n\t\ttrace!(\n\t\t\tsession = s.public_id,\n\t\t\t\"session resume window expired, dropping slot\"\n\t\t);\n\t});\n\n\t// connection dropped or some other fatal error occured.\n\t// park this session for resuming later.\n\tdestroy_session(\u0026mut session);\n\n\thistogram!(\n\t\t\"session_duration\",\n\t\tsession_start.elapsed().as_millis() as f64\n\t);\n}\n\nasync fn remove_view_prune_interval(\n\tsession: \u0026Session,\n) -\u003e tokio::time::Interval {\n\tlet mut remote_view_prune =\n\t\tinterval(session.global.profile().remote_view_prune_interval);\n\tremote_view_prune.set_missed_tick_behavior(MissedTickBehavior::Delay);\n\tremote_view_prune.tick().await;\n\tremote_view_prune\n}\n\n/// Handles internal commands sent from various system components to this\n/// session\nasync fn internal_command(\n\tcommand: Command,\n\tsession: \u0026mut Session,\n) -\u003e anyhow::Result\u003c()\u003e {\n\tmatch command {\n\t\tCommand::Terminate =\u003e {\n\t\t\ttrace!(\n\t\t\t\tsession = session.public_id,\n\t\t\t\t\"session instructed to terminate by an internal command\"\n\t\t\t);\n\t\t\tanyhow::bail!(\"session terminated by an explicit request\");\n\t\t}\n\t\tCommand::DespawnObject(public_id) =\u003e {\n\t\t\t// stop tracking its attributes versions\n\t\t\t// remove the object entry from the cache that\n\t\t\t// keeps track of the attributes that have already been\tsent\n\t\t\t// to the session. Next time an object with the same id is spawned\n\t\t\t// the session will receive all attributes again.\n\t\t\tsession.version_map.remove(\u0026EntityId::Object(public_id));\n\n\t\t\t// queue up a despawn event if the session cares about it\n\t\t\tif session.streams.observes_despawns() {\n\t\t\t\tsession.despawns.push(public_id);\n\t\t\t}\n\t\t}\n\n\t\tCommand::PlayerDisconnected(public_id) =\u003e {\n\t\t\t// stop tracking its attributes versions\n\t\t\t// remove the player entry from the cache that\n\t\t\t// keeps track of the attributes that have already been\tsent\n\t\t\t// to the session. Next time a player with the same id is spawned\n\t\t\t// the session will receive all attributes again.\n\t\t\tsession.version_map.remove(\u0026EntityId::Player(public_id));\n\n\t\t\t// queue up a disconnect event if the session cares about it\n\t\t\tif session.streams.observes_disconnects() {\n\t\t\t\tsession.disconnects.push(public_id);\n\t\t\t}\n\t\t}\n\n\t\tCommand::ForgetPlayer(public_id) =\u003e {\n\t\t\t// stop tracking its attributes versions\n\t\t\t// remove the player entry from the cache that\n\t\t\t// keeps track of the attributes that have already been\tsent\n\t\t\t// to the session. Next time a player with the same id is spawned\n\t\t\t// the session will receive all attributes again.\n\t\t\tsession.version_map.remove(\u0026EntityId::Player(public_id));\n\t\t}\n\n\t\tCommand::ForgetObject(public_id) =\u003e {\n\t\t\t// stop tracking its attributes versions\n\t\t\t// remove the object entry from the cache that\n\t\t\t// keeps track of the attributes that have already been\tsent\n\t\t\t// to the session. Next time an object with the same id is spawned\n\t\t\t// the session will receive all attributes again.\n\t\t\tsession.version_map.remove(\u0026EntityId::Object(public_id));\n\t\t}\n\t\tCommand::ReceiveUDPStream(from, packet) =\u003e {\n\t\t\t// apply the incoming stream packet to the session state\n\t\t\tif let Err(e) = unreliable::process(session, packet, from) {\n\t\t\t\twarn!(\n\t\t\t\t\tsession = session.public_id,\n\t\t\t\t\t\"Failed to process udp stream packet: {e}\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tCommand::ReceiveEvent(event) =\u003e {\n\t\t\t// pass this event to any subscription that is interested in it.\n\t\t\tsession.streams.try_receive_event(event)\n\t\t}\n\t};\n\n\tOk(())\n}\n\n/// Handles messages sent from the client over the network\nasync fn tcp_message(\n\tmessage: Option\u003cResult\u003cBytesMut, std::io::Error\u003e\u003e,\n\tsession: \u0026mut Session,\n) -\u003e anyhow::Result\u003c()\u003e {\n\tlet request_start = Instant::now();\n\n\tlet bytes = message.ok_or(anyhow::anyhow!(\"socket closed\"))??.freeze();\n\thistogram!(\"tick_request_size\", bytes.len() as f64);\n\n\tenum Variant {\n\t\tStream,\n\t\tSubscribe,\n\t\tUnsubscribe,\n\t\tSyncTime,\n\t}\n\n\tlet variant = {\n\t\tlet message = read_message(bytes.as_ref(), ReaderOptions::new())?;\n\t\tlet reader = message.get_root::\u003cinbound::Reader\u003e()?;\n\n\t\ttrace!(\n\t\t\tsession = session.public_id,\n\t\t\t\"tcp message received: {reader:?}\"\n\t\t);\n\n\t\tmatch reader.which()? {\n\t\t\tinbound::Which::Stream(Ok(_)) =\u003e Variant::Stream,\n\t\t\tinbound::Which::Subscribe(Ok(_)) =\u003e Variant::Subscribe,\n\t\t\tinbound::Which::Unsubscribe(_) =\u003e Variant::Unsubscribe,\n\t\t\tinbound::Which::SyncTime(_) =\u003e Variant::SyncTime,\n\t\t\t_ =\u003e anyhow::bail!(\"invalid message received from client: {reader:?}\"),\n\t\t}\n\t};\n\n\tmatch variant {\n\t\tVariant::Stream =\u003e reliable::process(bytes, session).await?,\n\t\tVariant::Subscribe =\u003e streams::subscribe(bytes, session).await?,\n\t\tVariant::Unsubscribe =\u003e streams::unsubscribe(bytes, session).await?,\n\t\tVariant::SyncTime =\u003e send_sync_time_response(session).await?,\n\t};\n\n\thistogram!(\n\t\t\"tick_processing_time\",\n\t\trequest_start.elapsed().as_micros() as f64\n\t);\n\n\tOk(())\n}\n\n/// Sent at the beginning of a session to the client to confirm that the session\n/// has started and to provide the client with its assigned player id and resume\n/// token they can use to resume the session later if it gets disconnected.\nasync fn send_session_handshake_response(\n\tsession: \u0026mut Session,\n) -\u003e anyhow::Result\u003c()\u003e {\n\tlet output = {\n\t\tlet output = BytesMut::new();\n\t\tlet mut writer = output.writer();\n\n\t\tlet mut buffer = vec![0u8; 1024 * 10];\n\t\tlet mut response =\n\t\t\tcapnp::message::Builder::new(ScratchSpaceHeapAllocator::new(\u0026mut buffer));\n\t\tlet builder = response.init_root::\u003csession_handshake_response::Builder\u003e();\n\n\t\tlet mut started = builder.init_started();\n\t\tstarted.set_assigned_id(session.public_id);\n\t\tstarted.set_resume_token(session.resume_token.as_bytes());\n\t\twrite_message(\u0026mut writer, \u0026response)?;\n\t\twriter.into_inner().freeze()\n\t};\n\n\tsession.tcplink.send(output).await?;\n\n\tOk(())\n}\n\nfn destroy_session(session: \u0026mut Session) {\n\tsession\n\t\t.global\n\t\t.despawn_player(session.public_id, session.resume_token.clone());\n\ttrace!(session = session.public_id, \"session disconnected\");\n}\n\n/// Pruning of remote_view is necessary to keep size of remote_view in check.\n/// Left unchecked, it can grow rapidly.\n/// Refer: https://app.clickup.com/t/8693fh3d1\nfn prune_remote_view(session: \u0026mut Session) -\u003e anyhow::Result\u003c()\u003e {\n\tlet start = std::time::Instant::now();\n\tlet player_obj =\n\t\tsession\n\t\t\t.global\n\t\t\t.players()\n\t\t\t.get(\u0026session.public_id)\n\t\t\t.ok_or(anyhow::anyhow!(\n\t\t\t\t\"session exists without a corresponding player entry\"\n\t\t\t))?;\n\n\t// Find entities withing Relevance::max reach\n\tlet relevant_entities = session\n\t\t.global\n\t\t.indices()\n\t\t.relevant(\u0026player_obj, Relevance::max());\n\n\t// Retain entities which are in Relevance::max reach.\n\t// Prune others.\n\tsession\n\t\t.version_map\n\t\t.retain(|key, _value| relevant_entities.contains(key));\n\n\thistogram!(\"remote_view_prune_time\", start.elapsed().as_micros() as f64);\n\n\tOk(())\n}\n\nasync fn send_sync_time_response(session: \u0026mut Session) -\u003e anyhow::Result\u003c()\u003e {\n\tlet output = {\n\t\tlet mut message = capnp::message::Builder::new_default();\n\t\tmessage\n\t\t\t.init_root::\u003coutbound::Builder\u003e()\n\t\t\t.init_sync_time()\n\t\t\t.set_timestamp(current_timestamp());\n\t\tmessage.as_bytes()?\n\t};\n\n\tsession.tcplink.send(output).await?;\n\tOk(())\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":474},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":707},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":235},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":15886},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":15629},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":15651},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":472},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":235},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":306},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":306},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":246},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":246},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":305},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":539},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":539},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":1596},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":518},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":518},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":1036},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":518},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":518},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":518},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":518},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":6},"fn_name":null}],"covered":97,"coverable":121},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","session","handshake.rs"],"content":"use {\n\tsuper::{FramedStream, Session},\n\tcrate::{\n\t\tauth::authenticate,\n\t\tglobal::GlobalState,\n\t\tstate::{\n\t\t\tplayer::{PlayerEntity, PlayerId},\n\t\t\tEntityId,\n\t\t},\n\t},\n\tbytes::{BufMut, BytesMut},\n\tcapnp::{message::ReaderOptions, serialize_packed},\n\tfutures::{SinkExt, StreamExt},\n\tmetrics::increment_counter,\n\tquark_client_sdk::protocol::{\n\t\thandshake::{session_handshake_request, session_handshake_response},\n\t\tSessionErrorCode,\n\t},\n\tstd::{net::SocketAddr, sync::Arc},\n\ttracing::trace,\n};\n\npub type ResumeToken = Vec\u003cu8\u003e;\npub type AuthData = Vec\u003cu8\u003e;\n\n#[allow(clippy::large_enum_variant)]\npub enum SessionHandshake {\n\t/// The client is requesting a new session.\n\tNew(AuthData),\n\t/// The client is requesting resume a previously started session using a\n\t/// resume token.\n\tResume(ResumeToken),\n\n\t/// The client is pre-authenticated by a proxy node and is requesting to\n\t/// start a session on this server node.\n\t/// Here we are passing the proxy id and the player id assigned by the proxy\n\tInternal(String, PlayerId),\n}\n\npub fn parse_handshake(bytes: \u0026[u8]) -\u003e anyhow::Result\u003cSessionHandshake\u003e {\n\tlet reader = serialize_packed::read_message(bytes, ReaderOptions::default())?;\n\tlet handshake = reader.get_root::\u003csession_handshake_request::Reader\u003e()?;\n\n\tmatch handshake.which()? {\n\t\tsession_handshake_request::Which::Start(reader) =\u003e {\n\t\t\tOk(SessionHandshake::New(reader?.get_auth()?.to_vec()))\n\t\t}\n\t\tsession_handshake_request::Which::Resume(reader) =\u003e Ok(\n\t\t\t// extract resume token\n\t\t\tSessionHandshake::Resume(reader?.get_token()?.to_vec()),\n\t\t),\n\t\tsession_handshake_request::Which::Internal(reader) =\u003e {\n\t\t\tlet reader = reader?;\n\t\t\tOk(SessionHandshake::Internal(\n\t\t\t\treader.reborrow().get_proxy_id()?.to_string()?,\n\t\t\t\treader.reborrow().get_assigned_id(),\n\t\t\t))\n\t\t}\n\t}\n}\n\npub async fn handshake(\n\tmut stream: FramedStream,\n\tremote_addr: SocketAddr,\n\tstate: Arc\u003cGlobalState\u003e,\n) -\u003e anyhow::Result\u003cSession\u003e {\n\tlet Some(Ok(bytes)) = stream.next().await else {\n\t\treturn Err(anyhow::anyhow!(\"Client disconnected\"));\n\t};\n\n\tmatch parse_handshake(\u0026bytes)? {\n\t\tSessionHandshake::New(auth) =\u003e {\n\t\t\tnew_session(remote_addr, auth, state, stream).await\n\t\t}\n\n\t\tSessionHandshake::Resume(resume_token) =\u003e {\n\t\t\tresume_session(remote_addr, resume_token, state, stream).await\n\t\t}\n\t\tSessionHandshake::Internal(proxy_id, player_id) =\u003e {\n\t\t\tinternal_session(proxy_id, player_id, remote_addr, state, stream).await\n\t\t}\n\t}\n}\n\nasync fn internal_session(\n\tproxy_id: String,\n\tplayer_id: PlayerId,\n\tremote_addr: SocketAddr,\n\tstate: Arc\u003cGlobalState\u003e,\n\tstream: FramedStream,\n) -\u003e Result\u003cSession, anyhow::Error\u003e {\n\tif player_id == 0 {\n\t\tincrement_counter!(\"session_handshake_failure\");\n\t\tdisconnect_with_error(stream, SessionErrorCode::InvalidToken).await?;\n\t\tanyhow::bail!(\"Player id 0 is reserved for server use\")\n\t}\n\n\tif !state.topology().is_proxy(\u0026proxy_id) {\n\t\tincrement_counter!(\"session_handshake_failure\");\n\t\tdisconnect_with_error(stream, SessionErrorCode::InvalidRequest).await?;\n\t\tanyhow::bail!(\"Proxy id is not recognized\")\n\t}\n\n\tif state.players().contains_key(\u0026player_id) {\n\t\tincrement_counter!(\"session_handshake_failure\");\n\t\tdisconnect_with_error(\n\t\t\tstream, //\n\t\t\tSessionErrorCode::AlreadyConnected,\n\t\t)\n\t\t.await?;\n\t\tanyhow::bail!(\"Player already connected\")\n\t}\n\n\tstate\n\t\t.players()\n\t\t.insert(player_id, PlayerEntity::new(EntityId::Player(player_id)));\n\n\ttrace!(\"new session from {remote_addr}, public id: {player_id}\");\n\tincrement_counter!(\"session_new_success\");\n\n\tOk(Session::new(player_id, stream, state))\n}\n\nasync fn resume_session(\n\tremote_addr: SocketAddr,\n\tresume_token: Vec\u003cu8\u003e,\n\tstate: Arc\u003cGlobalState\u003e,\n\tstream: tokio_util::codec::Framed\u003c\n\t\ttokio::net::TcpStream,\n\t\ttokio_util::codec::LengthDelimitedCodec,\n\t\u003e,\n) -\u003e Result\u003cSession, anyhow::Error\u003e {\n\tlet string_token = String::from_utf8(resume_token)?;\n\tif let Some(session) = state.resumes().take(\u0026string_token) {\n\t\tincrement_counter!(\"session_resume_success\");\n\n\t\tlet player_id = session.public_id;\n\t\tif state.players().contains_key(\u0026player_id) {\n\t\t\tdisconnect_with_error(stream, SessionErrorCode::InvalidToken).await?;\n\t\t\tanyhow::bail!(\"Player already connected\")\n\t\t}\n\n\t\ttracing::trace!(\n\t\t\t\"Resuming session {player_id} using session token {string_token} from \\\n\t\t\t {remote_addr}\"\n\t\t);\n\n\t\tstate.players().insert(player_id, session.entity);\n\t\tOk(Session::new(session.public_id, stream, state))\n\t} else {\n\t\ttrace!(\"unrecognized resume token {string_token}\");\n\t\tincrement_counter!(\"session_handshake_failure\");\n\t\tdisconnect_with_error(stream, SessionErrorCode::InvalidToken).await?;\n\t\tanyhow::bail!(\"Invalid resume token\")\n\t}\n}\n\nasync fn new_session(\n\tremote_addr: SocketAddr,\n\tauth: Vec\u003cu8\u003e,\n\tstate: Arc\u003cGlobalState\u003e,\n\tstream: FramedStream,\n) -\u003e Result\u003cSession, anyhow::Error\u003e {\n\tlet initial_state = match authenticate(\u0026auth, state.auth()) {\n\t\tOk(auth) =\u003e auth,\n\t\tErr(e) =\u003e {\n\t\t\tincrement_counter!(\"session_handshake_auth_failure\");\n\t\t\tdisconnect_with_error(\n\t\t\t\tstream, //\n\t\t\t\tSessionErrorCode::AuthenticationFailed,\n\t\t\t)\n\t\t\t.await?;\n\t\t\tanyhow::bail!(\"Invalid auth data: {e:}\")\n\t\t}\n\t};\n\n\tlet EntityId::Player(player_id) = *initial_state.id() else {\n\t\tincrement_counter!(\"session_handshake_failure\");\n\t\tdisconnect_with_error(\n\t\t\tstream, //\n\t\t\tSessionErrorCode::InvalidToken,\n\t\t)\n\t\t.await?;\n\t\tanyhow::bail!(\"Player id was not assigned correctly\")\n\t};\n\n\tif player_id == 0 {\n\t\tincrement_counter!(\"session_handshake_failure\");\n\t\tdisconnect_with_error(\n\t\t\tstream, //\n\t\t\tSessionErrorCode::InvalidToken,\n\t\t)\n\t\t.await?;\n\t\tanyhow::bail!(\"Player id 0 is reserved for server use\")\n\t}\n\n\tif state.players().contains_key(\u0026player_id) {\n\t\tincrement_counter!(\"session_handshake_failure\");\n\t\tdisconnect_with_error(\n\t\t\tstream, //\n\t\t\tSessionErrorCode::AlreadyConnected,\n\t\t)\n\t\t.await?;\n\t\tanyhow::bail!(\"Player already connected\")\n\t}\n\n\tstate.players().insert(player_id, initial_state);\n\ttrace!(\"new session from {remote_addr}, public id: {player_id}\");\n\tincrement_counter!(\"session_new_success\");\n\n\t// create session object. This object has all we need\n\t// to start an event loop for this connection.\n\tOk(Session::new(player_id, stream, state))\n}\n\npub async fn disconnect_with_error(\n\tmut stream: FramedStream,\n\tcode: SessionErrorCode,\n) -\u003e anyhow::Result\u003c()\u003e {\n\tlet outbuf = {\n\t\tlet outbuf = BytesMut::new();\n\t\tlet mut writer = outbuf.writer();\n\n\t\tlet mut message = capnp::message::Builder::new_default();\n\t\tlet mut response =\n\t\t\tmessage.init_root::\u003csession_handshake_response::Builder\u003e();\n\t\tresponse.set_rejected(code);\n\n\t\tcapnp::serialize_packed::write_message(\u0026mut writer, \u0026message)?;\n\t\twriter.into_inner().freeze()\n\t};\n\n\t// Encode length in the buffer\n\tstream.send(outbuf).await?;\n\n\tincrement_counter!(\"session_handshake_failure\");\n\n\tOk(())\n}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":480},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":234},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":702},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":720},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":240},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":234},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":234},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":234},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":465},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":231},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":231},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":231},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":231},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":231},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":231},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":45,"coverable":98},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","session","interests.rs"],"content":"use {\n\tsuper::command::{Command, Commands},\n\tcrate::state::{object::ObjectId, player::PlayerId, EntityId},\n\tdashmap::DashMap,\n\tfxhash::FxBuildHasher,\n\tstd::{\n\t\tsync::Arc,\n\t\ttime::{Duration, Instant},\n\t},\n};\n\ntype ObjectsMap =\n\tDashMap\u003cObjectId, DashMap\u003cPlayerId, Instant, FxBuildHasher\u003e, FxBuildHasher\u003e;\ntype PlayersMap =\n\tDashMap\u003cPlayerId, DashMap\u003cPlayerId, Instant, FxBuildHasher\u003e, FxBuildHasher\u003e;\n\npub struct Interests {\n\t/// Keeps track of which players are aware of a given object.\n\t/// A player becomes aware of an object if it has received at least\n\t/// one update about the object during its session.\n\tobjects: Arc\u003cObjectsMap\u003e,\n\n\t/// Keeps track of which players are aware of a given player.\n\t/// A player becomes aware of another player if it has received at least\n\t/// one update about the player during its session.\n\tplayers: Arc\u003cPlayersMap\u003e,\n}\n\nimpl Interests {\n\tpub fn new(commands: Arc\u003cCommands\u003e) -\u003e Self {\n\t\tlet instance = Self {\n\t\t\tobjects: Arc::new(DashMap::with_hasher(FxBuildHasher::default())),\n\t\t\tplayers: Arc::new(DashMap::with_hasher(FxBuildHasher::default())),\n\t\t};\n\t\t// periodically purge expired entries,\n\t\t// this is done to avoid explosive growth of the interest tracking\n\t\t// data structures\n\t\ttokio::spawn(purge_loop(\n\t\t\tArc::clone(\u0026instance.objects),\n\t\t\tArc::clone(\u0026instance.players),\n\t\t\tcommands,\n\t\t));\n\n\t\tinstance\n\t}\n}\n\nimpl Interests {\n\t/// Tells the system that a given player has become aware of a given set of\n\t/// objects.\n\tpub fn mark_awareness(\u0026self, player: PlayerId, entities: \u0026[EntityId]) {\n\t\tfor entity_id in entities {\n\t\t\tmatch entity_id {\n\t\t\t\tEntityId::Player(id) =\u003e {\n\t\t\t\t\tself\n\t\t\t\t\t\t.players\n\t\t\t\t\t\t.entry(*id)\n\t\t\t\t\t\t.or_default()\n\t\t\t\t\t\t.insert(player, Instant::now());\n\t\t\t\t}\n\t\t\t\tEntityId::Object(id) =\u003e {\n\t\t\t\t\tself\n\t\t\t\t\t\t.objects\n\t\t\t\t\t\t.entry(*id)\n\t\t\t\t\t\t.or_default()\n\t\t\t\t\t\t.insert(player, Instant::now());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpub fn forget(\u0026self, player: PlayerId, entities: \u0026[EntityId]) {\n\t\tfor entity_id in entities {\n\t\t\tmatch entity_id {\n\t\t\t\tEntityId::Player(id) =\u003e {\n\t\t\t\t\tlet mut removeit = false;\n\t\t\t\t\tif let Some(p) = self.players.get(id) {\n\t\t\t\t\t\tp.value().remove(\u0026player);\n\n\t\t\t\t\t\tif p.value().is_empty() {\n\t\t\t\t\t\t\tremoveit = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif removeit {\n\t\t\t\t\t\tself.players.remove(id);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tEntityId::Object(id) =\u003e {\n\t\t\t\t\tlet mut removeit = false;\n\t\t\t\t\tif let Some(p) = self.objects.get(id) {\n\t\t\t\t\t\tp.value().remove(\u0026player);\n\n\t\t\t\t\t\tif p.value().is_empty() {\n\t\t\t\t\t\t\tremoveit = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif removeit {\n\t\t\t\t\t\tself.objects.remove(id);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/// Returns all players that know of an object and removes that collection\n\t/// from the interest tracking. This happens during despawn, when we an object\n\t/// is destroyed and we want to tell every player that is aware of it that it\n\t/// has been destroyed.\n\tpub fn take_players_aware_of_object(\n\t\t\u0026self,\n\t\tobject: ObjectId,\n\t) -\u003e Option\u003cVec\u003cPlayerId\u003e\u003e {\n\t\tself\n\t\t\t.objects\n\t\t\t.remove(\u0026object)\n\t\t\t.map(|(_, removed)| removed.into_iter().map(|elem| elem.0).collect())\n\t}\n\n\t/// Returns all players that know of a player and removes that collection\n\t/// from the interest tracking. This happens during disconnect, when we a\n\t/// player is disconnected and we want to tell every player that is aware of\n\t/// it that it has been disconnected.\n\tpub fn take_players_aware_of_player(\n\t\t\u0026self,\n\t\tplayer: PlayerId,\n\t) -\u003e Option\u003cVec\u003cPlayerId\u003e\u003e {\n\t\tself\n\t\t\t.players\n\t\t\t.remove(\u0026player)\n\t\t\t.map(|(_, removed)| removed.into_iter().map(|elem| elem.0).collect())\n\t}\n}\n\nasync fn purge_loop(\n\tobjects: Arc\u003cObjectsMap\u003e,\n\tplayers: Arc\u003cPlayersMap\u003e,\n\tcommands: Arc\u003cCommands\u003e,\n) {\n\tconst INTEREST_TIMEOUT: Duration = Duration::from_secs(60 * 3);\n\tconst INTEREST_PURGE_INTERVAL: Duration = Duration::from_secs(15);\n\n\tloop {\n\t\ttokio::time::sleep(INTEREST_PURGE_INTERVAL).await;\n\n\t\tlet now = Instant::now();\n\n\t\tobjects.retain(|object_id_source, interested| {\n\t\t\tinterested.retain(|player_id_target, t| {\n\t\t\t\tlet expired = now - *t \u003c INTEREST_TIMEOUT;\n\n\t\t\t\tif expired {\n\t\t\t\t\tcommands.send_to(\n\t\t\t\t\t\tplayer_id_target,\n\t\t\t\t\t\tCommand::ForgetObject(*object_id_source),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\texpired\n\t\t\t});\n\n\t\t\t!interested.is_empty()\n\t\t});\n\n\t\tplayers.retain(|player_id_source, interested| {\n\t\t\tinterested.retain(|player_id_target, t| {\n\t\t\t\tlet expired = now - *t \u003c INTEREST_TIMEOUT;\n\n\t\t\t\tif expired {\n\t\t\t\t\tcommands.send_to(\n\t\t\t\t\t\tplayer_id_target,\n\t\t\t\t\t\tCommand::ForgetPlayer(*player_id_source),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\texpired\n\t\t\t});\n\n\t\t\t!interested.is_empty()\n\t\t});\n\t}\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":3541},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":21395},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":4327},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":4327},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":4327},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":4327},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":4327},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":4600},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":4600},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":4600},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":4600},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":4600},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":123},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":61,"coverable":67},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","session","mod.rs"],"content":"use {\n\tself::{\n\t\tcommand::{Channel, Command},\n\t\trelevance::RelevanceQuery,\n\t\tversions::VersionMap,\n\t},\n\tcrate::{\n\t\tglobal::GlobalState,\n\t\trelevance::Relevance,\n\t\tstate::{\n\t\t\tobject::ObjectId,\n\t\t\tplayer::{PlayerEntity, PlayerId},\n\t\t\tEntityId,\n\t\t},\n\t},\n\tdashmap::mapref::one::Ref,\n\tfxhash::FxBuildHasher,\n\tnanoid::nanoid,\n\trustc_hash::FxHashSet,\n\tstd::{\n\t\tnet::{IpAddr, Ipv4Addr, SocketAddr},\n\t\tsync::Arc,\n\t},\n\tstreams::Streams,\n\ttokio_util::codec::{Framed, LengthDelimitedCodec},\n};\n\npub mod command;\npub mod event_loop;\npub mod handshake;\npub mod interests;\npub mod resume;\npub mod tick;\npub mod versions;\n\nmod relevance;\nmod reliable;\nmod streams;\nmod unreliable;\n\npub type FramedStream = Framed\u003ctokio::net::TcpStream, LengthDelimitedCodec\u003e;\n\npub struct Session {\n\tpub tcplink: FramedStream,\n\tpub version_map: VersionMap,\n\tpub resume_token: String,\n\tpub public_id: PlayerId,\n\tpub commands: Channel\u003cCommand\u003e,\n\tpub despawns: Vec\u003cObjectId\u003e,\n\tpub disconnects: Vec\u003cPlayerId\u003e,\n\tpub global: Arc\u003cGlobalState\u003e,\n\tpub streams: Streams,\n\trelevance: RelevanceQuery,\n\tremote_addr: SocketAddr,\n}\n\nimpl Session {\n\tpub fn new(\n\t\tpublic_id: PlayerId,\n\t\ttcplink: FramedStream,\n\t\tglobal: Arc\u003cGlobalState\u003e,\n\t) -\u003e Self {\n\t\tlet queries = Streams::default();\n\t\tlet relevance = RelevanceQuery::new(\u0026global);\n\n\t\t// The port number for UDP and TCP is the same for the client\n\t\t// and the server. The remote address is update on every UDP\n\t\t// message coming from the client.\n\t\tlet remote_addr = tcplink.get_ref().peer_addr().unwrap_or_else(|_| {\n\t\t\tSocketAddr::new(IpAddr::V4(Ipv4Addr::new(0, 0, 0, 0)), 0)\n\t\t});\n\n\t\tSelf {\n\t\t\tglobal,\n\t\t\tstreams: queries,\n\t\t\ttcplink,\n\t\t\tpublic_id,\n\t\t\trelevance,\n\t\t\tremote_addr,\n\t\t\tdespawns: Vec::new(),\n\t\t\tdisconnects: Vec::new(),\n\t\t\tcommands: Channel::default(),\n\t\t\tresume_token: nanoid!(16),\n\t\t\tversion_map: VersionMap::default(),\n\t\t}\n\t}\n\n\tpub fn player_obj(\u0026self) -\u003e Ref\u003c'_, PlayerId, PlayerEntity, FxBuildHasher\u003e {\n\t\tself\n\t\t\t.global\n\t\t\t.players()\n\t\t\t.get(\u0026self.public_id)\n\t\t\t.expect(\"session exists without a corresponding player\")\n\t}\n\n\tpub fn query_relevant(\u0026mut self, radius: Relevance) -\u003e FxHashSet\u003cEntityId\u003e {\n\t\tlet player_obj = self\n\t\t\t.global\n\t\t\t.players()\n\t\t\t.get(\u0026self.public_id)\n\t\t\t.expect(\"session exists without a corresponding player\");\n\n\t\tself\n\t\t\t.relevance\n\t\t\t.query(player_obj.value(), self.public_id, radius)\n\t}\n}\n","traces":[{"line":58,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":1464},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":1464},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":1464},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":1464},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null}],"covered":20,"coverable":21},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","session","relevance.rs"],"content":"use {\n\tcrate::{\n\t\tglobal::GlobalState,\n\t\trelevance::Relevance,\n\t\tstate::{\n\t\t\tplayer::{PlayerEntity, PlayerId},\n\t\t\tEntityId,\n\t\t},\n\t},\n\trustc_hash::{FxHashMap, FxHashSet},\n\tstd::{\n\t\tcollections::hash_map::Entry,\n\t\tsync::Arc,\n\t\ttime::{Duration, Instant},\n\t},\n};\n\nstruct RelevanceSnapshot(Instant, FxHashSet\u003cEntityId\u003e);\n\nimpl RelevanceSnapshot {\n\tfn new(data: FxHashSet\u003cEntityId\u003e) -\u003e Self {\n\t\tSelf(Instant::now(), data)\n\t}\n}\n\npub struct RelevanceQuery {\n\tglobal: Arc\u003cGlobalState\u003e,\n\tvalidity_timeout: Duration,\n\tsnapshots: FxHashMap\u003cu32, RelevanceSnapshot\u003e,\n\n\t/// This is used to keep track of the widest query made so far,\n\t/// and it is used to optimize the number of calls to mark_awareness.\n\t/// If there was a query that is wider (larger relavance value) than the\n\t/// current one, and that query happened in less than the validity_timeout,\n\t/// then we don't need to call mark_awareness again as all the entries\n\t/// in the smaller query should be contained in the wider query.\n\twidest_query: (Relevance, Instant),\n}\n\nimpl RelevanceQuery {\n\tpub fn new(global: \u0026Arc\u003cGlobalState\u003e) -\u003e Self {\n\t\tSelf {\n\t\t\tglobal: Arc::clone(global),\n\t\t\tvalidity_timeout: global.profile().relevance_timeout,\n\t\t\tsnapshots: FxHashMap::default(),\n\t\t\twidest_query: (\n\t\t\t\tRelevance::min(),\n\t\t\t\tInstant::now() - global.profile().relevance_timeout,\n\t\t\t),\n\t\t}\n\t}\n\n\t/// Manages queries to relevancy indices and their caches.\n\t/// This is responsible for determining which players and objects are\n\t/// currently relevant to this session.\n\tpub fn query(\n\t\t\u0026mut self,\n\t\tplayer: \u0026PlayerEntity,\n\t\tplayer_id: PlayerId,\n\t\trelevance: Relevance,\n\t) -\u003e FxHashSet\u003cEntityId\u003e {\n\t\tlet relevance_bits = relevance.to_bits();\n\t\tmatch self.snapshots.entry(relevance_bits) {\n\t\t\tEntry::Occupied(mut entry) =\u003e {\n\t\t\t\tlet RelevanceSnapshot(at, data) = entry.get_mut();\n\t\t\t\tif at.elapsed() \u003c self.validity_timeout {\n\t\t\t\t\treturn data.clone();\n\t\t\t\t}\n\n\t\t\t\tentry.insert(RelevanceSnapshot::new(fetch_full_graph(\n\t\t\t\t\tplayer_id,\n\t\t\t\t\tself.global.indices().relevant(player, relevance),\n\t\t\t\t\t\u0026self.global,\n\t\t\t\t)));\n\t\t\t}\n\t\t\tEntry::Vacant(space) =\u003e {\n\t\t\t\tspace.insert(RelevanceSnapshot::new(fetch_full_graph(\n\t\t\t\t\tplayer_id,\n\t\t\t\t\tself.global.indices().relevant(player, relevance),\n\t\t\t\t\t\u0026self.global,\n\t\t\t\t)));\n\t\t\t}\n\t\t};\n\n\t\t// If the current query is wider than the previous one, or the\n\t\t// previous query has expired, update the widest query.\n\t\tif self.widest_query.1.elapsed() \u003e self.validity_timeout\n\t\t\t|| relevance \u003e= self.widest_query.0\n\t\t{\n\t\t\tself.widest_query = (relevance, Instant::now());\n\t\t\tmark_awareness(\n\t\t\t\t\u0026self.global,\n\t\t\t\tplayer_id,\n\t\t\t\t\u0026self.snapshots[\u0026relevance_bits].1,\n\t\t\t);\n\t\t}\n\n\t\tself.snapshots[\u0026relevance_bits].1.clone()\n\t}\n}\n\nfn mark_awareness(\n\tglobal: \u0026Arc\u003cGlobalState\u003e,\n\tplayer_id: PlayerId,\n\tentities: \u0026FxHashSet\u003cEntityId\u003e,\n) {\n\tlet global = Arc::clone(global);\n\tlet entities = entities.clone().into_iter().collect::\u003cVec\u003c_\u003e\u003e();\n\ttokio::spawn(async move {\n\t\tglobal.interests().mark_awareness(player_id, \u0026entities);\n\t});\n}\n\n/// Fetches the full graph of entities that are relevant to the given roots.\n///\n/// Relevancy indices only retreives entities that are directly relevant to the\n/// player, this function fetches all children of the relevant entities.\nfn fetch_full_graph(\n\tplayer_id: PlayerId,\n\troots: FxHashSet\u003cEntityId\u003e,\n\tglobal: \u0026GlobalState,\n) -\u003e FxHashSet\u003cEntityId\u003e {\n\tlet mut visited = FxHashSet::default();\n\tlet mut stack = Vec::with_capacity(roots.len());\n\n\t// Add all children of the current player to the stack\n\tstack.extend(\n\t\tglobal\n\t\t\t.graph()\n\t\t\t.children_of(EntityId::Player(player_id))\n\t\t\t.into_iter()\n\t\t\t.map(EntityId::Object),\n\t);\n\n\t// add all roots gathered by relevancy indices\n\tstack.extend(roots.iter().cloned());\n\n\t// traverse all roots and their children\n\twhile let Some(entity) = stack.pop() {\n\t\tif visited.insert(entity) {\n\t\t\tstack.extend(\n\t\t\t\tglobal\n\t\t\t\t\t.graph()\n\t\t\t\t\t.children_of(entity)\n\t\t\t\t\t.into_iter()\n\t\t\t\t\t.map(EntityId::Object),\n\t\t\t);\n\t\t}\n\t}\n\n\tvisited\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":2908},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":2908},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":14577},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":14577},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":14577},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":11898},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2679},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":2679},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":2679},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":2679},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":229},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":229},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":229},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":229},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":229},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":2908},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":2908},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":2908},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":2908},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":2908},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":2908},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":2908},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":2908},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":2908},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":5816},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":2908},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":2908},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":2908},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":2908},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":2908},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":2908},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":2908},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":2908},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":2908},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":2908},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":2908},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":27108},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":8294},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":8294},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":8294},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":8294},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":8294},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":8294},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":8294},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":2908},"fn_name":null}],"covered":53,"coverable":54},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","session","reliable.rs"],"content":"//! This module is repsonsible for managing the reliable TCP channel\n\nuse {\n\tsuper::{\n\t\ttick::{build_objects, build_players, UpdateSet},\n\t\tSession,\n\t},\n\tcrate::{\n\t\tevents::{self, Event},\n\t\tsession::tick::{build_events, update_objects_state, update_player_state},\n\t\tstate::EntityId,\n\t},\n\tbytes::{BufMut, Bytes, BytesMut},\n\tcapnp::{\n\t\tmessage::{ReaderOptions, ScratchSpaceHeapAllocator},\n\t\tserialize_packed::read_message,\n\t},\n\tfutures::SinkExt,\n\tmetrics::histogram,\n\tquark_client_sdk::protocol::{\n\t\tinbound::inbound::{self, Which},\n\t\toutbound::outbound,\n\t},\n\tstd::sync::Arc,\n\ttracing::trace,\n};\n\n/// Processes tick messages that come from the client through the reliable TCP\n/// channel. We don't have any size limit on the message that is sent through\n/// the reliable channgel because it guarantees ordering and delivery.\npub async fn process(\n\tmessage: Bytes,\n\tsession: \u0026mut Session,\n) -\u003e anyhow::Result\u003c()\u003e {\n\tlet message = read_message(message.as_ref(), ReaderOptions::new())?;\n\tlet reader = message.get_root::\u003cinbound::Reader\u003e()?;\n\tlet Which::Stream(Ok(reader)) = reader.which()? else {\n\t\tanyhow::bail!(\"Expected a stream message\");\n\t};\n\n\tupdate_player_state(reader.get_player()?, session)?;\n\tupdate_objects_state(reader.get_objects()?, session)?;\n\tevents::process(reader.get_events()?, session)?;\n\n\tOk(())\n}\n\n/// Sends a reliable tick to the client over TCP.\n///\n/// In this case we don't have constrains on the packet size so we just send a\n/// complete capnproto buffer as is.\npub async fn send(\n\tsession: \u0026mut Session,\n\tupdate_set: Vec\u003c(EntityId, Vec\u003cu16\u003e)\u003e,\n\tevents: Vec\u003cArc\u003cEvent\u003e\u003e,\n) -\u003e anyhow::Result\u003c(UpdateSet, Vec\u003cArc\u003cEvent\u003e\u003e)\u003e {\n\thistogram!(\"tcp_update_set_count\", update_set.len() as f64);\n\n\tlet output = {\n\t\tlet output = BytesMut::new();\n\t\tlet mut writer = output.writer();\n\n\t\tlet mut scratch_space = [0u8; 1024 * 16];\n\t\tlet mut message = capnp::message::Builder::new(\n\t\t\tScratchSpaceHeapAllocator::new(\u0026mut scratch_space),\n\t\t);\n\n\t\tlet (players_update_set, objects_update_set): (Vec\u003c_\u003e, Vec\u003c_\u003e) = update_set\n\t\t\t.iter()\n\t\t\t.partition(|\u0026entity| matches!(entity, (EntityId::Player(_), _)));\n\n\t\tlet mut builder = message.init_root::\u003coutbound::Builder\u003e();\n\t\tlet mut stream_update = builder.reborrow().init_stream();\n\n\t\tbuild_players(\n\t\t\tstream_update\n\t\t\t\t.reborrow()\n\t\t\t\t.init_players(players_update_set.len() as u32),\n\t\t\t\u0026players_update_set,\n\t\t\t\u0026mut session.version_map,\n\t\t\t\u0026session.global,\n\t\t);\n\n\t\tbuild_objects(\n\t\t\tstream_update\n\t\t\t\t.reborrow()\n\t\t\t\t.init_objects(objects_update_set.len() as u32),\n\t\t\t\u0026objects_update_set,\n\t\t\t\u0026mut session.version_map,\n\t\t\t\u0026session.global,\n\t\t);\n\n\t\tbuild_events(\n\t\t\tstream_update.reborrow().init_events(events.len() as u32),\n\t\t\tevents.into_iter(),\n\t\t);\n\n\t\ttrace!(\n\t\t\tsession = session.public_id,\n\t\t\t\"sending TCP stream tick: {:?}\",\n\t\t\tbuilder.into_reader()\n\t\t);\n\n\t\t// serialize the response into a byte buffer\n\t\tcapnp::serialize_packed::write_message(\u0026mut writer, \u0026message)\n\t\t\t.expect(\"failed to serialize capnp world_update message\");\n\t\twriter.into_inner().freeze()\n\t};\n\n\tsession.tcplink.send(output).await?;\n\n\t// tcp doesn't have a limit on the size of the message,\n\t// so after sending the message we can return an empty\n\t// set of remaining updates.\n\tOk((UpdateSet::default(), vec![]))\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":540},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":540},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":540},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":540},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":270},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":363},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":363},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":363},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":363},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":363},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":363},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":363},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":363},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2429},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":363},"fn_name":null}],"covered":18,"coverable":22},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","session","resume.rs"],"content":"use {\n\tsuper::Session,\n\tcrate::state::player::{PlayerEntity, PlayerId},\n\tdashmap::DashMap,\n\tfxhash::FxBuildHasher,\n\tstd::{fmt::Debug, sync::Arc, time::Duration},\n};\n\npub struct ResumableSession {\n\tpub public_id: PlayerId,\n\tpub entity: PlayerEntity,\n}\n\nimpl Debug for ResumableSession {\n\tfn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n\t\tf.debug_struct(\"ResumableSession\")\n\t\t\t.field(\"public_id\", \u0026self.public_id)\n\t\t\t.field(\"entity\", \u0026self.entity)\n\t\t\t.finish()\n\t}\n}\n\n#[derive(Debug)]\npub struct ResumableSessions {\n\ttimeout: Duration,\n\tsessions: Arc\u003cDashMap\u003cString, ResumableSession, FxBuildHasher\u003e\u003e,\n}\n\nimpl ResumableSessions {\n\tpub fn new(timeout: Duration) -\u003e Self {\n\t\tSelf {\n\t\t\ttimeout,\n\t\t\tsessions: Arc::new(DashMap::default()),\n\t\t}\n\t}\n\n\tpub fn park(\n\t\t\u0026self,\n\t\tsession: \u0026Session,\n\t\ton_dispose: impl FnOnce(ResumableSession) + Send + 'static,\n\t) {\n\t\tlet entity = session.player_obj().value().clone();\n\t\tself\n\t\t\t.sessions\n\t\t\t.insert(session.resume_token.clone(), ResumableSession {\n\t\t\t\tentity,\n\t\t\t\tpublic_id: session.public_id,\n\t\t\t});\n\n\t\ttracing::trace!(\n\t\t\t\"parking resumable session {} ({})\",\n\t\t\tsession.public_id,\n\t\t\tsession.resume_token\n\t\t);\n\n\t\tlet timeout = self.timeout;\n\t\tlet sessions = Arc::clone(\u0026self.sessions);\n\t\tlet resume_token = session.resume_token.clone();\n\n\t\t// if it is not resumed within the timeout duration, then remove it\n\t\t// and free up that session slot.\n\t\ttokio::spawn(async move {\n\t\t\ttokio::time::sleep(timeout).await;\n\t\t\tif let Some((_, session)) = sessions.remove(\u0026resume_token) {\n\t\t\t\ton_dispose(session);\n\t\t\t}\n\t\t});\n\t}\n\n\t/// Parks a session without a disposable callback.\n\tpub fn park_raw_session(\n\t\t\u0026self,\n\t\tpublic_id: u32,\n\t\ttoken: String,\n\t\tentity: PlayerEntity,\n\t) {\n\t\tself\n\t\t\t.sessions\n\t\t\t.insert(token.clone(), ResumableSession { public_id, entity });\n\n\t\tlet timeout = self.timeout;\n\t\tlet sessions = Arc::clone(\u0026self.sessions);\n\n\t\t// if it is not resumed within the timeout duration, then remove it\n\t\t// and free up that session slot.\n\t\ttokio::spawn(async move {\n\t\t\ttokio::time::sleep(timeout).await;\n\t\t\tlet _ = sessions.remove(\u0026token);\n\t\t});\n\t}\n\n\tpub fn take(\u0026self, resume_token: \u0026str) -\u003e Option\u003cResumableSession\u003e {\n\t\ttracing::info!(\"resumes: {:?}\", self.sessions);\n\t\tself\n\t\t\t.sessions\n\t\t\t.remove(resume_token)\n\t\t\t.map(|(_, session)| session)\n\t}\n\n\t#[cfg(test)]\n\tpub fn _iter(\u0026self, mut op: impl FnMut(\u0026str, \u0026ResumableSession)) {\n\t\tself.sessions.iter().for_each(|i| op(i.key(), i.value()))\n\t}\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":30,"coverable":41},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","session","streams.rs"],"content":"//! This module implements the server side part of the Streams API.\n\nuse {\n\tsuper::{\n\t\treliable,\n\t\ttick::{populate_despawns, populate_disconnects},\n\t\tunreliable,\n\t\tSession,\n\t},\n\tcrate::{events::Event, session::tick::calculate_update_set},\n\tbytes::Bytes,\n\tcapnp::{message::ReaderOptions, serialize_packed::read_message},\n\tcrossbeam::queue::ArrayQueue,\n\tfutures::{FutureExt, Stream},\n\tmetrics::histogram,\n\tquark_client_sdk::{\n\t\tprotocol::{\n\t\t\tevents::SystemEvents,\n\t\t\tinbound::{\n\t\t\t\tevents_filter,\n\t\t\t\tinbound::{self, Which},\n\t\t\t},\n\t\t},\n\t\tEventClass,\n\t\tEventsFilter,\n\t\tQoS,\n\t\tQuery,\n\t\tSubscriptionId,\n\t},\n\tstd::{\n\t\tcmp::Ordering,\n\t\tcollections::BinaryHeap,\n\t\tmem::take,\n\t\tpin::Pin,\n\t\tsync::Arc,\n\t\ttask::{Context, Poll},\n\t\ttime::Duration,\n\t},\n\ttokio::time::{sleep, Instant, Sleep},\n};\n\n/// Handles the subscription message from the client.\n/// Those messages are always sent over TCP.\npub async fn subscribe(\n\tmessage: Bytes,\n\tsession: \u0026mut Session,\n) -\u003e anyhow::Result\u003c()\u003e {\n\tlet message = read_message(message.as_ref(), ReaderOptions::new())?;\n\tlet reader = message.get_root::\u003cinbound::Reader\u003e()?;\n\n\tlet Which::Subscribe(Ok(reader)) = reader.which()? else {\n\t\tanyhow::bail!(\"Expected a subscribe message\");\n\t};\n\n\tlet query = Query {\n\t\tradius: reader.get_interest_radius().into(),\n\t\ttags: reader\n\t\t\t.get_tags()?\n\t\t\t.into_iter()\n\t\t\t.filter_map(|t| t.ok())\n\t\t\t.filter_map(|t| t.to_str().map(|s| s.to_string()).ok())\n\t\t\t.collect(),\n\t\tinterval: Duration::from_millis(reader.get_interval() as u64),\n\t\tpriority: reader.get_priority().into(),\n\t\tevents: match reader.get_events()?.which()? {\n\t\t\tevents_filter::Which::Whitelist(Ok(list)) =\u003e {\n\t\t\t\tEventsFilter::Whitelist(list.into_iter().collect())\n\t\t\t}\n\t\t\tevents_filter::Which::Blacklist(Ok(list)) =\u003e {\n\t\t\t\tEventsFilter::Blacklist(list.into_iter().collect())\n\t\t\t}\n\t\t\t_ =\u003e anyhow::bail!(\"Invalid events filter\"),\n\t\t},\n\t\tbacklog: match reader.get_backlog() {\n\t\t\t0 =\u003e 64, // default backlog size\n\t\t\tn =\u003e n as usize,\n\t\t},\n\t};\n\n\tlet id = reader.get_subscription_id();\n\n\tlet qos = match reader.get_reliable() {\n\t\ttrue =\u003e QoS::Reliable,\n\t\tfalse =\u003e QoS::Unreliable,\n\t};\n\n\t// we're putting an upper limit on the interval to prevent\n\t// clients from spamming the server with too many queries\n\tif query.interval \u003c Duration::from_millis(30) {\n\t\tanyhow::bail!(\"Invalid query subscription interval: {:?}\", query.interval);\n\t}\n\n\ttracing::trace!(\n\t\tsession = session.public_id,\n\t\t\"subscribing to query: {query:?}, id: {id}, qos: {qos:?}\"\n\t);\n\n\tsession.streams.subscribe(id, query, qos);\n\n\tOk(())\n}\n\n/// Handles the unsubscribe message from the client.\n/// Those messages are always sent over TCP.\npub async fn unsubscribe(\n\tmessage: Bytes,\n\tsession: \u0026mut Session,\n) -\u003e anyhow::Result\u003c()\u003e {\n\tlet message = read_message(message.as_ref(), ReaderOptions::new())?;\n\tlet reader = message.get_root::\u003cinbound::Reader\u003e()?;\n\n\tlet Which::Unsubscribe(id) = reader.which()? else {\n\t\tanyhow::bail!(\"Expected an unsubscribe message\");\n\t};\n\n\ttracing::info!(\n\t\tsession = session.public_id,\n\t\t\"unsubscribing from query: {id}\"\n\t);\n\n\tsession.streams.unsubscribe(id);\n\n\tOk(())\n}\n\n/// Manages the query subscriptions of a connected session.\n///\n/// Clients register subscriptions to queries, which specify the data\n/// they are interested in receiving updates for. They also specify the\n/// interval at which they want to receive updates and the protocol to use\n/// for the updates (reliable or unreliable).\n///\n/// This struct manages the list of active subscriptions and is responsible\n/// for waking up the session event loop at the correct intervals to send\n/// updates to the client and for producing the updates.\npub struct Streams {\n\ttimer: Pin\u003cBox\u003cSleep\u003e\u003e,\n\tqueue: BinaryHeap\u003cSubscription\u003e,\n}\n\n#[derive(Debug)]\nstruct Subscription {\n\tid: SubscriptionId,\n\tquery: Arc\u003cQuery\u003e,\n\tnext_tick: Instant,\n\tqos: QoS,\n\n\t/// A queue of events that were sent to this player and are waiting\n\t/// to be sent to the client. This list will only have events that\n\t/// this subscription query is interested in.\n\tinbox: ArrayQueue\u003cArc\u003cEvent\u003e\u003e,\n}\n\nimpl Subscription {\n\t/// Returns true if this subscription is interested in receiving\n\t/// events about despawned objects that are relevant to it.\n\tpub fn accepts_despawns(\u0026self) -\u003e bool {\n\t\tself\n\t\t\t.query\n\t\t\t.events\n\t\t\t.accepts(SystemEvents::ObjectsDespawned as EventClass)\n\t}\n\n\t/// Returns true if this subscription is interested in receiving\n\t/// events about player disconnects that are relevant to it.\n\tpub fn accepts_disconnects(\u0026self) -\u003e bool {\n\t\tself\n\t\t\t.query\n\t\t\t.events\n\t\t\t.accepts(SystemEvents::PlayerDisconnected as EventClass)\n\t}\n}\n\nimpl PartialEq for Subscription {\n\tfn eq(\u0026self, other: \u0026Self) -\u003e bool {\n\t\tself.id == other.id\n\t\t\t\u0026\u0026 self.query.priority == other.query.priority\n\t\t\t\u0026\u0026 self.next_tick == other.next_tick\n\t\t\t\u0026\u0026 self.qos == other.qos\n\t}\n}\n\nimpl Eq for Subscription {}\n\nimpl Ord for Subscription {\n\tfn cmp(\u0026self, other: \u0026Self) -\u003e Ordering {\n\t\t// we want reverse ordering\n\t\tmatch self.next_tick.cmp(\u0026other.next_tick) {\n\t\t\tOrdering::Equal =\u003e self.query.priority.cmp(\u0026other.query.priority),\n\t\t\tOrdering::Greater =\u003e Ordering::Less,\n\t\t\tOrdering::Less =\u003e Ordering::Greater,\n\t\t}\n\t}\n}\n\nimpl PartialOrd for Subscription {\n\tfn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\n\t\tSome(self.cmp(other))\n\t}\n}\n\nimpl Default for Streams {\n\tfn default() -\u003e Self {\n\t\tSelf {\n\t\t\ttimer: Box::pin(sleep(Duration::MAX)),\n\t\t\tqueue: BinaryHeap::with_capacity(3),\n\t\t}\n\t}\n}\n\nimpl Streams {\n\t// todo: consider having an upper limit on the number of subscriptions\n\tpub fn subscribe(\u0026mut self, id: SubscriptionId, query: Query, qos: QoS) {\n\t\t// first remove any existing subscription with the same id\n\t\tself.queue.retain(|sub| sub.id != id);\n\n\t\tlet next_tick = Instant::now() + query.interval;\n\t\tself.queue.push(Subscription {\n\t\t\tid,\n\t\t\tqos,\n\t\t\tnext_tick,\n\t\t\tinbox: ArrayQueue::new(query.backlog),\n\t\t\tquery: Arc::new(query),\n\t\t});\n\n\t\tlet next_tick = self.queue.peek().unwrap().next_tick;\n\t\tself.timer.as_mut().reset(next_tick);\n\n\t\tmatch qos {\n\t\t\tQoS::Reliable =\u003e {\n\t\t\t\thistogram!(\"reliable_query_count\", self.queue.len() as f64);\n\t\t\t}\n\t\t\tQoS::Unreliable =\u003e {\n\t\t\t\thistogram!(\"unreliable_query_count\", self.queue.len() as f64);\n\t\t\t}\n\t\t}\n\t}\n\n\tpub fn unsubscribe(\u0026mut self, id: SubscriptionId) {\n\t\tself.queue.retain(|sub| sub.id != id);\n\t\tif let Some(next) = self.queue.peek() {\n\t\t\tself.timer.as_mut().reset(next.next_tick);\n\t\t} else {\n\t\t\tself.timer.as_mut().reset(Instant::now() + Duration::MAX);\n\t\t}\n\n\t\thistogram!(\n\t\t\t\"reliable_query_count\",\n\t\t\tself.queue.iter().filter(|s| s.qos == QoS::Reliable).count() as f64\n\t\t);\n\n\t\thistogram!(\n\t\t\t\"unreliable_query_count\",\n\t\t\tself\n\t\t\t\t.queue\n\t\t\t\t.iter()\n\t\t\t\t.filter(|s| s.qos == QoS::Unreliable)\n\t\t\t\t.count() as f64\n\t\t);\n\t}\n\n\t/// This is called whenever an event is emitted by some other entity\n\t/// and this current session is relevant to that sender. Here we will need\n\t/// to see if any of our subscriptions is interested in this event and if\n\t/// so we will need to add it to the subscription's inbox.\n\tpub fn try_receive_event(\u0026self, event: Arc\u003cEvent\u003e) {\n\t\tfor subscription in self.queue.iter() {\n\t\t\tif subscription.query.events.accepts(event.class) {\n\t\t\t\tlet _ = subscription.inbox.push(event.clone());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/// This is called whenever a relevant object is despawned. If any of\n\t/// the registered queries are interested in despawn events, we will\n\t/// need to notify one of them by adding the despawn event to its inbox.\n\tpub fn observes_despawns(\u0026self) -\u003e bool {\n\t\tself.queue.iter().any(|s| s.accepts_despawns())\n\t}\n\n\t/// This is called whenever a relevent player disconnects. If any of the\n\t/// registered queries are interested in player disconnect events, we will\n\t/// need to notify one of them by adding the disconnect event to its inbox.\n\tpub fn observes_disconnects(\u0026self) -\u003e bool {\n\t\tself.queue.iter().any(|s| s.accepts_disconnects())\n\t}\n}\n\nimpl Stream for Streams {\n\ttype Item = QueryTick;\n\n\tfn poll_next(\n\t\tmut self: Pin\u003c\u0026mut Self\u003e,\n\t\tcx: \u0026mut Context\u003c'_\u003e,\n\t) -\u003e Poll\u003cOption\u003cSelf::Item\u003e\u003e {\n\t\tif self.timer.as_mut().poll_unpin(cx).is_ready() {\n\t\t\tif let Some(mut subscription) = self.queue.pop() {\n\t\t\t\tif subscription.next_tick \u003c= Instant::now() {\n\t\t\t\t\t// reschedule this task\n\t\t\t\t\tsubscription.next_tick = Instant::now() + subscription.query.interval;\n\n\t\t\t\t\t// prepeate the query that is going to run on this tick\n\t\t\t\t\tlet mut this_tick = QueryTick {\n\t\t\t\t\t\tquery: Arc::clone(\u0026subscription.query),\n\t\t\t\t\t\tqos: subscription.qos,\n\t\t\t\t\t\tevents: Vec::with_capacity(subscription.inbox.len()),\n\t\t\t\t\t\tobserves_despawns: subscription.accepts_despawns(),\n\t\t\t\t\t\tobserves_disconnects: subscription.accepts_disconnects(),\n\t\t\t\t\t};\n\n\t\t\t\t\t// drain the events from the subscription inbox\n\t\t\t\t\twhile let Some(event) = subscription.inbox.pop() {\n\t\t\t\t\t\tthis_tick.events.push(event);\n\t\t\t\t\t}\n\n\t\t\t\t\tself.queue.push(subscription);\n\n\t\t\t\t\t// find the next tick stop\n\t\t\t\t\tlet next_tick = self.queue.peek().unwrap().next_tick;\n\t\t\t\t\tself.timer.as_mut().reset(next_tick);\n\n\t\t\t\t\t// we have a tick ready now\n\t\t\t\t\treturn Poll::Ready(Some(this_tick));\n\t\t\t\t} else {\n\t\t\t\t\t// we're too early, reschedule the task\n\t\t\t\t\tself.queue.push(subscription);\n\n\t\t\t\t\tlet next_tick = self.queue.peek().unwrap().next_tick;\n\t\t\t\t\tself.timer.as_mut().reset(next_tick);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// the queue is empty, sleep forever until a new\n\t\t\t\t// subscription is added and the timer is reset.\n\t\t\t\tself.timer.as_mut().reset(Instant::now() + Duration::MAX);\n\t\t\t}\n\t\t}\n\n\t\tPoll::Pending\n\t}\n}\n\n#[derive(Debug)]\npub struct QueryTick {\n\tquery: Arc\u003cQuery\u003e,\n\tqos: QoS,\n\tevents: Vec\u003cArc\u003cEvent\u003e\u003e,\n\tobserves_despawns: bool,\n\tobserves_disconnects: bool,\n}\n\nimpl QueryTick {\n\tpub async fn send(self, session: \u0026mut Session) -\u003e anyhow::Result\u003c()\u003e {\n\t\tlet relevant = session.query_relevant(self.query.radius);\n\n\t\t// find out which entities have new values that need to be sent\n\t\t// to the client. Then produce a set of packets that will be sent\n\t\t// until all updates are sent.\n\t\tlet mut update_set = calculate_update_set(\n\t\t\tsession,\n\t\t\t\u0026relevant,\n\t\t\t\u0026self\n\t\t\t\t.query\n\t\t\t\t.tags\n\t\t\t\t.iter()\n\t\t\t\t.map(|s| s.as_str())\n\t\t\t\t.collect::\u003cVec\u003c_\u003e\u003e(),\n\t\t);\n\n\t\tlet mut iters = 0;\n\t\tlet start = Instant::now();\n\t\tlet mut events = self.events;\n\n\t\tif self.observes_despawns {\n\t\t\tevents.extend(populate_despawns(take(\u0026mut session.despawns)));\n\t\t}\n\n\t\tif self.observes_disconnects {\n\t\t\tevents.extend(populate_disconnects(take(\u0026mut session.disconnects)));\n\t\t}\n\n\t\t// in case of unreliable updates we need to pack updates into MTU sized\n\t\t// UDP packets. Here we calculate the update set and send on each\n\t\t// iteration a portion of it until all updates are sent.\n\t\tloop {\n\t\t\t// nothing to send, we're done\n\t\t\tif update_set.is_empty() \u0026\u0026 events.is_empty() {\n\t\t\t\thistogram!(\"stream_query_tick_iterations_count\", iters as f64);\n\t\t\t\thistogram!(\n\t\t\t\t\t\"stream_query_tick_duration\",\n\t\t\t\t\tstart.elapsed().as_micros() as f64\n\t\t\t\t);\n\t\t\t\treturn Ok(());\n\t\t\t}\n\n\t\t\t// try to send the update set to the client and return the remaining\n\t\t\t// updates that didn't fit in the current iteration.\n\t\t\t(update_set, events) = match self.qos {\n\t\t\t\tQoS::Reliable =\u003e reliable::send(session, update_set, events).await?,\n\t\t\t\tQoS::Unreliable =\u003e {\n\t\t\t\t\tunreliable::send(session, update_set, events).await?\n\t\t\t\t}\n\t\t\t};\n\n\t\t\titers += 1;\n\t\t}\n\t}\n}\n","traces":[{"line":44,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":484},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":235},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":14829},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":14829},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":14829},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":14829},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":14829},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":14811},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":14811},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":14811},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":14811},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":14811},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":989},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":989},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":989},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":989},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":989},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":237},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":495},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":242},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":235},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":69},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":30820},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":30820},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":29612},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":14863},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":16014},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":29612},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":29996},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":29068},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":14262},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":29068},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":14262},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":30006},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":363},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":363},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":94,"coverable":130},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","session","tick.rs"],"content":"//! This modules handles messages of type \"Tick\"\n//! See inbound.capnp in the protocol for the definition of the Tick message.\n//!\n//! A Tick message is a message that is sent frequently by the client to the\n//! server usually every few milliseconds. It contains a list of updates to\n//! player's attributes. The server responds with a list of updates to\n//! attributes of other players that are relevant to the current player.\n//!\n//! All this processing happens on a critical hot path. Make sure to keep the\n//! code here as fast as possible. This is the main bottleneck of the server.\n//! A red flag should be raised if this code takes more than 100 microseconds\n//! to execute per 1000 online players.\n\nuse {\n\tsuper::{\n\t\tversions::{EntityVersions, VersionMap},\n\t\tSession,\n\t},\n\tcrate::{\n\t\tevents::Event,\n\t\tglobal::GlobalState,\n\t\tstate::{\n\t\t\tentity::{AttributeId, Entity, EntityChanges},\n\t\t\tobject::ObjectId,\n\t\t\tplayer::PlayerId,\n\t\t\trules,\n\t\t\tEntityId,\n\t\t},\n\t},\n\tarrayvec::ArrayVec,\n\tcapnp::struct_list,\n\tfutures::future::Either,\n\tmetrics::histogram,\n\tnum_traits::{Num, ToBytes},\n\tquark_client_sdk::{\n\t\tprotocol::{\n\t\t\tcommon::{object, player},\n\t\t\tevents::SystemEvents,\n\t\t\toutbound::event,\n\t\t},\n\t\tEventClass,\n\t\tOutboundEvent,\n\t\tTimestamp,\n\t},\n\trustc_hash::FxHashSet,\n\tstd::{collections::HashSet, sync::Arc},\n\ttracing::trace,\n};\n\npub type UpdateSet = Vec\u003c(EntityId, Vec\u003cAttributeId\u003e)\u003e;\n\n/// Updates attributes of the current player from the incoming tick message.\n/// Returns true if any new attributes were created, false if only updates\n/// happened.\npub fn update_player_state(\n\tplayer: player::Reader\u003c'_\u003e,\n\tsession: \u0026mut Session,\n) -\u003e anyhow::Result\u003c()\u003e {\n\tlet player_id = session.public_id;\n\tlet Some(player_obj) = session.global.players().get(\u0026player_id) else {\n\t\tanyhow::bail!(\"player object does not exist for an active session\") // the player disconnected\n\t};\n\n\tlet attributes = player.reborrow().get_attributes()?;\n\thistogram!(\"player_update_attributes_count\", attributes.len() as f64);\n\n\tlet changes = EntityChanges {\n\t\tattributes: player_obj.push_attributes(attributes),\n\t};\n\n\t// keep track of the latest versions of attributes that we\n\t// know that the client knows about, so that in future ticks we can send\n\t// only the attributes that have changed.\n\tsession\n\t\t.version_map\n\t\t.apply_changes(EntityId::Player(session.public_id), \u0026changes);\n\n\t// publish the changes to external all replication consumers\n\tsession.global.replicate().entity(\n\t\tEntityId::Player(session.public_id),\n\t\t\u0026changes,\n\t\t\u0026player_obj,\n\t\tplayer_id,\n\t);\n\n\t// Apply any object model rules that might have changed as a result of\n\t// this update.\n\trules::apply_post_update_rules(\n\t\t\u0026session.public_id,\n\t\t\u0026player_obj,\n\t\t\u0026changes,\n\t\t\u0026session.global,\n\t);\n\n\tOk(())\n}\n\n/// Updates attributes of all objects that the current player has authority\n/// over. The user has authority over object previously created by the current\n/// player, over objects that were orphaned by other players, and over new\n/// objects that were created just now in this update.\npub fn update_objects_state(\n\treader: struct_list::Reader\u003cobject::Owned\u003e,\n\tsession: \u0026mut Session,\n) -\u003e anyhow::Result\u003c()\u003e {\n\tlet objects_reader = reader;\n\tfor object_reader in objects_reader {\n\t\t// skip objects that have no data at all\n\t\tif object_reader.get_attributes()?.is_empty() {\n\t\t\tcontinue;\n\t\t}\n\n\t\thistogram!(\n\t\t\t\"object_update_attributes_count\",\n\t\t\tobject_reader.get_attributes()?.len() as f64\n\t\t);\n\n\t\t// try to apply changes to the object\n\t\t// and return the list of attributes that were modified\n\t\t// by this update\n\t\tlet object_id = object_reader.get_id();\n\t\tlet changes = match session.global.objects().upsert(session, object_reader)\n\t\t{\n\t\t\tOk(changes) =\u003e changes,\n\t\t\tErr(e) =\u003e {\n\t\t\t\ttrace!(\n\t\t\t\t\tsession = session.public_id,\n\t\t\t\t\t\"Failed to update object {object_id}: {e:?}\",\n\t\t\t\t);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t};\n\n\t\t// keep track of the latest versions of attributes that we\n\t\t// know that the client knows about, so that in future ticks we can send\n\t\t// only the attributes that have changed.\n\t\tsession\n\t\t\t.version_map\n\t\t\t.apply_changes(EntityId::Object(object_reader.get_id()), \u0026changes);\n\n\t\t// publish the changes to external all replication consumers,\n\t\t// only if the object exists or was created. We could have denied\n\t\t// the creation of the object, so check for that here.\n\t\tif let Some(obj) = \u0026session.global.objects().get(\u0026object_reader.get_id()) {\n\t\t\tsession.global.replicate().entity(\n\t\t\t\tEntityId::Object(object_reader.get_id()),\n\t\t\t\t\u0026changes,\n\t\t\t\tobj,\n\t\t\t\tsession.public_id,\n\t\t\t);\n\t\t}\n\t}\n\n\tOk(())\n}\n\n/// Identifies the exact set of attributes on all relevant entities that have\n/// changed since the last tick. It will exclude entities that have no updates\n/// at all.\npub fn calculate_update_set(\n\tsession: \u0026Session,\n\trelevant: \u0026FxHashSet\u003cEntityId\u003e,\n\ttags: \u0026[\u0026str],\n) -\u003e UpdateSet {\n\tlet global = \u0026session.global;\n\tlet version_map = \u0026session.version_map;\n\n\tlet mut update_set = Vec::with_capacity(relevant.len());\n\n\tfor entity_id in relevant.iter() {\n\t\tlet Some(entity_ref) = (match entity_id {\n\t\t\tEntityId::Player(id) =\u003e global.players().get(id).map(Either::Left),\n\t\t\tEntityId::Object(id) =\u003e global.objects().get(id).map(Either::Right),\n\t\t}) else {\n\t\t\tcontinue;\n\t\t};\n\n\t\tlet entity = match entity_ref {\n\t\t\tEither::Left(ref player) =\u003e player.value(),\n\t\t\tEither::Right(ref object) =\u003e object.value(),\n\t\t};\n\n\t\t// check if the request is filtering by tags\n\t\tif !tags.is_empty() {\n\t\t\tlet entity_tags = session.global.schema().spec_of(entity).tags();\n\n\t\t\t// skip this entity if it doesn't have any of the requested tags\n\t\t\tif !entity_tags.iter().any(|tag| tags.contains(\u0026tag.as_ref())) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// this player has seen this entity before, check if it has any updates\n\t\tlet new_attributes = match version_map.get(entity_id) {\n\t\t\tSome(versions) =\u003e entity.find_new_attributes(\u0026versions.attributes),\n\t\t\tNone =\u003e entity.find_new_attributes(\u0026Default::default()),\n\t\t};\n\n\t\tif !new_attributes.is_empty() {\n\t\t\tupdate_set.push((*entity_id, new_attributes));\n\t\t}\n\t}\n\n\tupdate_set\n}\n\npub fn build_players(\n\tplayers_builder: struct_list::Builder\u003cplayer::Owned\u003e,\n\tplayers_update_set: \u0026[\u0026(EntityId, Vec\u003cAttributeId\u003e)],\n\tversion_map: \u0026mut VersionMap,\n\tglobal: \u0026GlobalState,\n) {\n\tlet mut entity_index = 0;\n\tlet mut players_builder = players_builder;\n\tfor (entity_id, attributes) in players_update_set {\n\t\tlet EntityId::Player(player_id) = *entity_id else {\n\t\t\tcontinue;\n\t\t};\n\n\t\tif attributes.is_empty() {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet mut player_builder = players_builder.reborrow().get(entity_index);\n\t\tlet Some(player) = global.players().get(\u0026player_id) else {\n\t\t\tcontinue; // the player disconnected\n\t\t};\n\t\tplayer_builder.reborrow().set_id(player_id);\n\n\t\tlet mut attributes_builder = player_builder\n\t\t\t.reborrow()\n\t\t\t.init_attributes(attributes.len() as u32);\n\n\t\tlet complete = player.pull_attributes(\n\t\t\tattributes, //\n\t\t\t\u0026mut attributes_builder,\n\t\t);\n\n\t\tif complete {\n\t\t\t// complete means that we have wrote all the attributes\n\t\t\t// and didn't skip any because the collection grew in the mean time.\n\t\t\t// If the returned value is incomplete, then don't record it in the\n\t\t\t// cache so the clien won't miss any updates.\n\t\t\tupdate_remote_view(\n\t\t\t\t\u0026player,\n\t\t\t\tattributes,\n\t\t\t\tversion_map.entry(*entity_id).or_default(),\n\t\t\t);\n\t\t}\n\t\tentity_index += 1;\n\t}\n}\n\npub fn build_objects(\n\tobjects_builder: struct_list::Builder\u003cobject::Owned\u003e,\n\tobjects_update_set: \u0026[\u0026(EntityId, Vec\u003cAttributeId\u003e)],\n\tversion_map: \u0026mut VersionMap,\n\tglobal: \u0026GlobalState,\n) {\n\tlet mut object_index = 0;\n\tlet mut objects_builder = objects_builder;\n\n\tfor (entity_id, attributes) in objects_update_set {\n\t\tlet EntityId::Object(object_id) = *entity_id else {\n\t\t\tcontinue;\n\t\t};\n\n\t\tif attributes.is_empty() {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet mut object_builder = objects_builder.reborrow().get(object_index);\n\t\tobject_builder.reborrow().set_id(object_id);\n\t\tlet Some(object) = global.objects().get(\u0026object_id) else {\n\t\t\tcontinue; // the object was despawned\n\t\t};\n\n\t\tlet mut attributes_builder = object_builder\n\t\t\t.reborrow()\n\t\t\t.init_attributes(attributes.len() as u32);\n\n\t\tlet complete = object.pull_attributes(\n\t\t\tattributes, //\n\t\t\t\u0026mut attributes_builder,\n\t\t);\n\n\t\tif complete {\n\t\t\t// complete means that we have sent all attributes\n\t\t\t// and didn't skip any because the collection grew in the mean time.\n\t\t\t// If the returned value is incomplete, then don't record it in the\n\t\t\t// cache so the clien won't miss any updates.\n\t\t\tupdate_remote_view(\n\t\t\t\t\u0026object,\n\t\t\t\tattributes,\n\t\t\t\tversion_map.entry(*entity_id).or_default(),\n\t\t\t);\n\t\t}\n\n\t\tobject_index += 1;\n\t}\n}\n\npub fn build_events(\n\tevents_builder: struct_list::Builder\u003cevent::Owned\u003e,\n\tinbox: impl ExactSizeIterator\u003cItem = Arc\u003cEvent\u003e\u003e,\n) {\n\tlet mut events_builder = events_builder;\n\tfor (i, event) in inbox.enumerate() {\n\t\tlet mut event_builder = events_builder.reborrow().get(i as u32);\n\t\tevent_builder.set_class(event.class);\n\t\tevent_builder.set_payload(\u0026event.payload);\n\t\tmatch event.sender {\n\t\t\tEntityId::Player(id) =\u003e event_builder.init_sender().set_player(id),\n\t\t\tEntityId::Object(id) =\u003e event_builder.init_sender().set_object(id),\n\t\t};\n\t}\n}\n\npub fn populate_despawns(despawns: Vec\u003cObjectId\u003e) -\u003e Vec\u003cArc\u003cEvent\u003e\u003e {\n\tpopulate_deletes(despawns, SystemEvents::ObjectsDespawned)\n}\n\npub fn populate_disconnects(disconnects: Vec\u003cPlayerId\u003e) -\u003e Vec\u003cArc\u003cEvent\u003e\u003e {\n\tpopulate_deletes(disconnects, SystemEvents::PlayerDisconnected)\n}\n\nfn populate_deletes\u003cT: Num + ToBytes + Eq + std::hash::Hash\u003e(\n\tdeletes: Vec\u003cT\u003e,\n\tevent_class: SystemEvents,\n) -\u003e Vec\u003cArc\u003cEvent\u003e\u003e {\n\tif deletes.is_empty() {\n\t\treturn vec![];\n\t}\n\n\t// all despawned objects that this player was aware of need to be\n\t// packaed into ObjectsDespawned events and sent to the client.\n\t//\n\t// The ObjectsDespawned event takes a number of object ids as a payload.\n\t// We will batch all pending despawn notifications into as many messages as\n\t// we can fit into a single event.\n\tlet id_size = std::mem::size_of::\u003cT\u003e();\n\tlet event_payload_size = OutboundEvent::MAX_PAYLOAD_SIZE;\n\tlet items_per_event = event_payload_size.div_ceil(id_size);\n\n\tlet mut dedup = HashSet::new();\n\tlet mut events = Vec::with_capacity((deletes.len() / items_per_event).max(1));\n\tfor deletes_chunk in deletes.chunks(items_per_event) {\n\t\tlet mut event = Event {\n\t\t\tsender: EntityId::SYSTEM_PLAYER,\n\t\t\tclass: event_class as EventClass,\n\t\t\tpayload: ArrayVec::new(),\n\t\t\ttimestamp: Timestamp::default(),\n\t\t};\n\n\t\tfor id in deletes_chunk {\n\t\t\tif dedup.insert(id) {\n\t\t\t\tfor byte in id.to_le_bytes().as_ref() {\n\t\t\t\t\tevent.payload.push(*byte);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tevents.push(Arc::new(event));\n\t}\n\n\tevents\n}\n\n/// Records the latest versions of entities their attributes\n/// that we have sent the client so far in this session, so that in future ticks\n/// we can send only the attributes that have changed.\nfn update_remote_view(\n\tentity: \u0026Entity,\n\tattributes: \u0026[AttributeId],\n\tview: \u0026mut EntityVersions,\n) {\n\tfor attrib in attributes {\n\t\tif let Some(version) = entity.attributes().get_timestamp(*attrib) {\n\t\t\tview.attributes.insert(*attrib, version);\n\t\t}\n\t}\n}\n","traces":[{"line":55,"address":[],"length":0,"stats":{"Line":482},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":482},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":964},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":482},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":482},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":482},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":482},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":482},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":482},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":482},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":482},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":482},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":482},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":482},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":482},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":482},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":482},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":482},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":482},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":482},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":2090},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":804},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":804},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":804},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":801},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":1602},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":801},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":801},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":801},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":801},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":801},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":482},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":59093},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":88175},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":21961},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":22326},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":399},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":87776},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":21736},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":22152},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":299},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":569},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":187},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":87402},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":42723},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":978},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":1033},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":1033},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":14806},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":363},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":363},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":363},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":1041},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":339},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":339},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":339},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":339},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":339},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":339},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":339},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":339},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":363},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":363},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":363},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":1751},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":694},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":694},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":694},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":694},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":694},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":694},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":694},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":694},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":694},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":363},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":363},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":403},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":14262},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":14262},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":14262},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":14262},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":28524},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":28524},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":28503},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":75},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":427},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":200},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":1033},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":15503},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":14470},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":7235},"fn_name":null}],"covered":115,"coverable":127},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","session","unreliable.rs"],"content":"//! This module is responsible for managing the unreliable UDP channel\n\nuse {\n\tsuper::{\n\t\ttick::{build_objects, build_players, UpdateSet},\n\t\tSession,\n\t},\n\tcrate::{\n\t\tevents::{self, Event},\n\t\tsession::tick::{build_events, update_objects_state, update_player_state},\n\t\tstate::{\n\t\t\tentity::AttributeId,\n\t\t\tobject::ObjectId,\n\t\t\tplayer::PlayerId,\n\t\t\tEntityId,\n\t\t},\n\t},\n\tcapnp::{\n\t\tmessage::{ReaderOptions, ScratchSpaceHeapAllocator},\n\t\tserialize_packed::{read_message, write_message},\n\t},\n\tquark_client_sdk::{\n\t\tprotocol::{self, outbound::stream_world_update},\n\t\tEventClass,\n\t\tMTUBytes,\n\t\tPacket,\n\t\tMAX_SEQUENCE_LENGTH,\n\t},\n\tstd::{mem::size_of, net::SocketAddr, sync::Arc},\n\ttracing::trace,\n};\n\n/// Processes tick messages that come from the client through the unreliable UDP\n/// channel. Through this channel we are working at the packet level because a\n/// long message cannot be easily fragmented over multiple packets. Each packet\n/// should be a self contained message.\npub fn process(\n\tsession: \u0026mut Session,\n\tpacket: Box\u003cPacket\u003e,\n\tfrom: SocketAddr,\n) -\u003e anyhow::Result\u003c()\u003e {\n\t// keep track of the last known address of the client\n\tsession.remote_addr = from;\n\n\tif packet.payload().is_empty() {\n\t\treturn Ok(());\n\t}\n\n\tlet message = read_message(packet.payload(), ReaderOptions::new())?;\n\tlet reader = message.get_root::\u003cprotocol::inbound::stream_tick::Reader\u003e()?;\n\n\ttrace!(\n\t\tsession = session.public_id,\n\t\t\"udp stream tick received from {from}: {reader:?}\",\n\t);\n\n\tif let Err(e) = update_player_state(reader.get_player()?, session) {\n\t\ttracing::warn!(\"Failed to update player state: {e:?}\");\n\t}\n\n\tif let Err(e) = update_objects_state(reader.get_objects()?, session) {\n\t\ttracing::warn!(\"Failed to update objects state: {e:?}\");\n\t}\n\n\tif let Err(e) = events::process(reader.get_events()?, session) {\n\t\ttracing::warn!(\"Failed to process events: {e:?}\");\n\t}\n\n\tOk(())\n}\n\ntype EntityChanges = Vec\u003c(EntityId, Vec\u003cu16\u003e)\u003e;\n\n/// Sends a portion of the update set and events to the client over one UDP.\n/// The function will return the remaining changes that didn't fit in the\n/// packet.\n///\n/// This function will be called in a loop by the `streams::QueryTick::send`\n/// function until all changes are sent and there is nothing remaining.\npub async fn send(\n\tsession: \u0026mut Session,\n\tupdate_set: Vec\u003c(quark_client_sdk::EntityId, Vec\u003cu16\u003e)\u003e,\n\tevents: Vec\u003cArc\u003cEvent\u003e\u003e,\n) -\u003e anyhow::Result\u003c(UpdateSet, Vec\u003cArc\u003cEvent\u003e\u003e)\u003e {\n\tlet mut events = events;\n\n\t// if we have no more changes to send, we can break the loop\n\t// otherwise produce a new packet for each batch of changes\n\t// that we can manage to fit in a packet.\n\tif update_set.is_empty() \u0026\u0026 events.is_empty() {\n\t\treturn Ok((UpdateSet::default(), vec![]));\n\t}\n\n\tlet (mut players_update_set, mut objects_update_set) = update_set\n\t\t.into_iter()\n\t\t.partition(|entity| matches!(entity, (EntityId::Player(_), _)));\n\n\tlet packet = {\n\t\tlet mut scratch = MTUBytes::default();\n\t\tlet mut message = capnp::message::Builder::new(\n\t\t\tScratchSpaceHeapAllocator::new(scratch.as_mut()),\n\t\t);\n\n\t\tlet mut batch = Vec::new();\n\t\tlet mut tick_builder = message.init_root::\u003cstream_world_update::Builder\u003e();\n\t\tlet max_attribs = approximate_max_attribs(\u0026tick_builder);\n\n\t\t// drain as many player changes as we can fit in a packet.\n\t\tbatch.extend(drain_changes(\u0026mut players_update_set, max_attribs));\n\n\t\t// find out how many attributes we have drained so far.\n\t\tlet attribs_so_far = batch\n\t\t\t.iter()\n\t\t\t.map(|(_, attribs)| attribs.len())\n\t\t\t.sum::\u003cusize\u003e();\n\n\t\t// check if we still have space for more attributes from objects\n\t\tlet max_attribs = max_attribs.saturating_sub(attribs_so_far);\n\t\tbatch.extend(drain_changes(\u0026mut objects_update_set, max_attribs));\n\n\t\tlet players: Vec\u003c_\u003e = batch\n\t\t\t.iter()\n\t\t\t.filter(|(entity, _)| entity.is_player())\n\t\t\t.collect();\n\n\t\tlet objects: Vec\u003c_\u003e = batch\n\t\t\t.iter()\n\t\t\t.filter(|(entity, _)| entity.is_object())\n\t\t\t.collect();\n\n\t\tbuild_players(\n\t\t\ttick_builder.reborrow().init_players(players.len() as u32),\n\t\t\t\u0026players,\n\t\t\t\u0026mut session.version_map,\n\t\t\t\u0026session.global,\n\t\t);\n\n\t\tbuild_objects(\n\t\t\ttick_builder.reborrow().init_objects(objects.len() as u32),\n\t\t\t\u0026objects,\n\t\t\t\u0026mut session.version_map,\n\t\t\t\u0026session.global,\n\t\t);\n\n\t\t// Calculate the maximum number of events that can fit in the remaining\n\t\t// space in this tick message. Then remove them from the remaining events\n\t\t// list.\n\t\tlet events_count = approximate_max_events(\u0026tick_builder, \u0026events);\n\n\t\tbuild_events(\n\t\t\ttick_builder.reborrow().init_events(events_count as u32),\n\t\t\tevents.drain(0..events_count),\n\t\t);\n\n\t\ttrace!(\n\t\t\tsession = session.public_id,\n\t\t\t\"sending UDP stream tick: {:?}\",\n\t\t\ttick_builder.into_reader()\n\t\t);\n\n\t\tbuild_packet(session.public_id, message)\n\t};\n\n\tsession\n\t\t.global\n\t\t.udp()\n\t\t.send_to(packet.as_bytes(), session.remote_addr)\n\t\t.await?;\n\n\t// we have more changes to send, so we need to produce\n\t// more packets to satisfy this query.\n\tOk((\n\t\tplayers_update_set\n\t\t\t.into_iter()\n\t\t\t.chain(objects_update_set)\n\t\t\t.collect(),\n\t\tevents,\n\t))\n}\n\nconst MAX_PAYLOAD_SIZE: usize = MTUBytes::SIZE;\n// This value was measured by trying the most pessimistic scenario for\n// the structure of the data that contains the most overhead, and that\n// is when we have large attributes with uncompressable values, each\n// attribute belonging to a different object.\nconst MIN_FREE_SPACE: usize = 384;\nconst MAX_WRITE_OFFSET: usize = MAX_PAYLOAD_SIZE - MIN_FREE_SPACE;\n\n/// Returns the maximum number of attributes that can be packed into a\n/// tick message. This is a rough approximation based on the current\n/// tick builder size and the maximum size of a packet.\n///\n/// This function takes into account the most pessimitic scenario where\n/// each attribute is the maximum size possible, each attribute belongs\n/// to a different object.\nfn approximate_max_attribs(builder: \u0026stream_world_update::Builder) -\u003e usize {\n\tlet words = builder.total_size().unwrap().word_count;\n\tlet current_size = words as usize * size_of::\u003ccapnp::Word\u003e();\n\n\tlet remaining_space = MAX_WRITE_OFFSET - current_size;\n\tlet max_attribute_size =\n\t\tsize_of::\u003cAttributeId\u003e() + MAX_SEQUENCE_LENGTH + size_of::\u003cObjectId\u003e() + 1;\n\tremaining_space / max_attribute_size\n}\n\n/// Returns the maximum number of events we can pack into the remaining\n/// space of a tick message in the order they are given in the second argument.\nfn approximate_max_events(\n\tbuilder: \u0026stream_world_update::Builder,\n\tevents: \u0026[Arc\u003cEvent\u003e],\n) -\u003e usize {\n\tlet words = builder.total_size().unwrap().word_count;\n\tlet current_size = words as usize * size_of::\u003ccapnp::Word\u003e();\n\n\tlet mut events_count = 0;\n\tlet mut remaining_space = MAX_WRITE_OFFSET - current_size;\n\n\tfor event in events {\n\t\tlet event_size = size_of::\u003cEventClass\u003e()\n\t\t\t+ size_of::\u003cEntityId\u003e()\n\t\t\t+ event.payload.len()\n\t\t\t+ size_of::\u003cusize\u003e();\n\n\t\tif event_size \u003e remaining_space {\n\t\t\treturn events_count;\n\t\t}\n\n\t\tevents_count += 1;\n\t\tremaining_space -= event_size;\n\t}\n\n\tevents_count\n}\n\n/// Given a list of attribute changes groupped by their entity id, this function\n/// will take as many changes as possible to fill a packet and return the\n/// remaining changes that didn't fit in the packet.\nfn drain_changes(\n\tremaining: \u0026mut EntityChanges,\n\tmax_attributes: usize,\n) -\u003e EntityChanges {\n\tlet mut drained = Vec::new();\n\tlet mut remaining_attribs = max_attributes;\n\n\twhile let Some((entity, mut attribs)) = remaining.pop() {\n\t\tlet attrib_count = attribs.len().min(remaining_attribs);\n\t\tdrained.push((entity, attribs.drain(0..attrib_count).collect::\u003cVec\u003c_\u003e\u003e()));\n\t\tremaining_attribs -= attrib_count;\n\n\t\tif !attribs.is_empty() {\n\t\t\tremaining.push((entity, attribs));\n\t\t}\n\n\t\t// if we've reached our max attribs count or there are no more\n\t\t// attributes to process, we can stop processing\n\t\tif remaining_attribs == 0 || remaining.is_empty() {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdrained\n}\n\n/// Composes a final UDP packet from the given capnp message builder.\n/// The returned packet is ready to be sent over the wire.\nfn build_packet(\n\tplayer_id: PlayerId,\n\tbuilder: capnp::message::Builder\u003cScratchSpaceHeapAllocator\u003e,\n) -\u003e Packet {\n\tlet mut packet = Packet::new(player_id);\n\tlet mut cursor = packet.cursor();\n\twrite_message(\u0026mut cursor, \u0026builder)\n\t\t.expect(\"failed to serialize message to packet buffer\");\n\tlet position = cursor.position() as usize;\n\tpacket.header_mut().advance_cursor(position);\n\tpacket\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":246},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":246},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":246},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":212},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":212},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":424},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":424},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":424},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":212},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":10,"coverable":66},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","session","versions.rs"],"content":"use {\n\tcrate::state::{\n\t\tentity::{AttributeChange, AttributeId, EntityChanges},\n\t\tEntityId,\n\t\tTimestamp,\n\t},\n\trustc_hash::FxHashMap,\n\tstd::ops::{Deref, DerefMut},\n};\n\npub type AttributesVersionMap = FxHashMap\u003cAttributeId, Timestamp\u003e;\n\n#[derive(Debug, Default)]\npub struct EntityVersions {\n\tpub attributes: AttributesVersionMap,\n}\n\n#[derive(Debug, Default)]\npub struct VersionMap(FxHashMap\u003cEntityId, EntityVersions\u003e);\n\nimpl AsRef\u003cFxHashMap\u003cEntityId, EntityVersions\u003e\u003e for VersionMap {\n\tfn as_ref(\u0026self) -\u003e \u0026FxHashMap\u003cEntityId, EntityVersions\u003e {\n\t\t\u0026self.0\n\t}\n}\n\nimpl Deref for VersionMap {\n\ttype Target = FxHashMap\u003cEntityId, EntityVersions\u003e;\n\n\tfn deref(\u0026self) -\u003e \u0026Self::Target {\n\t\t\u0026self.0\n\t}\n}\n\nimpl DerefMut for VersionMap {\n\tfn deref_mut(\u0026mut self) -\u003e \u0026mut Self::Target {\n\t\t\u0026mut self.0\n\t}\n}\n\nimpl VersionMap {\n\tpub fn apply_changes(\n\t\t\u0026mut self,\n\t\tentity_id: EntityId,\n\t\tchanges: \u0026EntityChanges,\n\t) {\n\t\tlet entity = self.0.entry(entity_id).or_default();\n\t\tfor (key, change) in \u0026changes.attributes {\n\t\t\tmatch change {\n\t\t\t\tAttributeChange::None =\u003e {}\n\t\t\t\tAttributeChange::Created(version) =\u003e {\n\t\t\t\t\tentity.attributes.insert(*key, *version);\n\t\t\t\t}\n\t\t\t\tAttributeChange::Updated(version) =\u003e {\n\t\t\t\t\t// update the version of an existing attribute\n\t\t\t\t\tentity.attributes.insert(*key, *version);\n\t\t\t\t}\n\t\t\t\tAttributeChange::Deleted =\u003e {\n\t\t\t\t\tentity.attributes.remove(key);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":43701},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":43701},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":1071},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1071},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1283},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":1283},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":15077},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":6859},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":6859},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":13,"coverable":16},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","state","entity.rs"],"content":"use {\n\tsuper::{EntityId, Timestamp, TimestampedVal},\n\tcrate::{schema::ClassId, session::versions::AttributesVersionMap},\n\tarrayvec::ArrayVec,\n\tcapnp::struct_list,\n\tcrossbeam::atomic::AtomicConsume,\n\tmetrics::atomics::AtomicU64,\n\tparking_lot::RwLock,\n\tquark_client_sdk::{\n\t\tprotocol::attributes::attribute,\n\t\tValue,\n\t\tWellKnownAttribute,\n\t},\n\trustc_hash::FxHashMap,\n\tstd::{\n\t\tcell::UnsafeCell,\n\t\tfmt::Debug,\n\t\tsync::atomic::{AtomicUsize, Ordering},\n\t},\n\tthiserror::Error,\n\ttracing::{trace, warn},\n};\n\n/// Represents the result of attribute set operation.\n#[derive(Debug, Copy, Clone, PartialEq, Eq)]\npub enum AttributeChange {\n\t/// Nothing has changed.\n\t///\n\t/// An attribute with the same key and value already exists\n\t/// and has the same value as the update.\n\tNone,\n\n\t/// An existing attribute value was set to none.\n\tDeleted,\n\n\t/// An existing attribute was updated with the timestamp.\n\tUpdated(Timestamp),\n\n\t/// A new attribute was created with the timestamp\n\tCreated(Timestamp),\n}\n\npub type AttributesSetChanges = FxHashMap\u003cAttributeId, AttributeChange\u003e;\npub type AttributesMap =\n\tElementsMap\u003cAttributeId, AttributeValue, MAX_ATTRIBUTES\u003e;\n\n/// This type describes what has changed to an entity after a tick update is\n/// applied to it. It is used in few places:\n/// - When sending a tick update to a client, we only send the attributes that\n///   have changed since the last update. So we need to keep track of what has\n///   changed to maintain a per-session version map.\n/// - When replicating an entity to another node, we use this data to create a\n///   list of changes to send to the other node.\n/// - When an entity gets new attributes that were not present before, we need\n///   to check if that makes it eligible to be indexed by any of the relevancy\n///   indexes.\n#[derive(Debug, Default)]\npub struct EntityChanges {\n\tpub attributes: AttributesSetChanges,\n}\n\n/// A cell that can be written to and read from concurrently.\n///\n/// Internally it has two buffers, one for reading and another for writing,\n/// which are swapped when the cell is written to.\n///\n/// Reads are lock-free and wait-free.\n/// There can be multiple readers at the same time and only one writer.\n///\n/// This data structures sacrifices individual read performance as it\n/// always returns a copy of the data, but it optimizes for lock free\n/// access to the most up to date version of the data\npub struct ConcurrentCell\u003cT: Clone + PartialEq\u003e {\n\tback: RwLock\u003c()\u003e,\n\tbuffers: [UnsafeCell\u003cT\u003e; 2],\n\tfront: AtomicUsize,\n\ttimestamp: AtomicU64,\n}\n\nunsafe impl\u003cT: Send + Clone + PartialEq\u003e Send for ConcurrentCell\u003cT\u003e {}\nunsafe impl\u003cT: Sync + Clone + PartialEq\u003e Sync for ConcurrentCell\u003cT\u003e {}\n\nimpl\u003cT: Clone + Default + PartialEq\u003e Default for ConcurrentCell\u003cT\u003e {\n\tfn default() -\u003e Self {\n\t\tSelf::new_with_timestamp(T::default(), 0)\n\t}\n}\n\nimpl\u003cT: PartialEq + Clone + PartialEq\u003e PartialEq for ConcurrentCell\u003cT\u003e {\n\tfn eq(\u0026self, other: \u0026Self) -\u003e bool {\n\t\tself.get() == other.get()\n\t}\n}\n\nimpl\u003cT: Clone + Debug + PartialEq\u003e Debug for ConcurrentCell\u003cT\u003e {\n\tfn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n\t\tf.debug_struct(\"ConcurrentCell\")\n\t\t\t.field(\"value\", \u0026self.get())\n\t\t\t.field(\"timestamp\", \u0026self.timestamp())\n\t\t\t.finish()\n\t}\n}\n\nimpl\u003cT: Clone + PartialEq\u003e ConcurrentCell\u003cT\u003e {\n\t/// Creates a new instance of the cell with a given initial value and\n\t/// timestamp 1.\n\t#[cfg(test)]\n\tpub fn new(value: T) -\u003e Self {\n\t\tSelf::new_with_timestamp(value, 1)\n\t}\n\n\t/// Creates a new instance of the cell with a given initial value and\n\t/// timestamp.\n\tpub fn new_with_timestamp(value: T, timestamp: Timestamp) -\u003e Self {\n\t\tlet back = RwLock::new(());\n\t\tlet buffers = [UnsafeCell::new(value.clone()), UnsafeCell::new(value)];\n\n\t\tSelf {\n\t\t\tback,\n\t\t\tbuffers,\n\t\t\tfront: AtomicUsize::new(0),\n\t\t\ttimestamp: AtomicU64::new(timestamp),\n\t\t}\n\t}\n\n\t/// Returns a the most up to date state stored in the cell that is available\n\t/// for reading. This operation is lock-free and wait-free.\n\tpub fn get(\u0026self) -\u003e T {\n\t\t// SAFETY: The the inactive buffer is only writte to by the `set` method.\n\t\t// The `set` method locks the `back` field, which guarantees that the\n\t\t// there is only one writer at a time, and that is where the inactive\n\t\t// buffer is written to. Under no circumstances is the inactive buffer\n\t\t// is read from while it is being written to.\n\t\tunsafe { \u0026*self.buffers[self.front.load_consume()].get() }.clone()\n\t}\n\n\t/// Returns the timestamp of the cell.\n\t///\n\t/// This value gets incremented with every write to the cell.\n\tpub fn timestamp(\u0026self) -\u003e Timestamp {\n\t\tself.timestamp.load_consume()\n\t}\n\n\t/// Sets the value of the cell.\n\t///\n\t/// This will write the value to the\n\tpub fn set(\u0026self, value: T, timestamp: Timestamp) -\u003e bool {\n\t\tif self.timestamp() \u003e= timestamp {\n\t\t\treturn false;\n\t\t}\n\t\tlet current_value =\n\t\t\tunsafe { \u0026*self.buffers[self.front.load_consume()].get() };\n\n\t\t// don't update the timestamp if the value didn't change\n\t\tif value == *current_value {\n\t\t\treturn false;\n\t\t}\n\n\t\tlet _set_guard = self.back.write();\n\n\t\t// The inactive buffer is the one that is not being read from at the\n\t\t// moment. It is guaranteed that there will be only one writer at a time,\n\t\t// and that is where the inactive buffer is written to.\n\t\tlet inactive = if self.front.load_consume() == 0 { 1 } else { 0 };\n\n\t\t// SAFETY: The inactive buffer is only written to by the `set` method.\n\t\t// The `set` method locks the `back` field, which guarantees that the\n\t\t// there is only one writer at a time, and that is where the inactive\n\t\t// buffer is written to. Under no circumstances is the inactive buffer\n\t\t// is read from while it is being written to.\n\t\t//\n\t\t// At any time .get() is called, the front buffer is guaranteed to be\n\t\t// in a consistent state.\n\t\tunsafe { *self.buffers[inactive].get() = value };\n\n\t\tself.front.store(inactive, Ordering::Release);\n\t\tself.timestamp.store(timestamp, Ordering::SeqCst);\n\t\ttrue\n\t}\n}\n/// This is the maximum number of attributes allowed on one entity.\n///\n/// This is a hard limit because we use a fixed size array to store\n/// the attributes and we want to avoid dynamic allocations. Values\n/// that are stored as attributes should all have fixed-size inline\n/// storage.\n///\n/// Right now an attribute value supports string and bytes types as well\n/// as other types. Strings are bytes are stored inline, so when deciding\n/// this value we need to take into account the maximum length of a string\n/// or bytes value. and multiply it by the maximum capacity of the state.\npub const MAX_ATTRIBUTES: usize = 128;\n\n/// Used to uniquely identify an attribute type on a entity\npub type AttributeId = u16;\n\n/// Represents a single attribute on a entity.\n///\n/// Attributes are the smallest unit of storage in the state.\n///\n/// Attributes are always sorted by their key when they appear\n/// in the state. This is to allow fast lookup using binary search in\n/// fixed-allocation arrays.\npub type AttributeValue = ConcurrentCell\u003cValue\u003e;\n\n/// This type implements a collection of elements with fixed-sized static\n/// storage. It is used to store attributes.\n///\n/// It is optimized for fast lookup, iteration and access individual elements,\n/// and sacrifices the performance of adding and removing elements.\n///\n/// It is designed based on the observation that it is orders of magnitude\n/// more common to update exiting attributes that adding new\n/// ones or removing existing ones. Usually games will push the initial state\n/// of all fields at the beginning of an update of an entity and then just\n/// modify them in place. Adding new attributes is rare\n/// operation in comparision.\n///\n/// Attributes are always identified by their ids which are not\n/// neccessarily their positions in the internal storage.\n///\n/// Modifying existing elements of this collection relies on their own\n/// interior mutability.\npub struct ElementsMap\u003c\n\tK: Ord + Debug,\n\tV: Default + Debug,\n\tconst CAPACITY: usize,\n\u003e {\n\telements: UnsafeCell\u003cArrayVec\u003c(K, V), CAPACITY\u003e\u003e,\n\tlock: RwLock\u003c()\u003e,\n}\n\nunsafe impl\u003cK: Ord + Debug + Sync, V: Default + Debug + Sync, const CAPACITY: usize\u003e\n\tSync for ElementsMap\u003cK, V, CAPACITY\u003e\n{\n}\n\nimpl\u003cK: Ord + Clone + Debug, V: Default + Debug, const CAPACITY: usize\u003e Debug\n\tfor ElementsMap\u003cK, V, CAPACITY\u003e\n{\n\tfn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n\t\tf.debug_struct(\"ElementsMap\")\n\t\t\t.field(\"elements\", \u0026self.elements)\n\t\t\t.finish()\n\t}\n}\n\nimpl\u003cK: Ord + Debug, V: Default + Debug, const CAPACITY: usize\u003e Default\n\tfor ElementsMap\u003cK, V, CAPACITY\u003e\n{\n\tfn default() -\u003e Self {\n\t\tSelf {\n\t\t\telements: UnsafeCell::new(ArrayVec::new()),\n\t\t\tlock: RwLock::new(()),\n\t\t}\n\t}\n}\n\n/// This equality comparision is only here for unit tests.\n/// it should NEVER be used in actual product code.\n#[cfg(test)]\nimpl\u003c\n\t\tK: Ord + Clone + PartialEq + Debug,\n\t\tV: Default + PartialEq + Debug,\n\t\tconst CAPACITY: usize,\n\t\u003e PartialEq for ElementsMap\u003cK, V, CAPACITY\u003e\n{\n\tfn eq(\u0026self, other: \u0026Self) -\u003e bool {\n\t\tunsafe {\n\t\t\t// SAFETY: This is enable only in unit tests\n\t\t\tlet this_elements = \u0026*self.elements.get() as \u0026ArrayVec\u003c(K, V), CAPACITY\u003e;\n\t\t\tlet other_elements =\n\t\t\t\t\u0026*other.elements.get() as \u0026ArrayVec\u003c(K, V), CAPACITY\u003e;\n\t\t\tthis_elements.as_slice() == other_elements.as_slice()\n\t\t}\n\t}\n}\n\nimpl\u003c\n\t\tK: Ord + Debug + Copy,\n\t\tV: Clone + PartialEq + Default + Debug,\n\t\tconst CAPACITY: usize,\n\t\u003e ElementsMap\u003cK, ConcurrentCell\u003cV\u003e, CAPACITY\u003e\n{\n\t/// Assigns new value to an attribute.\n\t///\n\t/// Three things could happen:\n\t/// - If the attribute does not exist, it is created with the new value.\n\t/// - If the attribute exists and the new value is different from the old\n\t///   value, and new timestamp is greater than existing, the attribute is\n\t///   updated .\n\t/// - If the attribute exists and the new value is the same as the old value,\n\t///   or the given timestamp is lower or equal to the existing, the attribute\n\t///   is not updated.\n\tpub fn try_set(\n\t\t\u0026self,\n\t\tkey: K,\n\t\tvalue: V,\n\t\ttimestamp: Timestamp,\n\t) -\u003e Result\u003cAttributeChange, Error\u003e {\n\t\tlet (updated, created) = self.access(key, |v| v.set(value, timestamp))?;\n\n\t\tif created {\n\t\t\tOk(AttributeChange::Created(timestamp))\n\t\t} else if updated {\n\t\t\tOk(AttributeChange::Updated(timestamp))\n\t\t} else {\n\t\t\tOk(AttributeChange::None)\n\t\t}\n\t}\n}\n\nimpl\u003cK: Ord + Debug + Copy, V: Default + Debug, const CAPACITY: usize\u003e\n\tElementsMap\u003cK, V, CAPACITY\u003e\n{\n\tfn elements(\u0026self) -\u003e \u0026ArrayVec\u003c(K, V), CAPACITY\u003e {\n\t\t// SAFETY: any access that changes the length of the array\n\t\t// is guarded by the lock.\n\t\tunsafe { \u0026*self.elements.get() as \u0026ArrayVec\u003c(K, V), CAPACITY\u003e }\n\t}\n\n\t/// Retreives an element by its id.\n\t/// Returns None if the element does not exist.\n\tpub fn try_access\u003cR\u003e(\u0026self, key: K, op: impl FnOnce(\u0026V) -\u003e R) -\u003e Option\u003cR\u003e {\n\t\tlet _guard = self.lock.read();\n\t\tself\n\t\t\t.elements()\n\t\t\t.binary_search_by_key(\u0026key, |(k, _)| *k)\n\t\t\t.map(|ix| op(\u0026self.elements()[ix].1))\n\t\t\t.ok()\n\t}\n\n\t/// Invoked op on an elemenet. If the element does not exists\n\t/// it is created with a default value and then Op is invoked on it.\n\t///\n\t/// Returns the output of Op on the element and boolean that\n\t/// indicates if it was an existing element (false) or a new one (true).\n\tpub fn access\u003cR\u003e(\n\t\t\u0026self,\n\t\tkey: K,\n\t\top: impl FnOnce(\u0026V) -\u003e R,\n\t) -\u003e Result\u003c(R, bool), Error\u003e {\n\t\tlet guard = self.lock.read();\n\t\tif let Ok(index) = self.elements().binary_search_by_key(\u0026key, |(k, _)| *k) {\n\t\t\tOk((op(\u0026self.elements()[index].1), false))\n\t\t} else {\n\t\t\tdrop(guard);\n\t\t\tself.push(key, Default::default())?;\n\t\t\tOk((self.try_access(key, op).expect(\"just inserted\"), true))\n\t\t}\n\t}\n\n\t/// Iterates over all elements in the collection.\n\tpub fn iter(\u0026self, mut op: impl FnMut(\u0026K, \u0026V)) {\n\t\tlet _guard = self.lock.read();\n\n\t\tfor (k, v) in self.elements().iter() {\n\t\t\top(k, v);\n\t\t}\n\t}\n\n\t/// Inserts an element into the collection.\n\tpub fn push(\u0026self, key: K, value: V) -\u003e Result\u003c(), Error\u003e {\n\t\tlet _guard = self.lock.write();\n\t\tif self.elements().capacity() == self.elements().len() {\n\t\t\treturn Err(Error::StateIsFull(self.elements().capacity()));\n\t\t}\n\n\t\t// SAFETY: concurrent writes are guarded by the lock\n\t\tlet elements_mut =\n\t\t\tunsafe { \u0026mut *self.elements.get() as \u0026mut ArrayVec\u003c(K, V), CAPACITY\u003e };\n\n\t\telements_mut.push((key, value));\n\t\telements_mut.sort_by_key(|(k, _)| *k);\n\t\tOk(())\n\t}\n\n\t/// Checks if an element with a given id exists in the collection.\n\tpub fn contains_key(\u0026self, key: K) -\u003e bool {\n\t\tlet _guard = self.lock.read();\n\t\tself\n\t\t\t.elements()\n\t\t\t.binary_search_by_key(\u0026key, |(k, _)| *k)\n\t\t\t.is_ok()\n\t}\n\n\t/// Removes an element from the collection by its id.\n\tpub fn _remove(\u0026self, key: \u0026K) {\n\t\tlet _guard = self.lock.write();\n\n\t\tlet index = match self.elements().binary_search_by_key(\u0026key, |(k, _)| k) {\n\t\t\tOk(index) =\u003e index,\n\t\t\tErr(_) =\u003e return, // not here, do nothing\n\t\t};\n\n\t\t// SAFETY: concurrent writes are guarded by the lock\n\t\tlet elements_mut =\n\t\t\tunsafe { \u0026mut *self.elements.get() as \u0026mut ArrayVec\u003c(K, V), CAPACITY\u003e };\n\n\t\telements_mut.remove(index);\n\t}\n}\n\nimpl\u003cK: Ord + Debug + Copy, const CAPACITY: usize\u003e\n\tElementsMap\u003cK, ConcurrentCell\u003cValue\u003e, CAPACITY\u003e\n{\n\t/// Retreives an element by its id.\n\tpub fn get(\u0026self, key: K) -\u003e Option\u003cValue\u003e {\n\t\tself.try_access(key, |v| v.get())\n\t}\n\n\tpub fn get_with_timestamp(\u0026self, key: K) -\u003e Option\u003cTimestampedVal\u003e {\n\t\tself.try_access(key, |v| (v.get(), v.timestamp()).into())\n\t}\n\n\tpub fn get_timestamp(\u0026self, key: K) -\u003e Option\u003cTimestamp\u003e {\n\t\tself.try_access(key, |v| v.timestamp())\n\t}\n}\n\npub struct Entity {\n\tid: EntityId,\n\tattributes: ElementsMap\u003cAttributeId, AttributeValue, MAX_ATTRIBUTES\u003e,\n}\n\nimpl Debug for Entity {\n\tfn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n\t\tf.debug_struct(\"Entity\")\n\t\t\t.field(\"id\", \u0026self.id)\n\t\t\t.field(\n\t\t\t\t\"attributes\",\n\t\t\t\t\u0026self\n\t\t\t\t\t.attributes\n\t\t\t\t\t.elements()\n\t\t\t\t\t.into_iter()\n\t\t\t\t\t.filter_map(|(k, v)| if *k == 0 { None } else { Some((k, v.get())) })\n\t\t\t\t\t.collect::\u003cVec\u003c_\u003e\u003e(),\n\t\t\t)\n\t\t\t.finish()\n\t}\n}\n\nimpl Clone for Entity {\n\tfn clone(\u0026self) -\u003e Self {\n\t\tlet clone = Self::new(self.id);\n\t\tself.attributes.iter(|key, value| {\n\t\t\tlet _ = clone\n\t\t\t\t.attributes\n\t\t\t\t.try_set(*key, value.get(), value.timestamp());\n\t\t});\n\t\tclone\n\t}\n}\n\nunsafe impl Send for Entity {}\nunsafe impl Sync for Entity {}\n\nimpl Entity {\n\tpub fn new(id: EntityId) -\u003e Self {\n\t\tSelf {\n\t\t\tid,\n\t\t\tattributes: ElementsMap::default(),\n\t\t}\n\t}\n\n\tpub const fn id(\u0026self) -\u003e \u0026EntityId {\n\t\t\u0026self.id\n\t}\n\n\tpub fn attributes(\u0026self) -\u003e \u0026AttributesMap {\n\t\t\u0026self.attributes\n\t}\n\n\tpub fn class_id(\u0026self) -\u003e Option\u003cClassId\u003e {\n\t\tself\n\t\t\t.attributes()\n\t\t\t.get(WellKnownAttribute::ClassId as AttributeId)\n\t\t\t.and_then(|value| match value {\n\t\t\t\tValue::Int8(class_id) =\u003e Some(class_id as ClassId),\n\t\t\t\tValue::Int16(class_id) =\u003e Some(class_id as ClassId),\n\t\t\t\tValue::Int32(class_id) =\u003e Some(class_id as ClassId),\n\t\t\t\tValue::Int64(class_id) =\u003e Some(class_id as ClassId),\n\t\t\t\tValue::Uint8(class_id) =\u003e Some(class_id as ClassId),\n\t\t\t\tValue::Uint16(class_id) =\u003e Some(class_id as ClassId),\n\t\t\t\tValue::Uint32(class_id) =\u003e Some(class_id as ClassId),\n\t\t\t\tValue::Uint64(class_id) =\u003e Some(class_id),\n\t\t\t\t_ =\u003e None,\n\t\t\t})\n\t}\n\n\t/// Finds the attributes that have changed since the last update\n\t/// The versions map is used to determine the version of the attributes\n\t/// were last sent to the client.\n\tpub fn find_new_attributes(\n\t\t\u0026self,\n\t\tversions: \u0026AttributesVersionMap,\n\t) -\u003e Vec\u003cAttributeId\u003e {\n\t\tlet mut new_attributes = Vec::new();\n\t\tself.attributes.iter(|id, value| {\n\t\t\tif *id == 0 {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif let Some(version) = versions.get(id) {\n\t\t\t\tif value.timestamp() \u003c= *version {\n\t\t\t\t\t// skip writing an attribute if we already have the latest version\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif value.get() == Value::None \u0026\u0026 !versions.contains_key(id) {\n\t\t\t\t// skip writing an attribute if it was removed\n\t\t\t\t// and the client is not aware of it\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tnew_attributes.push(*id);\n\t\t});\n\n\t\tnew_attributes\n\t}\n\n\t/// Retreives an exact list of attributes from the entity and writes them\n\t/// to a capnp builder. This is used when the update set is already known\n\t/// and we just want to write data to the output buffer.\n\t///\n\t/// If you need however to discover the attributes that have changed\n\t/// since the last update, use `pull_attribute_updates` instead.\n\tpub fn pull_attributes(\n\t\t\u0026self,\n\t\tattributes: \u0026[AttributeId],\n\t\tbuilder: \u0026mut struct_list::Builder\u003c'_, attribute::Owned\u003e,\n\t) -\u003e bool {\n\t\tlet mut ix = 0;\n\t\tlet mut complete = true;\n\t\tfor id in attributes {\n\t\t\tif let Some(TimestampedVal(value, timestamp)) =\n\t\t\t\tself.attributes.get_with_timestamp(*id)\n\t\t\t{\n\t\t\t\tif ix \u003e= builder.len() {\n\t\t\t\t\tcomplete = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tlet mut attribute_builder = builder.reborrow().get(ix);\n\t\t\t\tattribute_builder.set_key(*id);\n\t\t\t\tattribute_builder.set_timestamp(timestamp);\n\t\t\t\tvalue.write_to_capnp(\u0026mut attribute_builder.reborrow().init_value());\n\t\t\t\tix += 1;\n\t\t\t}\n\t\t}\n\n\t\tcomplete\n\t}\n\n\t/// Updates attributes on this entity from a capnp reader.\n\t///\n\t/// This is used to update the state from a session request\n\t/// buffer without having to create any copies.\n\tpub fn push_attributes(\n\t\t\u0026self,\n\t\treader: struct_list::Reader\u003c'_, attribute::Owned\u003e,\n\t) -\u003e AttributesSetChanges {\n\t\tlet mut changes = AttributesSetChanges::default();\n\n\t\tfor attribute in reader {\n\t\t\tlet key = attribute.get_key();\n\t\t\tlet timestamp = attribute.get_timestamp();\n\n\t\t\t// note: we prefer to write values and skip the ones that fail\n\t\t\t// for some reason rather than loosing the whole update.\n\n\t\t\tlet value = match Value::from_capnp_reader(\u0026attribute.get_value()) {\n\t\t\t\tOk(value) =\u003e value,\n\t\t\t\tErr(e) =\u003e {\n\t\t\t\t\twarn!(\"failed to read attribute value from capnp reader: {e}\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// setting an attribute to none is equivalent to removing it\n\t\t\t// it will not be immediately removed from the entity, but\n\t\t\t// it will be overriden by a set operation with a new value.\n\t\t\tlet is_none = value == Value::None;\n\n\t\t\tlet change = match self.attributes.try_set(key, value, timestamp) {\n\t\t\t\tOk(new_timestamp) =\u003e new_timestamp,\n\t\t\t\tErr(e) =\u003e {\n\t\t\t\t\ttrace!(\n\t\t\t\t\t\t\"failed to push new attribute ({key}) to entity ({:?}): {e:?}\",\n\t\t\t\t\t\tself.id()\n\t\t\t\t\t);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif is_none {\n\t\t\t\t// if the value is none, we remove the attribute from the entity\n\t\t\t\t// and add it to the changes map so that we keep track of it.\n\t\t\t\tchanges.insert(key, AttributeChange::Deleted);\n\t\t\t} else {\n\t\t\t\tchanges.insert(key, change);\n\t\t\t}\n\t\t}\n\n\t\tchanges\n\t}\n}\n\n#[cfg(test)]\nimpl PartialEq for Entity {\n\tfn eq(\u0026self, other: \u0026Self) -\u003e bool {\n\t\tself.attributes == other.attributes\n\t}\n}\n\n#[derive(Error, Debug)]\npub enum Error {\n\t#[error(\"State capacity is exhausted ({0})\")]\n\tStateIsFull(usize),\n\n\t#[error(\"capnp error: {0}\")]\n\tCapnp(#[from] capnp::Error),\n}\n\n#[cfg(test)]\nmod tests {\n\tuse super::*;\n\n\t#[test]\n\tfn cell_set_same_version_not_allowed() {\n\t\t// given\n\t\tlet cell = ConcurrentCell::new_with_timestamp(1, 1);\n\n\t\t// when\n\t\tlet updated = cell.set(2, 1);\n\n\t\t// then\n\t\tassert!(!updated);\n\t}\n\n\t#[test]\n\tfn cell_set_prev_version_not_allowed() {\n\t\t// given\n\t\tlet cell = ConcurrentCell::new_with_timestamp(1, 2);\n\n\t\t// when\n\t\tlet updated = cell.set(2, 1);\n\n\t\t// then\n\t\tassert!(!updated);\n\t}\n\n\t#[test]\n\tfn cell_set_next_version_allowed() {\n\t\t// given\n\t\tlet cell = ConcurrentCell::new_with_timestamp(1, 1);\n\n\t\t// when\n\t\tlet updated = cell.set(2, 2);\n\n\t\t// then\n\t\tassert!(updated);\n\t}\n}\n","traces":[{"line":84,"address":[],"length":0,"stats":{"Line":7152},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":7152},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":7172},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":7172},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":7172},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":7172},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":7172},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":22890},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":22890},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":219983},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":219983},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":7210},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":7210},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":7208},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":7208},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":7208},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":7208},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":14416},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":33947},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":33947},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":33947},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":1936},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":7744},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":1892},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":180522},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":180522},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":51782},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":51782},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":51782},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":223547},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":133341},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":7207},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":7207},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":31452},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":7152},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":7152},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":7152},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":76727},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":76727},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":487683},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":205478},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":7169},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":7169},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":7169},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":7169},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":7169},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":7169},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":198887},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":636},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":636},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":636},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":1907},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":24788},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":57623},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":7311},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":21933},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":7235},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":21705},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":59},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":946},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":946},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":7640},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":7640},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":44118},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":44118},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":1351},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":1351},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":1351},"fn_name":null},{"line":478,"address":[],"length":0,"stats":{"Line":1628},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":248},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":494,"address":[],"length":0,"stats":{"Line":43701},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":43701},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":248968},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":205267},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":198016},"fn_name":null},{"line":507,"address":[],"length":0,"stats":{"Line":197978},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":7344},"fn_name":null},{"line":514,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":7235},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":43701},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":1033},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":1033},"fn_name":null},{"line":535,"address":[],"length":0,"stats":{"Line":1033},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":15503},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":7235},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":7235},"fn_name":null},{"line":546,"address":[],"length":0,"stats":{"Line":7235},"fn_name":null},{"line":547,"address":[],"length":0,"stats":{"Line":7235},"fn_name":null},{"line":548,"address":[],"length":0,"stats":{"Line":7235},"fn_name":null},{"line":549,"address":[],"length":0,"stats":{"Line":7235},"fn_name":null},{"line":553,"address":[],"length":0,"stats":{"Line":1033},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":482},"fn_name":null},{"line":564,"address":[],"length":0,"stats":{"Line":482},"fn_name":null},{"line":566,"address":[],"length":0,"stats":{"Line":2440},"fn_name":null},{"line":573,"address":[],"length":0,"stats":{"Line":979},"fn_name":null},{"line":575,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":576,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":586,"address":[],"length":0,"stats":{"Line":979},"fn_name":null},{"line":588,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":589,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":590,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":591,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":593,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":597,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":600,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":602,"address":[],"length":0,"stats":{"Line":978},"fn_name":null},{"line":606,"address":[],"length":0,"stats":{"Line":482},"fn_name":null}],"covered":113,"coverable":166},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","state","graph.rs"],"content":"use {\n\tsuper::{object::ObjectId, player::PlayerId, EntityId},\n\tdashmap::{DashMap, DashSet},\n\tfxhash::FxBuildHasher,\n\tstd::fmt::Debug,\n};\n\n/// The object graph is a directed graph of objects ownership.\n/// It is used to track the ownership of objects and to quickly find all objects\n/// that are owned by an entity.\n#[derive(Debug, Default)]\npub struct ObjectGraph {\n\t/// A map of all objects to their owners.\n\towners: DashMap\u003cObjectId, EntityId, FxBuildHasher\u003e,\n\n\t/// A map of all entities to their children.\n\tchildren: DashMap\u003cEntityId, DashSet\u003cObjectId, FxBuildHasher\u003e, FxBuildHasher\u003e,\n}\n\nimpl ObjectGraph {\n\tpub fn children_of(\u0026self, owner: EntityId) -\u003e Vec\u003cObjectId\u003e {\n\t\tself\n\t\t\t.children\n\t\t\t.get(\u0026owner)\n\t\t\t.map(|children| children.value().iter().map(|child| *child).collect())\n\t\t\t.unwrap_or_default()\n\t}\n\n\tpub fn owner_of(\u0026self, object: ObjectId) -\u003e Option\u003cEntityId\u003e {\n\t\tself.owners.get(\u0026object).map(|owner| *owner)\n\t}\n\n\t/// Returns the root of the ownership tree for the given object.\n\tpub fn root_owner_of(\u0026self, object: ObjectId) -\u003e Option\u003cEntityId\u003e {\n\t\tlet mut current_node = object;\n\n\t\tloop {\n\t\t\tif let Some(owner) = self.owners.get(\u0026current_node) {\n\t\t\t\tmatch *owner {\n\t\t\t\t\tEntityId::Player(id) =\u003e return Some(EntityId::Player(id)),\n\t\t\t\t\tEntityId::Object(parent) =\u003e current_node = parent,\n\t\t\t\t};\n\t\t\t} else if current_node == object {\n\t\t\t\treturn None;\n\t\t\t} else {\n\t\t\t\treturn Some(EntityId::Object(current_node));\n\t\t\t}\n\t\t}\n\t}\n\n\t/// Returns true of the object is owned by a given entity.\n\t/// This will traverse the whole ownership path to the root and the\n\t/// owner doesn't have to be the direct parent of the object.\n\tpub fn is_owned_by(\u0026self, object: ObjectId, owner: EntityId) -\u003e bool {\n\t\tself\n\t\t\t.root_owner_of(object)\n\t\t\t.map(|root| root == owner)\n\t\t\t.unwrap_or_default()\n\t}\n\n\tpub fn owner_changed(\u0026self, object: ObjectId, new_owner: EntityId) {\n\t\tif let Some(old_owner) = self.owners.insert(object, new_owner) {\n\t\t\tself\n\t\t\t\t.children\n\t\t\t\t.get(\u0026old_owner)\n\t\t\t\t.and_then(|children| children.value().remove(\u0026object));\n\t\t}\n\n\t\tself.children.entry(new_owner).or_default().insert(object);\n\t}\n\n\tpub fn object_despawned(\u0026self, object: ObjectId) {\n\t\tif let Some((_, owner)) = self.owners.remove(\u0026object) {\n\t\t\tself\n\t\t\t\t.children\n\t\t\t\t.get(\u0026owner)\n\t\t\t\t.and_then(|children| children.value().remove(\u0026object));\n\n\t\t\tif self\n\t\t\t\t.children\n\t\t\t\t.get(\u0026owner)\n\t\t\t\t.map(|children| children.value().is_empty())\n\t\t\t\t.unwrap_or_default()\n\t\t\t{\n\t\t\t\tself.children.remove(\u0026owner);\n\t\t\t}\n\t\t}\n\t}\n\n\tpub fn player_disconnected(\u0026self, player: PlayerId) {\n\t\tself.children.remove(\u0026EntityId::Player(player));\n\t}\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":14168},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":14168},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":14168},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":14168},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":39678},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":1528},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":4581},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":1072},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":1072},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":2133},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":1057},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":1045},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1045},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":1045},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":3124},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":634},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":638},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":634},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":23},"fn_name":null}],"covered":30,"coverable":30},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","state","mod.rs"],"content":"use {\n\tquark_client_sdk::{protocol::attributes::attribute, Value},\n\tstd::time::{SystemTime, UNIX_EPOCH},\n};\n\npub mod entity;\npub mod graph;\npub mod object;\npub mod player;\npub mod rules;\n\npub type EntityId = quark_client_sdk::EntityId;\npub type Timestamp = quark_client_sdk::Timestamp;\n\n#[derive(Debug, Clone, PartialOrd, Ord, PartialEq, Eq, Hash)]\npub enum DespawnedEntity {\n\tObject(object::ObjectId),\n\tPlayer(player::PlayerId, String),\n}\n\n#[derive(Debug, Clone, PartialEq, Default)]\npub struct TimestampedVal(pub Value, pub Timestamp);\n\nimpl TimestampedVal {\n\tpub fn from_capnp_reader(\n\t\treader: \u0026attribute::Reader,\n\t) -\u003e Result\u003cSelf, capnp::Error\u003e {\n\t\tlet value = Value::from_capnp_reader(\u0026reader.get_value())?;\n\t\tlet timestamp = reader.get_timestamp();\n\t\tOk(Self(value, timestamp))\n\t}\n}\n\nimpl From\u003c(Value, Timestamp)\u003e for TimestampedVal {\n\tfn from((value, timestamp): (Value, Timestamp)) -\u003e Self {\n\t\tSelf(value, timestamp)\n\t}\n}\n\npub fn current_timestamp() -\u003e Timestamp {\n\tSystemTime::now()\n\t\t.duration_since(UNIX_EPOCH)\n\t\t.unwrap_or_default()\n\t\t.as_millis()\n\t\t.try_into()\n\t\t.unwrap_or_default()\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":5301},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":10602},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":8073},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":8073},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":628},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":628},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":628},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","state","object.rs"],"content":"use super::{entity::Entity, player::PlayerId};\n\n// Used to uniquely identify an object\npub type ObjectId = u64;\npub type ObjectEntity = Entity;\n\n/// An object id is derived from a player if the first 32 bits of the object id\n/// are equal to the player id. This is used to ensure that session spawn\n/// objects in their own namespace and avoid collisions with objects spawned by\n/// other sessions.\npub const fn is_id_derived(object_id: ObjectId, player_id: PlayerId) -\u003e bool {\n\t(object_id \u003e\u003e 32) as u32 == player_id\n}\n\n/// An object id is shared if it is allocated in the\n/// shared namespace (i.e. the first 32 bits are all 1s).\n///\n/// This is used to identify objects that are part of the\n/// level and are not spawned by any player, instead they\n/// are on-demand made dynamic when on certain interactions.\npub const fn is_id_shared(object_id: ObjectId) -\u003e bool {\n\tis_id_derived(object_id, u32::MAX as PlayerId)\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":640},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":640},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":4},"fn_name":null}],"covered":4,"coverable":4},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","state","player.rs"],"content":"use super::entity::Entity;\n\n/// Used to uniquely identify a player session\npub type PlayerId = u32;\npub type PlayerEntity = Entity;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","state","rules","mod.rs"],"content":"use {\n\tsuper::{\n\t\tentity::{AttributeChange, AttributeId, Entity, EntityChanges},\n\t\tplayer::PlayerId,\n\t},\n\tcrate::global::GlobalState,\n\tlazy_static::lazy_static,\n\tquark_client_sdk::WellKnownAttribute,\n\trustc_hash::FxHashMap,\n\tstd::sync::Arc,\n};\n\nmod ownership;\nmod spec;\n\ntype RuleFunction = fn(\n\t\u0026PlayerId,         // by\n\t\u0026Entity,           // entity\n\tAttributeId,       // attribute\n\t\u0026AttributeChange,  // change\n\t\u0026Arc\u003cGlobalState\u003e, // global\n);\n\nlazy_static! {\n\tstatic ref RULES: FxHashMap\u003cAttributeId, Vec\u003cRuleFunction\u003e\u003e = {\n\t\tlet mut rules = FxHashMap::default();\n\n\t\t// rules that apply when the owner of an entity changes\n\t\trules.insert(\n\t\t\tWellKnownAttribute::OwnerId as AttributeId,\n\t\t\tvec![ownership::apply_ownership_index as RuleFunction],\n\t\t);\n\n\t\t// rules when the class of an entity changes\n\t\trules.insert(\n\t\t\tWellKnownAttribute::ClassId as AttributeId,\n\t\t\tvec![spec::apply_new_spec as RuleFunction],\n\t\t);\n\n\t\trules\n\t};\n}\n\npub fn apply_post_update_rules(\n\tby: \u0026PlayerId,\n\tentity: \u0026Entity,\n\tchange: \u0026EntityChanges,\n\tglobal: \u0026Arc\u003cGlobalState\u003e,\n) {\n\tfor (attribute, change) in change.attributes.iter() {\n\t\tif change == \u0026AttributeChange::None {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif let Some(rules) = RULES.get(attribute) {\n\t\t\tfor rule in rules {\n\t\t\t\trule(by, entity, *attribute, change, global);\n\t\t\t}\n\t\t}\n\t}\n}\n","traces":[{"line":44,"address":[],"length":0,"stats":{"Line":1479},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":9118},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":7639},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":657},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":2628},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":657},"fn_name":null}],"covered":6,"coverable":7},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","state","rules","ownership.rs"],"content":"use {\n\tcrate::{\n\t\tglobal::GlobalState,\n\t\tstate::{\n\t\t\tentity::{AttributeChange, AttributeId, Entity},\n\t\t\tplayer::PlayerId,\n\t\t\tEntityId,\n\t\t},\n\t},\n\tquark_client_sdk::{Value, WellKnownAttribute},\n\tstd::sync::Arc,\n\ttracing::trace,\n};\n\n/// When an entity changes its owner, we need to update the reverse index of\n/// owned objects on the owner.\npub fn apply_ownership_index(\n\tby: \u0026PlayerId,\n\tentity: \u0026Entity,\n\t_attribute: AttributeId,\n\t_change: \u0026AttributeChange,\n\tglobal: \u0026Arc\u003cGlobalState\u003e,\n) {\n\tlet EntityId::Object(object_id) = *entity.id() else {\n\t\tentity\n\t\t\t.attributes()\n\t\t\t.try_access(WellKnownAttribute::OwnerId as AttributeId, |e| {\n\t\t\t\te.set(Value::None, Default::default())\n\t\t\t});\n\n\t\treturn; // players can't be owned, so this is noop\n\t};\n\n\tlet Some(new_owner) = entity\n\t\t.attributes()\n\t\t.get(WellKnownAttribute::OwnerId as AttributeId)\n\telse {\n\t\treturn; // no owner, so this is a noop\n\t};\n\n\tlet new_owner = match new_owner {\n\t\tValue::Uint32(id) =\u003e EntityId::Player(id),\n\t\tValue::Uint64(id) =\u003e EntityId::Object(id),\n\t\t_ =\u003e return, // invalid owner, so this is a noop\n\t};\n\n\tif global.graph().owner_of(object_id) == Some(new_owner) {\n\t\treturn; // nothing changed.\n\t}\n\n\t// if the object was owned by a player, then only\n\t// that player can reassign ownership of the object\n\tlet old_owner = global.graph().root_owner_of(object_id);\n\tif let Some(EntityId::Player(old_owner)) = old_owner {\n\t\tif old_owner != *by {\n\t\t\ttrace!(\n\t\t\t\tsession = by,\n\t\t\t\t\"Ownership change denied for {entity:?} by {by:?}\"\n\t\t\t);\n\n\t\t\t// revert back to the old owner\n\t\t\tentity.attributes().try_access(\n\t\t\t\tWellKnownAttribute::OwnerId as AttributeId,\n\t\t\t\t|e| {\n\t\t\t\t\te.set(Value::Uint32(old_owner), e.timestamp());\n\t\t\t\t},\n\t\t\t);\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\tglobal.graph().owner_changed(object_id, new_owner);\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":634},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":1268},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":634},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":634},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":632},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":628},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":6},"fn_name":null}],"covered":11,"coverable":23},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","state","rules","spec.rs"],"content":"use {\n\tcrate::{\n\t\tglobal::GlobalState,\n\t\tschema,\n\t\tstate::{\n\t\t\tentity::{AttributeChange, AttributeId, Entity},\n\t\t\tplayer::PlayerId,\n\t\t\tEntityId,\n\t\t},\n\t},\n\tstd::sync::Arc,\n};\n\npub fn apply_new_spec(\n\tby: \u0026PlayerId,\n\tentity: \u0026Entity,\n\t_attribute: AttributeId,\n\t_change: \u0026AttributeChange,\n\tglobal: \u0026Arc\u003cGlobalState\u003e,\n) {\n\tmatch entity.id() {\n\t\tEntityId::Object(_) =\u003e {\n\t\t\tapply_new_object_spec(by, entity, global);\n\t\t}\n\t\tEntityId::Player(_) =\u003e {\n\t\t\tapply_new_player_spec(by, entity, global);\n\t\t}\n\t}\n}\n\nfn apply_new_object_spec(\n\t_by: \u0026PlayerId,\n\tentity: \u0026Entity,\n\tglobal: \u0026Arc\u003cGlobalState\u003e,\n) {\n\tlet EntityId::Object(object_id) = *entity.id() else {\n\t\treturn;\n\t};\n\n\t// if the object has a defined TTL in the schema,\n\t// schedule its deletion right away.\n\tif let schema::Lifetime::Timeout(ttl) =\n\t\t*global.schema().spec_of(entity).lifetime()\n\t{\n\t\tlet global = Arc::clone(global);\n\t\ttokio::spawn(async move {\n\t\t\ttokio::time::sleep(ttl).await;\n\t\t\tglobal.objects().system_despawn(object_id, \u0026global);\n\t\t});\n\t}\n}\n\nfn apply_new_player_spec(\n\t_by: \u0026PlayerId,\n\t_entity: \u0026Entity,\n\t_global: \u0026GlobalState,\n) {\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":4},"fn_name":null}],"covered":14,"coverable":15},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","tests","admin.rs"],"content":"use {\n\tcrate::{\n\t\topts::{Profile, ServerOptions},\n\t\tschema::Schema,\n\t\ttests::mock::MockServer,\n\t},\n\treqwest::StatusCode,\n\tserde::Deserialize,\n\tstd::{net::SocketAddr, path::PathBuf, str::FromStr},\n};\n\n#[derive(PartialEq, Eq, Debug, Deserialize)]\nstruct Stats {\n\tplayers: usize,\n\tobjects: usize,\n}\n\n#[derive(PartialEq, Eq, Debug, Deserialize)]\nstruct Player {\n\tplayer_id: u32,\n}\n\n// This test case is validate the functionality of the following admin/info apis\n// 1. info/stats\n// 2. info/status\n// 3. info/profile\n// 1. info/schema (default response)\n#[tokio::test]\nasync fn admin_info_api_test() -\u003e anyhow::Result\u003c()\u003e {\n\t// Starting the server with admin listen address\n\tlet admin_addr = SocketAddr::from(([127, 0, 0, 1], 3000));\n\tlet server = MockServer::new(ServerOptions {\n\t\tadmin_api: Some(admin_addr),\n\t\t..Default::default()\n\t})\n\t.await?;\n\n\t// Hitting the admin/info/stats api and validating the response\n\tlet response = reqwest::get(\"http://127.0.0.1:3000/info/stats\")\n\t\t.await?\n\t\t.text()\n\t\t.await?;\n\tlet stats = serde_json::from_str::\u003cStats\u003e(response.as_str())\n\t\t.expect(\"Failed to deserialize JSON\");\n\tassert_eq!(stats, Stats {\n\t\tplayers: 0,\n\t\tobjects: 0\n\t});\n\n\t// Hitting the admin/info/status api and validating the response\n\tlet response = reqwest::get(\"http://127.0.0.1:3000/info/status\")\n\t\t.await?\n\t\t.text()\n\t\t.await?;\n\tassert_eq!(response, \"ok\");\n\n\t// Hitting the admin/info/profile api and validating that the profile matches\n\t// the server profile\n\tlet response = reqwest::get(\"http://127.0.0.1:3000/info/profile\")\n\t\t.await?\n\t\t.text()\n\t\t.await?;\n\tlet profile = serde_json::from_str::\u003cProfile\u003e(response.as_str())\n\t\t.expect(\"Failed to deserialize JSON\");\n\n\tassert_eq!(server.profile().resume_timeout, profile.resume_timeout);\n\tassert_eq!(\n\t\tserver.profile().relevance_timeout,\n\t\tprofile.relevance_timeout\n\t);\n\tassert_eq!(\n\t\tserver.profile().group_index.reindex_interval,\n\t\tprofile.group_index.reindex_interval\n\t);\n\tassert_eq!(\n\t\tserver.profile().global_index.reindex_interval,\n\t\tprofile.global_index.reindex_interval\n\t);\n\n\t// Hitting the admin/info/schema api and validating the response\n\t// Schema is not provided in the server so the response should be \"default\"\n\tlet response = reqwest::get(\"http://127.0.0.1:3000/info/schema\")\n\t\t.await?\n\t\t.text()\n\t\t.await?;\n\tassert_eq!(response, \"default\");\n\n\tOk(())\n}\n\n// This test case is to test the admin/info/schema api\n// after requesting the schema from the server, we  validate the received\n// schema with the actual schema provided to the server\n#[tokio::test]\nasync fn admin_info_schema_api_test() -\u003e anyhow::Result\u003c()\u003e {\n\t// Admin listen address\n\tlet admin_addr = SocketAddr::from(([127, 0, 0, 1], 8080));\n\t// Providing the server with path to schema (minimal schema)\n\tlet path = PathBuf::from_str(\"src/tests/assets/minimal.yml\")?;\n\n\t// Server started with minimal schema and admin services\n\tMockServer::new(ServerOptions {\n\t\tadmin_api: Some(admin_addr),\n\t\tschema: Some(path),\n\t\t..Default::default()\n\t})\n\t.await?;\n\n\t// Hitting the admin/info/schema api and validating the schema in detail\n\tlet response = reqwest::get(\"http://127.0.0.1:8080/info/schema\")\n\t\t.await?\n\t\t.text()\n\t\t.await?;\n\tlet rcvschema = serde_yaml::from_str::\u003cSchema\u003e(response.as_str())\n\t\t.expect(\"Failed to deserialize YAML\");\n\n\tlet minimal_schema = Schema::from_yaml_file(\"src/tests/assets/minimal.yml\")?;\n\n\tassert_eq!(minimal_schema, rcvschema);\n\n\tOk(())\n}\n\n// This test case is to test the admin/info/schema api with JSON output format\n// after requesting the schema from the server, we  validate the received\n// schema with the actual schema provided to the server\n#[tokio::test]\nasync fn admin_info_schema_json_api_test() -\u003e anyhow::Result\u003c()\u003e {\n\t// given\n\tlet admin_addr = SocketAddr::from(([127, 0, 0, 1], 8081));\n\n\tlet path = PathBuf::from_str(\"src/tests/assets/full.yml\")?;\n\n\tMockServer::new(ServerOptions {\n\t\tadmin_api: Some(admin_addr),\n\t\tschema: Some(path),\n\t\t..Default::default()\n\t})\n\t.await?;\n\n\t// when\n\tlet response = reqwest::get(\"http://127.0.0.1:8081/info/schema?format=json\")\n\t\t.await?\n\t\t.text()\n\t\t.await?;\n\tlet rcvschema = serde_json::from_str::\u003cSchema\u003e(response.as_str())\n\t\t.expect(\"Failed to deserialize JSON\");\n\n\t// then\n\tlet minimal_schema = Schema::from_yaml_file(\"src/tests/assets/full.yml\")?;\n\n\tassert_eq!(minimal_schema, rcvschema);\n\n\tOk(())\n}\n\n// This test case verfies the functionality of admin player apis\n// 1. admin/player/:id\n// 2. admin/player/:id/kick\n#[tokio::test]\nasync fn admin_player_api_test() -\u003e anyhow::Result\u003c()\u003e {\n\t// Admin listen address\n\tlet admin_addr = SocketAddr::from(([127, 0, 0, 1], 8000));\n\t// Server started with admin services\n\tlet server = MockServer::new(ServerOptions {\n\t\tadmin_api: Some(admin_addr),\n\t\t..Default::default()\n\t})\n\t.await?;\n\n\t// Connecting a client to the server\n\tlet client = server.new_session().await?;\n\n\t// Generating the url for admin/player/:id api\n\tlet player_url = format!(\"http://127.0.0.1:8000/player/{}\", client.id());\n\t// Hitting the admin/player/:id api which should echo back the player id sent\n\t// in the URL\n\tlet response = reqwest::get(player_url).await?.text().await?;\n\n\tlet player = serde_json::from_str::\u003cPlayer\u003e(response.as_str())\n\t\t.expect(\"Failed to deserialize JSON\");\n\n\tassert_eq!(player, Player {\n\t\tplayer_id: client.id()\n\t});\n\n\t// Generating the url for admin/player/:id/kick api\n\tlet player_url = format!(\"http://127.0.0.1:8000/player/{}/kick\", client.id());\n\n\t// Hitting the HTTP-POST admin/player/:id/kick with the connecting client's id\n\t// Client should be removed from the server\n\tlet response = reqwest::Client::new()\n\t\t.post(player_url)\n\t\t.body(\"\")\n\t\t.send()\n\t\t.await?;\n\tassert_eq!(response.status(), 200);\n\n\tlet player_url = format!(\"http://127.0.0.1:8000/player/{}\", client.id());\n\tassert_eq!(\n\t\treqwest::get(player_url).await?.status(),\n\t\tStatusCode::NOT_FOUND\n\t);\n\n\tOk(())\n}\n\n// Test that the meta schema endpoint returns valid json output\n#[tokio::test]\nasync fn admin_meta_schema_json_api_test() -\u003e anyhow::Result\u003c()\u003e {\n\t// given\n\tlet admin_addr = SocketAddr::from(([127, 0, 0, 1], 8082));\n\tlet path = PathBuf::from_str(\"src/tests/assets/full.yml\")?;\n\n\tMockServer::new(ServerOptions {\n\t\tadmin_api: Some(admin_addr),\n\t\tschema: Some(path),\n\t\t..Default::default()\n\t})\n\t.await?;\n\n\t// when\n\tlet response = reqwest::get(\"http://127.0.0.1:8082/meta/schema\").await?;\n\n\t// then\n\tassert!(response.status().is_success());\n\tassert!(serde_json::from_str::\u003cschemars::schema::RootSchema\u003e(\n\t\tresponse.text().await?.as_str(),\n\t)\n\t.is_ok());\n\n\tOk(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","tests","authenticate.rs"],"content":"use {\n\tcrate::{opts::ServerOptions, tests::mock::MockServer},\n\thmac::{Hmac, Mac},\n\tjwt::SignWithKey,\n\tsha2::Sha256,\n\tstd::collections::BTreeMap,\n};\n\n// This test varifies the working of Quark jwt-SHA256 authentication\n// First case is to generate a valid token and client should be connected to\n// server Second case is to generate a token with invalid secret\n// Third case is to generate a valid token but without \"pid\" claim, auth should\n// fail Fourth case is to overflow the attributes in the token, auth should fail\n#[tokio::test]\nasync fn jwt_auth_smoke() -\u003e anyhow::Result\u003c()\u003e {\n\tlet secret = Hmac::new_from_slice(b\"QUARK-TEST-SEC\").unwrap();\n\tlet invalid_secret: Hmac\u003cSha256\u003e =\n\t\tHmac::new_from_slice(b\"QUARK-TEEST-SEC\").unwrap();\n\n\tlet server = MockServer::new(ServerOptions {\n\t\tsecret: Some(secret.clone()),\n\t\t..Default::default()\n\t})\n\t.await?;\n\n\t// Case 1\n\tlet mut claims = BTreeMap::new();\n\tclaims.insert(\"pid\", \"1\");\n\n\tlet jwt_token_response = claims.sign_with_key(\u0026secret)?;\n\n\tlet client_connected = server\n\t\t.build_session()\n\t\t.with_auth(jwt_token_response.as_bytes())\n\t\t.build()\n\t\t.await\n\t\t.is_ok();\n\n\tassert!(client_connected);\n\n\t// Case 2\n\tlet mut claims = BTreeMap::new();\n\tclaims.insert(\"pid\", \"1\");\n\n\tlet jwt_token_response = claims.sign_with_key(\u0026invalid_secret)?;\n\n\tlet client_connected = server\n\t\t.build_session()\n\t\t.with_auth(jwt_token_response.as_bytes())\n\t\t.build()\n\t\t.await\n\t\t.is_ok();\n\n\tassert!(!client_connected);\n\n\t// Case 3\n\tlet mut claims = BTreeMap::new();\n\tclaims.insert(\"position\", \"2,3,4\");\n\tlet jwt_token_response = claims.sign_with_key(\u0026secret)?;\n\n\tlet client_connected = server\n\t\t.build_session()\n\t\t.with_auth(jwt_token_response.as_bytes())\n\t\t.build()\n\t\t.await\n\t\t.is_ok();\n\n\tassert!(!client_connected);\n\n\t// Attributes array to overflow the claims\n\tlet attrs = [\n\t\t\"attr1\", \"attr2\", \"attr3\", \"attr4\", \"attr5\", \"attr6\", \"attr7\", \"attr8\",\n\t\t\"attr9\", \"attr10\", \"attr11\", \"attr12\", \"attr13\", \"attr14\", \"attr15\",\n\t\t\"attr16\", \"attr17\", \"attr18\", \"attr19\", \"attr20\", \"attr21\", \"attr22\",\n\t\t\"attr23\", \"attr24\", \"attr25\", \"attr26\", \"attr27\", \"attr28\", \"attr29\",\n\t\t\"attr30\", \"attr31\", \"attr32\", \"attr33\", \"attr34\", \"attr35\", \"attr36\",\n\t\t\"attr37\", \"attr38\", \"attr39\", \"attr40\", \"attr41\", \"attr42\", \"attr43\",\n\t\t\"attr44\", \"attr45\", \"attr46\", \"attr47\", \"attr48\", \"attr49\", \"attr50\",\n\t\t\"attr51\", \"attr52\", \"attr53\", \"attr54\", \"attr55\", \"attr56\", \"attr57\",\n\t\t\"attr58\", \"attr59\", \"attr60\", \"attr61\", \"attr62\", \"attr63\", \"attr64\",\n\t\t\"attr65\", \"attr66\", \"attr67\", \"attr68\", \"attr69\", \"attr70\", \"attr71\",\n\t\t\"attr72\", \"attr73\", \"attr74\", \"attr75\", \"attr76\", \"attr77\", \"attr78\",\n\t\t\"attr79\", \"attr80\", \"attr81\", \"attr82\", \"attr83\", \"attr84\", \"attr85\",\n\t\t\"attr86\", \"attr87\", \"attr88\", \"attr89\", \"attr90\", \"attr91\", \"attr92\",\n\t\t\"attr93\", \"attr94\", \"attr95\", \"attr96\", \"attr97\", \"attr98\", \"attr99\",\n\t\t\"attr100\", \"attr101\", \"attr102\", \"attr103\", \"attr104\", \"attr105\",\n\t\t\"attr106\", \"attr107\", \"attr108\", \"attr109\", \"attr110\", \"attr111\",\n\t\t\"attr112\", \"attr113\", \"attr114\", \"attr115\", \"attr116\", \"attr117\",\n\t\t\"attr118\", \"attr119\", \"attr120\", \"attr121\", \"attr122\", \"attr123\",\n\t\t\"attr124\", \"attr125\", \"attr126\", \"attr127\", \"attr128\", \"attr129\",\n\t\t\"attr130\",\n\t];\n\n\t// Case 4\n\tlet mut claims = BTreeMap::new();\n\tclaims.insert(\"pid\", \"3\");\n\tfor attr in attrs {\n\t\tclaims.insert(attr, \"any\");\n\t}\n\tlet jwt_token_response = claims.sign_with_key(\u0026secret)?;\n\n\tlet client_connected = server\n\t\t.build_session()\n\t\t.with_auth(jwt_token_response.as_bytes())\n\t\t.build()\n\t\t.await\n\t\t.is_ok();\n\n\tassert!(!client_connected);\n\n\tOk(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","tests","authority.rs"],"content":"use {\n\tcrate::{\n\t\topts::{Profile, ServerOptions},\n\t\trelevance::{GroupIndexConfig, SpatialIndexConfig},\n\t\tschema::{self, Object, Ownership, Schema},\n\t\ttests::mock::{MockServer, SessionTestExt, TickUpdate},\n\t},\n\tquark_client_sdk::{Value, WellKnownAttribute},\n\tstd::time::Duration,\n};\n\n#[tokio::test]\nasync fn two_players_update_one_object_with_time_decay() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::new(ServerOptions::with_profile(Profile {\n\t\tspatial_index: SpatialIndexConfig {\n\t\t\tmax_radius: 10,\n\t\t\tmap_width: 100,\n\t\t\tmap_height: 100,\n\t\t\tcells_count_x: 10,\n\t\t\tcells_count_y: 10,\n\t\t\treindex_interval: Duration::from_millis(500),\n\t\t},\n\n\t\t..Default::default()\n\t}))\n\t.await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\n\tlet object_id = client1.derive_global_id(51);\n\n\tupdate.object(object_id).attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((10.0, 2.0, 3.0)),\n\t);\n\n\tupdate\n\t\t.object(object_id)\n\t\t.attributes\n\t\t.insert(200, Value::Uint32(100));\n\n\tclient1.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\t// now ensure that client2 receives the update\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((2.0, 3.0, 4.0)),\n\t);\n\n\tlet resp2 = client2.roundtrip(update).await?;\n\n\tassert_eq!(resp2.players.len(), 1);\n\tassert_eq!(resp2.objects.len(), 1);\n\tassert_eq!(resp2.events.len(), 0);\n\tassert_eq!(\n\t\tresp2.objects[\u0026object_id].attributes[\u0026200],\n\t\tValue::Uint32(100)\n\t);\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate\n\t\t.object(object_id)\n\t\t.attributes\n\t\t.insert(200, Value::Uint32(999));\n\tclient2.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\t// client 1 created an object, client 2 updated its value, client 1 should see\n\t// the update\n\tlet resp1 = client1.pull().await?;\n\tassert_eq!(resp1.players.len(), 1);\n\tassert_eq!(resp1.objects.len(), 1);\n\tassert_eq!(resp1.events.len(), 0);\n\tassert_eq!(\n\t\tresp1.objects[\u0026object_id].attributes[\u0026200],\n\t\tValue::Uint32(999)\n\t);\n\n\tOk(())\n}\n\n#[tokio::test]\nasync fn two_players_update_one_object_immediate() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::new(ServerOptions::with_profile(Profile {\n\t\tspatial_index: SpatialIndexConfig {\n\t\t\tmax_radius: 100,\n\t\t\tmap_width: 100000,\n\t\t\tmap_height: 100000,\n\t\t\tcells_count_x: 100,\n\t\t\tcells_count_y: 100,\n\t\t\treindex_interval: Duration::from_millis(50),\n\t\t},\n\n\t\t..Default::default()\n\t}))\n\t.await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\tlet mut client3 = server.new_session().await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\n\tlet object_id = client1.derive_global_id(51);\n\n\tupdate.object(object_id).attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((2810.0, 219.0, 3.0)),\n\t);\n\n\tupdate\n\t\t.object(object_id)\n\t\t.attributes\n\t\t.insert(200, Value::Uint32(100));\n\n\tclient1.push(update).await?;\n\n\t// now ensure that client2 receives the update\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((2.0, 3.0, 4.0)),\n\t);\n\n\tupdate\n\t\t.object(object_id)\n\t\t.attributes\n\t\t.insert(200, Value::Uint32(999));\n\tclient2.push(update).await?; // update it quickly enough that the first update doesn't decay\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((3.0, 3.0, 4.0)),\n\t);\n\tlet resp3 = client3.roundtrip(update).await?;\n\n\tassert_eq!(resp3.players.len(), 2);\n\tassert_eq!(resp3.objects.len(), 1);\n\tassert_eq!(resp3.events.len(), 0);\n\tassert_eq!(\n\t\tresp3.objects[\u0026object_id].attributes[\u0026200],\n\t\tValue::Uint32(100) // client 2 update should not go through\n\t);\n\n\t// now wait a bit and let the last successfull update decay with time,\n\t// and now it should go through\n\tserver.wait_for_spatial_reindex().await;\n\ttokio::time::sleep(std::time::Duration::from_millis(700)).await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate\n\t\t.object(object_id)\n\t\t.attributes\n\t\t.insert(200, Value::Uint32(999));\n\tclient2.roundtrip(update).await?;\n\n\tlet resp3 = client3.pull().await?;\n\tassert_eq!(resp3.players.len(), 0);\n\tassert_eq!(resp3.objects.len(), 1);\n\tassert_eq!(resp3.events.len(), 0);\n\tassert_eq!(\n\t\tresp3.objects[\u0026object_id].attributes[\u0026200],\n\t\tValue::Uint32(999) // client 2 update should go through\n\t);\n\n\tOk(())\n}\n\n#[tokio::test]\nasync fn two_players_update_one_object_different_relevance(\n) -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::new(ServerOptions::with_profile_and_schema(\n\t\tProfile {\n\t\t\tspatial_index: SpatialIndexConfig {\n\t\t\t\tmax_radius: 100,\n\t\t\t\tmap_width: 100000,\n\t\t\t\tmap_height: 100000,\n\t\t\t\tcells_count_x: 100,\n\t\t\t\tcells_count_y: 100,\n\t\t\t\treindex_interval: Duration::from_millis(50),\n\t\t\t},\n\t\t\tgroup_index: GroupIndexConfig {\n\t\t\t\treindex_interval: Duration::from_millis(50),\n\t\t\t},\n\t\t\t..Default::default()\n\t\t},\n\t\tSchema::with_objects(vec![Object {\n\t\t\tname: \"test-object\".to_string(),\n\t\t\tclass_id: 2003,\n\t\t\townership: Ownership::Detached,\n\t\t\tlifetime: schema::Lifetime::Owner,\n\t\t\tblend: schema::Blend::default(),\n\t\t\t..Default::default()\n\t\t}])?,\n\t))\n\t.await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\tlet mut client3 = server.new_session().await?;\n\n\t// same scenario as above, where two clients are updating\n\t// the same object very rapidly, but one is much much closer\n\t// to the object, so that even halving its score because of\n\t// continuity, it still has a higher score than the other client\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\n\tlet object_id = client1.derive_global_id(51);\n\n\tupdate.object(object_id).attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((49810.0, 3219.0, 3.0)),\n\t);\n\n\tupdate\n\t\t.object(object_id)\n\t\t.attributes\n\t\t.insert(WellKnownAttribute::ClassId as u16, Value::Uint32(2003));\n\n\tupdate\n\t\t.object(object_id)\n\t\t.attributes\n\t\t.insert(200, Value::Uint32(100));\n\tclient1.roundtrip(update).await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((49800.0, 3200.0, 4.0)),\n\t);\n\tupdate\n\t\t.object(object_id)\n\t\t.attributes\n\t\t.insert(200, Value::Uint32(999));\n\tclient2.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((3.0, 3.0, 4.0)),\n\t);\n\tlet resp3 = client3.roundtrip(update).await?;\n\n\tassert_eq!(resp3.players.len(), 2);\n\tassert_eq!(resp3.objects.len(), 1);\n\tassert_eq!(resp3.events.len(), 0);\n\n\t// classid, position, and the attribute\n\tassert_eq!(resp3.objects[\u0026object_id].attributes.len(), 3);\n\tassert_eq!(\n\t\tresp3.objects[\u0026object_id].attributes[\u0026200],\n\t\tValue::Uint32(999) // client 2 update should go through\n\t);\n\n\tOk(())\n}\n\n#[tokio::test]\nasync fn two_players_update_one_object_different_relevance_3d(\n) -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::new(ServerOptions::with_profile_and_schema(\n\t\tProfile {\n\t\t\tspatial_index: SpatialIndexConfig {\n\t\t\t\tmax_radius: 100,\n\t\t\t\tmap_width: 100000,\n\t\t\t\tmap_height: 100000,\n\t\t\t\tcells_count_x: 100,\n\t\t\t\tcells_count_y: 100,\n\t\t\t\treindex_interval: Duration::from_millis(50),\n\t\t\t},\n\t\t\tgroup_index: GroupIndexConfig {\n\t\t\t\treindex_interval: Duration::from_millis(50),\n\t\t\t},\n\t\t\t..Default::default()\n\t\t},\n\t\tSchema::with_objects(vec![Object {\n\t\t\tname: \"test-object\".to_string(),\n\t\t\tclass_id: 2003,\n\t\t\townership: Ownership::Detached,\n\t\t\tlifetime: schema::Lifetime::Owner,\n\t\t\tblend: schema::Blend::default(),\n\t\t\t..Default::default()\n\t\t}])?,\n\t))\n\t.await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\tlet mut client3 = server.new_session().await?;\n\n\t// same scenario as above, where two clients are updating\n\t// the same object very rapidly, but one is much much closer\n\t// to the object, so that even halving its score because of\n\t// continuity, it still has a higher score than the other client\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3d((1.0f64, 2.0f64, 3.0f64)),\n\t);\n\n\tlet object_id = client1.derive_global_id(51);\n\n\tupdate.object(object_id).attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3d((49810.0f64, 3219.0f64, 3.0f64)),\n\t);\n\n\tupdate\n\t\t.object(object_id)\n\t\t.attributes\n\t\t.insert(WellKnownAttribute::ClassId as u16, Value::Uint32(2003));\n\n\tupdate\n\t\t.object(object_id)\n\t\t.attributes\n\t\t.insert(200, Value::Uint32(100));\n\tclient1.roundtrip(update).await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3d((49800.0f64, 3200.0f64, 4.0f64)),\n\t);\n\tupdate\n\t\t.object(object_id)\n\t\t.attributes\n\t\t.insert(200, Value::Uint32(999));\n\tclient2.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3d((3.0f64, 3.0f64, 4.0f64)),\n\t);\n\tlet resp3 = client3.roundtrip(update).await?;\n\n\tassert_eq!(resp3.players.len(), 2);\n\tassert_eq!(resp3.objects.len(), 1);\n\tassert_eq!(resp3.events.len(), 0);\n\n\t// classid, position, and the attribute\n\tassert_eq!(resp3.objects[\u0026object_id].attributes.len(), 3);\n\tassert_eq!(\n\t\tresp3.objects[\u0026object_id].attributes[\u0026200],\n\t\tValue::Uint32(999) // client 2 update should go through\n\t);\n\n\tOk(())\n}\n\n/// This test ensures that if an object has a spec with an owner authority\n/// that only the owner is allowed to update the object.\n#[tokio::test]\nasync fn object_owner_authority_set_in_spec() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::new(ServerOptions::with_profile_and_schema(\n\t\tProfile {\n\t\t\tspatial_index: SpatialIndexConfig {\n\t\t\t\tmax_radius: 100,\n\t\t\t\tmap_width: 100000,\n\t\t\t\tmap_height: 100000,\n\t\t\t\tcells_count_x: 100,\n\t\t\t\tcells_count_y: 100,\n\t\t\t\treindex_interval: Duration::from_millis(50),\n\t\t\t},\n\t\t\t..Default::default()\n\t\t},\n\t\tSchema::with_objects(vec![\n\t\t\t// one object has owner authority\n\t\t\tObject {\n\t\t\t\tname: \"test-object\".to_string(),\n\t\t\t\tclass_id: 2003,\n\t\t\t\townership: Ownership::Creator,\n\t\t\t\tlifetime: schema::Lifetime::Owner,\n\t\t\t\tblend: schema::Blend::Owner,\n\t\t\t\t..Default::default()\n\t\t\t},\n\t\t\t// and the other has shared authority\n\t\t\tObject {\n\t\t\t\tname: \"test-object2\".to_string(),\n\n\t\t\t\tclass_id: 2004,\n\t\t\t\townership: Ownership::Creator,\n\t\t\t\tlifetime: schema::Lifetime::Owner,\n\t\t\t\tblend: schema::Blend::default(),\n\t\t\t\t..Default::default()\n\t\t\t},\n\t\t])?,\n\t))\n\t.await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\tlet mut client3 = server.new_session().await?;\n\n\tlet object1_id = client1.derive_global_id(51);\n\tlet object2_id = client1.derive_global_id(52);\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tupdate\n\t\t.object(object1_id)\n\t\t.attributes\n\t\t.insert(WellKnownAttribute::ClassId as u16, Value::Uint16(2003));\n\n\tupdate\n\t\t.object(object1_id)\n\t\t.attributes\n\t\t.insert(1002, Value::Uint64(1234));\n\n\tupdate\n\t\t.object(object2_id)\n\t\t.attributes\n\t\t.insert(WellKnownAttribute::ClassId as u16, Value::Uint16(2004));\n\tupdate\n\t\t.object(object2_id)\n\t\t.attributes\n\t\t.insert(1002, Value::Uint64(4321));\n\n\tclient1.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((2.0, 3.0, 4.0)),\n\t);\n\tlet resp2 = client2.roundtrip(update).await?;\n\n\tassert_eq!(resp2.players.len(), 1);\n\tassert_eq!(resp2.objects.len(), 2);\n\tassert_eq!(resp2.events.len(), 0);\n\tassert_eq!(\n\t\tresp2.objects[\u0026object1_id].attributes[\u00261002],\n\t\tValue::Uint64(1234)\n\t);\n\tassert_eq!(\n\t\tresp2.objects[\u0026object1_id].attributes\n\t\t\t[\u0026(WellKnownAttribute::OwnerId as u16)],\n\t\tValue::Uint32(client1.id())\n\t);\n\n\tassert_eq!(\n\t\tresp2.objects[\u0026object2_id].attributes[\u00261002],\n\t\tValue::Uint64(4321)\n\t);\n\tassert_eq!(\n\t\tresp2.objects[\u0026object2_id].attributes\n\t\t\t[\u0026(WellKnownAttribute::OwnerId as u16)],\n\t\tValue::Uint32(client1.id())\n\t);\n\n\t// wait a bit for the relevance of the last update to decay.\n\ttokio::time::sleep(std::time::Duration::from_millis(700)).await;\n\n\t// now client 2 will try updating both objects but only one\n\t// update should go through, for the object with shared authority\n\n\tlet mut update = TickUpdate::default();\n\tupdate\n\t\t.object(object1_id)\n\t\t.attributes\n\t\t.insert(1002, Value::Uint64(9999));\n\tupdate\n\t\t.object(object2_id)\n\t\t.attributes\n\t\t.insert(1002, Value::Uint64(9997));\n\n\tclient2.roundtrip(update).await?;\n\n\tlet resp1 = client1.pull().await?;\n\n\t// only the object with shared authority should have been updated\n\tassert_eq!(resp1.players.len(), 1);\n\tassert_eq!(resp1.objects.len(), 1);\n\tassert_eq!(resp1.events.len(), 0);\n\tassert_eq!(\n\t\tresp1.objects[\u0026object2_id].attributes[\u00261002],\n\t\tValue::Uint64(9997)\n\t);\n\n\t// now client3 should see object1 with the old value and object2 with the new\n\t// value\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((3.0, 3.0, 4.0)),\n\t);\n\tlet resp3 = client3.roundtrip(update).await?;\n\n\tassert_eq!(resp3.players.len(), 2);\n\tassert_eq!(resp3.objects.len(), 2);\n\tassert_eq!(resp3.events.len(), 0);\n\n\tassert_eq!(\n\t\tresp3.objects[\u0026object1_id].attributes[\u00261002],\n\t\tValue::Uint64(1234)\n\t);\n\n\tassert_eq!(\n\t\tresp3.objects[\u0026object2_id].attributes[\u00261002],\n\t\tValue::Uint64(9997)\n\t);\n\n\t// client1 should be able to update its owned object1\n\tlet mut update = TickUpdate::default();\n\tupdate\n\t\t.object(object1_id)\n\t\t.attributes\n\t\t.insert(1002, Value::Uint64(9998));\n\tclient1.roundtrip(update).await?;\n\n\tlet resp3 = client3.pull().await?;\n\tassert_eq!(resp3.players.len(), 0);\n\tassert_eq!(resp3.objects.len(), 1);\n\tassert_eq!(resp3.events.len(), 0);\n\n\tassert_eq!(\n\t\tresp3.objects[\u0026object1_id].attributes[\u00261002],\n\t\tValue::Uint64(9998)\n\t);\n\n\tOk(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","tests","blend.rs"],"content":"use {\n\tcrate::{\n\t\tobjects::{AverageMethod, AverageParams},\n\t\topts::ServerOptions,\n\t\tschema::{self, Attribute, Object, Ownership, Schema},\n\t\ttests::mock::{MockServer, SessionTestExt, TickUpdate},\n\t},\n\tfutures::future::join_all,\n\tquark_client_sdk::{\n\t\tAttributeId,\n\t\tAttributeType,\n\t\tSession,\n\t\tValue,\n\t\tWellKnownAttribute,\n\t},\n\tstd::{array, time::Duration},\n};\n\nasync fn blend_test_baseline\u003cconst N: usize\u003e(\n\tparams: AverageParams,\n\tupdates: [(f32, f32, f32); N],\n\texpected: (f32, f32, f32),\n) -\u003e anyhow::Result\u003c()\u003e {\n\tassert!(N \u003e= 2);\n\tlet server =\n\t\tMockServer::new(ServerOptions::with_schema(Schema::with_objects(vec![\n\t\t\tObject {\n\t\t\t\tname: \"test-object\".to_string(),\n\t\t\t\tclass_id: 2003,\n\t\t\t\townership: Ownership::Creator,\n\t\t\t\tlifetime: schema::Lifetime::Owner,\n\t\t\t\tattributes: vec![Attribute {\n\t\t\t\t\tname: \"Position\".to_string(),\n\t\t\t\t\tkey: 1,\n\t\t\t\t\tstream: false,\n\t\t\t\t\tblend: schema::Blend::Average(params),\n\t\t\t\t\tr#type: Some(AttributeType::Vec3),\n\t\t\t\t}],\n\t\t\t\t..Default::default()\n\t\t\t},\n\t\t])?))\n\t\t.await?;\n\n\tlet clients: [_; N] = array::from_fn(|_| {\n\t\tserver\n\t\t\t.build_session()\n\t\t\t.with_interval(Duration::from_millis(30))\n\t\t\t.build()\n\t});\n\n\tlet mut clients: Vec\u003cSession\u003e = join_all(clients)\n\t\t.await\n\t\t.into_iter()\n\t\t.collect::\u003cResult\u003c_, _\u003e\u003e()?;\n\n\t// make all clients spatially relevant to each other\n\t// so that they receive updates from each other\n\tfor client in clients.iter_mut() {\n\t\tlet mut update = TickUpdate::default();\n\t\tupdate.player.attributes.insert(\n\t\t\tWellKnownAttribute::Position as AttributeId,\n\t\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t\t);\n\t\tclient.push(update).await?;\n\t}\n\n\t// for for spatial reindexing to kick in.\n\tserver.wait_for_spatial_reindex().await;\n\n\t// create the shared object\n\tlet objid = clients[0].derive_global_id(12);\n\tlet mut update = TickUpdate::default();\n\tupdate.object(objid).attributes.insert(\n\t\tWellKnownAttribute::ClassId as AttributeId,\n\t\tValue::Uint64(2003),\n\t);\n\tupdate.object(objid).attributes.insert(\n\t\tWellKnownAttribute::Position as AttributeId,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tclients[0].push(update).await?;\n\n\t// time barrier\n\tserver.wait_for_spatial_reindex().await;\n\n\t// send competing updates\n\tfor (value, client) in updates.iter().zip(clients.iter_mut()) {\n\t\tlet mut update = TickUpdate::default();\n\t\tupdate.object(objid).attributes.insert(\n\t\t\tWellKnownAttribute::Position as AttributeId,\n\t\t\tValue::Vec3(*value),\n\t\t);\n\t\tclient.push(update).await?;\n\t}\n\n\t// time barrier\n\tserver.wait_for_spatial_reindex().await;\n\n\t// ensure that we averaged correctly\n\tlet resp1 = clients[1].pull().await?;\n\tassert_eq!(resp1.objects.len(), 1);\n\tassert_eq!(\n\t\tresp1.objects[\u0026objid].attributes.len(),\n\t\t3,\n\t\t\"{:?}\",\n\t\tresp1.objects[\u0026objid].attributes\n\t);\n\tassert_eq!(\n\t\tresp1.objects[\u0026objid].attributes\n\t\t\t[\u0026(WellKnownAttribute::OwnerId as AttributeId)],\n\t\tValue::Uint32(clients[0].id())\n\t);\n\tassert_eq!(\n\t\tresp1.objects[\u0026objid].attributes\n\t\t\t[\u0026(WellKnownAttribute::ClassId as AttributeId)],\n\t\tValue::Uint64(2003)\n\t);\n\tassert_eq!(\n\t\tresp1.objects[\u0026objid].attributes\n\t\t\t[\u0026(WellKnownAttribute::Position as AttributeId)],\n\t\tValue::Vec3(expected)\n\t);\n\n\tOk(())\n}\n\n#[ignore]\n#[tokio::test]\nasync fn blend_average_mode_smoke() -\u003e anyhow::Result\u003c()\u003e {\n\tblend_test_baseline(\n\t\tAverageParams {\n\t\t\tperiod: Duration::from_secs(1),\n\t\t\tsamples: 5,\n\t\t\tmethod: AverageMethod::Mode,\n\t\t},\n\t\t[\n\t\t\t(4.0, 5.0, 6.0),\n\t\t\t(1.5, 2.5, 3.5),\n\t\t\t(25.0, 35.0, 45.0),\n\t\t\t(3.2, 1.4, 5.8),\n\t\t\t(25.0, 35.0, 45.0),\n\t\t],\n\t\t(25.0, 35.0, 45.0),\n\t)\n\t.await\n}\n\n#[ignore]\n#[tokio::test]\nasync fn blend_average_mean_smoke() -\u003e anyhow::Result\u003c()\u003e {\n\tblend_test_baseline(\n\t\tAverageParams {\n\t\t\tperiod: Duration::from_secs(1),\n\t\t\tsamples: 3,\n\t\t\tmethod: AverageMethod::Mean,\n\t\t},\n\t\t[(4.0, 4.0, 2.0), (2.0, 3.0, 4.0), (6.0, 5.0, 6.0)],\n\t\t(4.0, 4.0, 4.0),\n\t)\n\t.await\n}\n\n#[ignore]\n#[tokio::test]\nasync fn blend_average_median_smoke() -\u003e anyhow::Result\u003c()\u003e {\n\tblend_test_baseline(\n\t\tAverageParams {\n\t\t\tperiod: Duration::from_secs(1),\n\t\t\tsamples: 3,\n\t\t\tmethod: AverageMethod::Median,\n\t\t},\n\t\t[(1.5, 2.5, 3.5), (200.0, 300.0, 400.0), (6.0, 5.0, 6.0)],\n\t\t(6.0, 5.0, 6.0),\n\t)\n\t.await\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","tests","despawn.rs"],"content":"use {\n\tcrate::{\n\t\topts::{Profile, ServerOptions},\n\t\trelevance::SpatialIndexConfig,\n\t\tschema::{self, Object, Ownership, Schema},\n\t\tstate::{entity::AttributeId, object::ObjectId, EntityId},\n\t\ttests::mock::{MockServer, SessionTestExt, TickUpdate},\n\t},\n\tquark_client_sdk::{\n\t\tprotocol::{events::SystemEvents, WellKnownAttribute},\n\t\tOutboundEvent,\n\t\tRecipient,\n\t\tValue,\n\t},\n\tstd::{mem::size_of, time::Duration},\n};\n\n/// Ensure that events in the system reserved range are not propagated.\n\n#[tokio::test]\nasync fn reserved_range_event_ignore() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::default().await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tclient1.roundtrip(update).await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((2.0, 3.0, 4.0)),\n\t);\n\tclient2.roundtrip(update).await?;\n\n\t// wait for spacial index to reindex players so they become relevant to each\n\t// other and app-level events are propagated\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.events.push(OutboundEvent {\n\t\tclass: 500,\n\t\tpayload: [1, 2, 3, 4, 5, 6, 7, 8, 9, 0][..].try_into().unwrap(),\n\t\trecipient: Recipient::default(),\n\t});\n\tclient1.roundtrip(update).await?;\n\n\tlet resp1 = client1.pull().await?;\n\tlet resp2 = client2.pull().await?;\n\n\tassert!(resp1.events.is_empty());\n\tassert!(resp2.events.is_empty());\n\n\tOk(())\n}\n\n/// Tests that an object despawn event is propagated to a relevant player.\n\n#[tokio::test]\nasync fn despawn_event_propagation_smoke() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::default().await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\tlet mut client3 = server.new_session().await?;\n\n\t// create client3 that will not be aware of the object, because its update\n\t// was sent before client 1 creates an object.\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((90000.0, 2.0, 3.0)),\n\t);\n\tclient3.push(update).await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\n\tlet objectid = client1.derive_global_id(1);\n\tupdate.object(objectid).attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((10.0, 2.0, 3.0)),\n\t);\n\tclient1.push(update).await?;\n\n\t// wait for spacial index to reindex players so they become relevant to each\n\t// other and app-level events are propagated\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1000.0, 1000.0, 4.0)),\n\t);\n\n\tlet pre2 = client2.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\t// client3 is far enough to not be aware of the object\n\tassert!(client3.pull().await?.objects.is_empty());\n\n\t// get latest state of the world from the server for client 2\n\tlet mut client2_response = client2.pull().await?;\n\n\tclient2_response.players.extend(pre2.players);\n\tclient2_response.objects.extend(pre2.objects);\n\tclient2_response.events.extend(pre2.events);\n\n\t// ensure that client 2 can see the object created by client 1\n\t// and the server will now know that client 2 is aware about the object\n\tassert_eq!(client2_response.players.len(), 1);\n\tassert_eq!(client2_response.objects.len(), 1);\n\tassert_eq!(client2_response.objects[\u0026objectid].id, objectid);\n\tassert_eq!(\n\t\tclient2_response.objects[\u0026objectid].attributes\n\t\t\t[\u0026(WellKnownAttribute::Position as AttributeId)],\n\t\tValue::Vec3((10.0, 2.0, 3.0))\n\t);\n\n\tlet mut update = TickUpdate::default();\n\tupdate.events.push(OutboundEvent {\n\t\tclass: SystemEvents::ObjectsDespawned as u16,\n\t\tpayload: objectid.to_le_bytes()[..].try_into().unwrap(),\n\t\trecipient: Recipient::default(),\n\t});\n\n\t// this despawn event should be propagated\n\t// because client 2 is aware about the object\n\tclient1.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\t// client2 should have received the despawn event\n\tlet client2_response = client2.pull().await?;\n\tassert_eq!(client2_response.events.len(), 1);\n\tassert_eq!(\n\t\tclient2_response.events[0].class,\n\t\tSystemEvents::ObjectsDespawned as u16\n\t);\n\tassert_eq!(client2_response.events[0].sender, EntityId::SYSTEM_PLAYER);\n\tassert_eq!(\n\t\tclient2_response.events[0].payload[..],\n\t\tobjectid.to_le_bytes()[..]\n\t);\n\n\t// client3 should not have received the despawn event\n\t// or any info about the object because it was never aware of it.\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((7.0, 2.0, 3.0)),\n\t);\n\n\tlet client3_response = client3.roundtrip(update).await?;\n\tassert!(client3_response.events.is_empty());\n\tassert!(client3_response.objects.is_empty());\n\tassert_eq!(client3_response.players.len(), 2);\n\n\tOk(())\n}\n\n#[tokio::test]\nasync fn despawn_event_propagation_aware_notify() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::default().await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tclient1.roundtrip(update).await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((2.0, 3.0, 4.0)),\n\t);\n\n\tlet pre_state2 = client2.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\t// now both clients are aware about each other\n\t// no objects were created yet.\n\tlet state2 = client2.pull().await?;\n\tassert!(state2.objects.is_empty());\n\tassert_eq!(state2.players.len() + pre_state2.players.len(), 1);\n\n\t// client1 creates a new objects\n\tlet objectid = client1.derive_global_id(1);\n\tlet mut update = TickUpdate::default();\n\tupdate.object(objectid).attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((10.0, 2.0, 3.0)),\n\t);\n\tclient1.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\t// client2 should have received the object\n\tlet state2 = client2.pull().await?;\n\tassert_eq!(state2.objects.len(), 1);\n\tassert_eq!(state2.objects[\u0026objectid].id, objectid);\n\tassert_eq!(\n\t\tstate2.objects[\u0026objectid].attributes\n\t\t\t[\u0026(WellKnownAttribute::Position as AttributeId)],\n\t\tValue::Vec3((10.0, 2.0, 3.0))\n\t);\n\n\t// client2 moves far away and stops being relevant\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((90000.0, 2.0, 3.0)),\n\t);\n\tclient2.roundtrip(update).await?;\n\n\t// client1 updates the object\n\tlet mut update = TickUpdate::default();\n\tupdate.object(objectid).attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((20.0, 2.0, 3.0)),\n\t);\n\tclient1.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\t// client2 should not have received the object update\n\t// because it is not relevant anymore\n\tlet state2 = client2.pull().await?;\n\tassert_eq!(state2.objects.len(), 0);\n\n\t// client2 moves back and becomes relevant again\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((2.0, 3.0, 4.0)),\n\t);\n\tclient2.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\t// client2 should have received the object update\n\tlet state2 = client2.pull().await?;\n\n\tassert_eq!(state2.objects.len(), 1);\n\tassert_eq!(state2.objects[\u0026objectid].id, objectid);\n\tassert_eq!(\n\t\tstate2.objects[\u0026objectid].attributes\n\t\t\t[\u0026(WellKnownAttribute::Position as AttributeId)],\n\t\tValue::Vec3((20.0, 2.0, 3.0))\n\t);\n\n\t// client2 moves far away again\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((90000.0, 2.0, 3.0)),\n\t);\n\n\tlet state2 = client2.roundtrip(update).await?;\n\tassert!(state2.objects.is_empty());\n\n\tserver.wait_for_spatial_reindex().await;\n\n\t// client1 updates the object again\n\tlet mut update = TickUpdate::default();\n\tupdate.object(objectid).attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((30.0, 2.0, 3.0)),\n\t);\n\tclient1.roundtrip(update).await?;\n\n\t// client2 should not have received the object update\n\t// because it is not relevant anymore\n\tlet state2 = client2.pull().await?;\n\tassert_eq!(state2.objects.len(), 0);\n\n\t// client1 despawns the object\n\tlet mut update = TickUpdate::default();\n\tupdate.events.push(OutboundEvent {\n\t\tclass: SystemEvents::ObjectsDespawned as u16,\n\t\tpayload: objectid.to_le_bytes()[..].try_into().unwrap(),\n\t\trecipient: Recipient::default(),\n\t});\n\n\tclient1.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\t// client2 should have received the despawn event\n\tlet state2 = client2.pull().await?;\n\tassert_eq!(state2.objects.len(), 0);\n\tassert_eq!(state2.events.len(), 1);\n\tassert_eq!(\n\t\tstate2.events[0].class,\n\t\tSystemEvents::ObjectsDespawned as u16\n\t);\n\tassert_eq!(state2.events[0].sender, EntityId::SYSTEM_PLAYER);\n\tassert_eq!(state2.events[0].payload[..], objectid.to_le_bytes()[..]);\n\n\t// client2 moves close again\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((2.0, 3.0, 4.0)),\n\t);\n\tclient2.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\t// client2 should not have received the object update\n\t// because it is has been despawned\n\tlet state2 = client2.pull().await?;\n\tassert_eq!(state2.objects.len(), 0);\n\n\tOk(())\n}\n\n#[tokio::test]\nasync fn despawn_event_batching() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::default().await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tupdate\n\t\t.object(client1.derive_global_id(1))\n\t\t.attributes\n\t\t.insert(\n\t\t\tWellKnownAttribute::Position as u16,\n\t\t\tValue::Vec3((10.0, 2.0, 3.0)),\n\t\t);\n\n\tupdate\n\t\t.object(client1.derive_global_id(2))\n\t\t.attributes\n\t\t.insert(\n\t\t\tWellKnownAttribute::Position as u16,\n\t\t\tValue::Vec3((12.0, 2.0, 3.0)),\n\t\t);\n\n\tupdate\n\t\t.object(client1.derive_global_id(3))\n\t\t.attributes\n\t\t.insert(\n\t\t\tWellKnownAttribute::Position as u16,\n\t\t\tValue::Vec3((14.0, 2.0, 3.0)),\n\t\t);\n\tclient1.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((2.0, 3.0, 4.0)),\n\t);\n\tlet resp2 = client2.roundtrip(update).await?;\n\n\tassert_eq!(resp2.objects.len(), 3);\n\n\tlet combined_ids: Vec\u003cu8\u003e = client1\n\t\t.derive_global_id(1)\n\t\t.to_le_bytes()\n\t\t.into_iter()\n\t\t.chain(client1.derive_global_id(2).to_le_bytes())\n\t\t.collect();\n\n\t// despawn object 1 and 2 in one event\n\tlet mut update = TickUpdate::default();\n\tupdate.events.push(OutboundEvent {\n\t\tclass: SystemEvents::ObjectsDespawned as u16,\n\t\tpayload: combined_ids[..].try_into().unwrap(),\n\t\trecipient: Recipient::default(),\n\t});\n\n\t// despawn object 3 in another event\n\tupdate.events.push(OutboundEvent {\n\t\tclass: SystemEvents::ObjectsDespawned as u16,\n\t\tpayload: client1.derive_global_id(3).to_le_bytes()[..]\n\t\t\t.try_into()\n\t\t\t.unwrap(),\n\t\trecipient: Recipient::default(),\n\t});\n\tclient1.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet resp2 = client2.pull().await?;\n\tassert_eq!(resp2.objects.len(), 0);\n\tassert_eq!(resp2.events.len(), 1);\n\n\t// all three objects should be despawned in one event\n\tassert_eq!(\n\t\tresp2.events[0].payload[..],\n\t\tclient1\n\t\t\t.derive_global_id(1)\n\t\t\t.to_le_bytes()\n\t\t\t.into_iter()\n\t\t\t.chain(client1.derive_global_id(2).to_le_bytes())\n\t\t\t.chain(client1.derive_global_id(3).to_le_bytes())\n\t\t\t.collect::\u003cVec\u003c_\u003e\u003e()[..]\n\t);\n\n\tOk(())\n}\n\n#[tokio::test]\nasync fn disconnect_event_smoke() -\u003e anyhow::Result\u003c()\u003e {\n\t// create a server with a short resume timeout\n\tlet server = MockServer::new(ServerOptions::with_profile(Profile {\n\t\tresume_timeout: Duration::from_millis(100),\n\t\t..Default::default()\n\t}))\n\t.await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\tlet mut client3 = server.new_session().await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\n\tlet resp_pre_1 = client1.roundtrip(update).await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((2.0, 2.0, 3.0)),\n\t);\n\tlet resp_pre_2 = client2.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet resp1 = client1.pull().await?;\n\tlet resp2 = client2.pull().await?;\n\n\tassert_eq!(resp1.players.len() + resp_pre_1.players.len(), 1);\n\tassert!(resp1.events.is_empty());\n\n\tassert_eq!(resp2.players.len() + resp_pre_2.players.len(), 1);\n\tassert!(resp2.events.is_empty());\n\n\tlet client1_id = client1.id().to_le_bytes();\n\tdrop(client1);\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet resp2 = client2.pull().await?;\n\n\tassert_eq!(resp2.players.len(), 0);\n\tassert_eq!(resp2.events.len(), 1);\n\tassert_eq!(\n\t\tresp2.events[0].class,\n\t\tSystemEvents::PlayerDisconnected as u16\n\t);\n\tassert_eq!(resp2.events[0].sender, EntityId::SYSTEM_PLAYER);\n\tassert_eq!(resp2.events[0].payload[..], client1_id[..]);\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\n\tlet resp3 = client3.roundtrip(update).await?;\n\n\tassert_eq!(resp3.players.len(), 1);\n\tassert!(resp3.events.is_empty());\n\n\tOk(())\n}\n\n#[tokio::test]\nasync fn despawn_authority() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::new(ServerOptions::with_profile(Profile {\n\t\tspatial_index: SpatialIndexConfig {\n\t\t\tmax_radius: 100,\n\t\t\tmap_width: 100000,\n\t\t\tmap_height: 100000,\n\t\t\tcells_count_x: 100,\n\t\t\tcells_count_y: 100,\n\t\t\treindex_interval: Duration::from_millis(150),\n\t\t},\n\n\t\t..Default::default()\n\t}))\n\t.await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\n\tlet object_id = client1.derive_global_id(51);\n\n\tupdate.object(object_id).attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((10.0, 2.0, 3.0)),\n\t);\n\n\tupdate\n\t\t.object(object_id)\n\t\t.attributes\n\t\t.insert(200, Value::Uint32(100));\n\n\tclient1.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((2.0, 3.0, 4.0)),\n\t);\n\n\tlet resp2 = client2.roundtrip(update).await?;\n\n\tassert_eq!(resp2.players.len(), 1);\n\tassert_eq!(resp2.objects.len(), 1);\n\tassert_eq!(resp2.events.len(), 0);\n\tassert_eq!(\n\t\tresp2.objects[\u0026object_id].attributes[\u0026200],\n\t\tValue::Uint32(100)\n\t);\n\n\tserver.wait_for_spatial_reindex().await;\n\n\t// wait for some time to have time decay applied to\n\t// the last update score\n\ttokio::time::sleep(Duration::from_millis(800)).await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.events.push(OutboundEvent {\n\t\tclass: SystemEvents::ObjectsDespawned as u16,\n\t\tpayload: object_id.to_le_bytes()[..].try_into().unwrap(),\n\t\trecipient: Recipient::default(),\n\t});\n\tclient2.roundtrip(update).await?;\n\n\t// wait for the server to process the event\n\tserver.wait_for_spatial_reindex().await;\n\ttokio::time::sleep(Duration::from_secs(1)).await;\n\n\t// client1 should receive the despawn event\n\tlet resp1 = client1.pull().await?;\n\n\tassert_eq!(resp1.events.len(), 1);\n\tassert_eq!(resp1.events[0].class, SystemEvents::ObjectsDespawned as u16);\n\tassert_eq!(resp1.events[0].sender, EntityId::SYSTEM_PLAYER);\n\tassert_eq!(resp1.events[0].payload[..], object_id.to_le_bytes()[..]);\n\n\tOk(())\n}\n\n/// When an object has it's lifetime bound to the owner, it should be despawned\n/// when the owner disconnects.\n#[tokio::test]\nasync fn object_despawned_when_owner_despawns() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server =\n\t\tMockServer::new(ServerOptions::with_schema(Schema::with_objects(vec![\n\t\t\tObject {\n\t\t\t\tname: \"test-object\".to_string(),\n\n\t\t\t\tclass_id: 2003,\n\t\t\t\townership: Ownership::Creator,\n\t\t\t\tlifetime: schema::Lifetime::Owner,\n\t\t\t\tblend: schema::Blend::default(),\n\t\t\t\t..Default::default()\n\t\t\t},\n\t\t\tObject {\n\t\t\t\tname: \"test-object2\".to_string(),\n\n\t\t\t\tclass_id: 2004,\n\t\t\t\tlifetime: schema::Lifetime::Owner,\n\t\t\t\tblend: schema::Blend::default(),\n\t\t\t\t..Default::default()\n\t\t\t},\n\t\t])?))\n\t\t.await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\n\tlet client1id = client1.id();\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\n\tlet object1id = client1.derive_global_id(1);\n\tlet object2id = client1.derive_global_id(2);\n\tlet object3id = client1.derive_global_id(3);\n\n\tupdate\n\t\t.object(object1id)\n\t\t.attributes\n\t\t.insert(WellKnownAttribute::ClassId as u16, Value::Uint64(2003));\n\n\tupdate.object(object2id).attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\n\tupdate\n\t\t.object(object3id)\n\t\t.attributes\n\t\t.insert(WellKnownAttribute::ClassId as u16, Value::Uint64(2004));\n\n\tupdate\n\t\t.object(object3id)\n\t\t.attributes\n\t\t.insert(WellKnownAttribute::OwnerId as u16, Value::Uint64(object2id));\n\n\tclient1.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tlet resp2 = client2.roundtrip(update).await?;\n\n\tassert_eq!(resp2.players.len(), 1);\n\tassert_eq!(resp2.objects.len(), 3);\n\n\tassert_eq!(resp2.players[\u0026client1.id()].attributes.len(), 1);\n\tassert_eq!(resp2.objects[\u0026object1id].attributes.len(), 2);\n\n\tassert_eq!(\n\t\tresp2.objects[\u0026object1id].attributes[\u0026(WellKnownAttribute::OwnerId as u16)],\n\t\tValue::Uint32(client1.id())\n\t);\n\n\tassert_eq!(\n\t\tresp2.objects[\u0026object1id].attributes[\u0026(WellKnownAttribute::ClassId as u16)],\n\t\tValue::Uint64(2003)\n\t);\n\n\t// position, owner, class id\n\tassert_eq!(resp2.objects[\u0026object2id].attributes.len(), 2);\n\tassert_eq!(\n\t\tresp2.objects[\u0026object2id].attributes\n\t\t\t[\u0026(WellKnownAttribute::Position as u16)],\n\t\tValue::Vec3((1.0, 2.0, 3.0))\n\t);\n\tassert_eq!(\n\t\tresp2.objects[\u0026object2id].attributes[\u0026(WellKnownAttribute::OwnerId as u16)],\n\t\tValue::Uint32(client1.id())\n\t);\n\n\tassert_eq!(resp2.objects[\u0026object3id].attributes.len(), 2);\n\tassert_eq!(\n\t\tresp2.objects[\u0026object3id].attributes[\u0026(WellKnownAttribute::ClassId as u16)],\n\t\tValue::Uint64(2004)\n\t);\n\n\tassert_eq!(\n\t\tresp2.objects[\u0026object3id].attributes[\u0026(WellKnownAttribute::OwnerId as u16)],\n\t\tValue::Uint64(object2id)\n\t);\n\n\t// client 1 despawns object2, which owns object3\n\t// object3 should be despawned as well\n\tlet mut update = TickUpdate::default();\n\tupdate.events.push(OutboundEvent {\n\t\tclass: SystemEvents::ObjectsDespawned as u16,\n\t\tpayload: object2id.to_le_bytes()[..].try_into().unwrap(),\n\t\trecipient: Recipient::default(),\n\t});\n\n\tclient1.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet resp2 = client2.pull().await?;\n\n\tassert_eq!(resp2.events.len(), 1);\n\tassert_eq!(resp2.events[0].class, SystemEvents::ObjectsDespawned as u16);\n\tassert_eq!(resp2.events[0].sender, EntityId::SYSTEM_PLAYER);\n\n\tlet mut payload_ids: Vec\u003c_\u003e = resp2.events[0].payload[..]\n\t\t.chunks_exact(size_of::\u003cObjectId\u003e())\n\t\t.map(|chunk| ObjectId::from_le_bytes(chunk.try_into().unwrap()))\n\t\t.collect();\n\n\tassert_eq!(payload_ids.len(), 2);\n\n\tpayload_ids.sort();\n\tassert_eq!(payload_ids, vec![object2id, object3id]);\n\n\t// clien1 disconnects\n\tdrop(client1);\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut resp2 = client2.pull().await?;\n\n\tresp2.events.sort_by_key(|e| e.class);\n\n\t// we should be notified about a client disconnect and an object despawn\n\tassert_eq!(resp2.players.len(), 0);\n\tassert_eq!(resp2.objects.len(), 0);\n\tassert_eq!(resp2.events.len(), 2);\n\n\tassert_eq!(resp2.events[0].sender, EntityId::SYSTEM_PLAYER);\n\tassert_eq!(\n\t\tresp2.events[0].class,\n\t\tself::SystemEvents::ObjectsDespawned as u16\n\t);\n\n\tassert_eq!(resp2.events[0].payload[..], object1id.to_le_bytes()[..]);\n\n\tassert_eq!(resp2.events[1].sender, EntityId::SYSTEM_PLAYER);\n\tassert_eq!(\n\t\tresp2.events[1].class,\n\t\tself::SystemEvents::PlayerDisconnected as u16\n\t);\n\tassert_eq!(resp2.events[1].payload[..], client1id.to_le_bytes()[..]);\n\n\tOk(())\n}\n\n/// When an object has it's lifetime bound to the owner, it should be despawned\n/// when the owner disconnects.\n#[tokio::test]\nasync fn object_despawned_after_timeout() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::new(ServerOptions::with_profile_and_schema(\n\t\tProfile {\n\t\t\tspatial_index: SpatialIndexConfig {\n\t\t\t\treindex_interval: Duration::from_millis(150),\n\t\t\t\t..Default::default()\n\t\t\t},\n\t\t\t..Default::default()\n\t\t},\n\t\tSchema::with_objects(vec![Object {\n\t\t\tname: \"test-object\".to_string(),\n\n\t\t\tclass_id: 2003,\n\t\t\townership: Ownership::Creator,\n\t\t\tlifetime: schema::Lifetime::Timeout(Duration::from_secs(2)),\n\t\t\tblend: schema::Blend::default(),\n\t\t\t..Default::default()\n\t\t}])?,\n\t))\n\t.await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\n\tlet obj1id = client1.derive_global_id(1);\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\n\tupdate\n\t\t.object(obj1id)\n\t\t.attributes\n\t\t.insert(WellKnownAttribute::ClassId as u16, Value::Uint64(2003));\n\n\tclient1.push(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((2.0, 3.0, 4.0)),\n\t);\n\tlet resp2 = client2.roundtrip(update).await?;\n\n\tassert_eq!(resp2.players.len(), 1);\n\tassert_eq!(resp2.objects.len(), 1);\n\tassert_eq!(resp2.objects[\u0026obj1id].attributes.len(), 2);\n\tassert_eq!(\n\t\tresp2.objects[\u0026obj1id].attributes[\u0026(WellKnownAttribute::ClassId as u16)],\n\t\tValue::Uint64(2003)\n\t);\n\tassert_eq!(\n\t\tresp2.objects[\u0026obj1id].attributes[\u0026(WellKnownAttribute::OwnerId as u16)],\n\t\tValue::Uint32(client1.id())\n\t);\n\n\ttokio::time::sleep(Duration::from_secs(3)).await;\n\n\tlet resp2 = client2.pull().await?;\n\n\tassert_eq!(resp2.objects.len(), 0);\n\tassert_eq!(resp2.events.len(), 1);\n\tassert_eq!(resp2.events[0].class, SystemEvents::ObjectsDespawned as u16);\n\tassert_eq!(resp2.events[0].sender, EntityId::SYSTEM_PLAYER);\n\tassert_eq!(resp2.events[0].payload[..], obj1id.to_le_bytes()[..]);\n\n\tlet resp1 = client1.pull().await?;\n\tassert_eq!(resp1.objects.len(), 0);\n\tassert_eq!(resp1.events.len(), 1);\n\tassert_eq!(resp1.events[0].class, SystemEvents::ObjectsDespawned as u16);\n\tassert_eq!(resp1.events[0].sender, EntityId::SYSTEM_PLAYER);\n\tassert_eq!(resp1.events[0].payload[..], obj1id.to_le_bytes()[..]);\n\n\tOk(())\n}\n\n/// When an object is bound to the owner, it should be despawned\n/// when the owner tries to do so and no other client can make it despawn.\n#[tokio::test]\nasync fn object_despawned_by_owner() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::new(ServerOptions::with_profile_and_schema(\n\t\tProfile {\n\t\t\tspatial_index: SpatialIndexConfig {\n\t\t\t\treindex_interval: Duration::from_millis(150),\n\t\t\t\t..Default::default()\n\t\t\t},\n\t\t\t..Default::default()\n\t\t},\n\t\tSchema::with_objects(vec![\n\t\t\tObject {\n\t\t\t\tname: \"test-object\".to_string(),\n\n\t\t\t\tclass_id: 2003,\n\t\t\t\townership: Ownership::Creator,\n\t\t\t\tlifetime: schema::Lifetime::Owner,\n\t\t\t\tblend: schema::Blend::Owner,\n\t\t\t\t..Default::default()\n\t\t\t},\n\t\t\tObject {\n\t\t\t\tname: \"test-object2\".to_string(),\n\n\t\t\t\tclass_id: 2004,\n\t\t\t\townership: Ownership::Detached,\n\t\t\t\tlifetime: schema::Lifetime::Owner,\n\t\t\t\tblend: schema::Blend::Owner,\n\t\t\t\t..Default::default()\n\t\t\t},\n\t\t])?,\n\t))\n\t.await?;\n\n\t// Creating two clients, out of which only client1 owns one of the\n\t// two objects\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\n\t// Creating two objects through schema, one of which is owned by the\n\t// client1 and the second one has its ownership detached\n\tlet obj1id = client1.derive_global_id(1);\n\tlet obj2id = client1.derive_global_id(2);\n\n\tlet mut update = TickUpdate::default();\n\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\n\tupdate\n\t\t.object(obj1id)\n\t\t.attributes\n\t\t.insert(WellKnownAttribute::ClassId as u16, Value::Uint64(2003));\n\tupdate\n\t\t.object(obj2id)\n\t\t.attributes\n\t\t.insert(WellKnownAttribute::ClassId as u16, Value::Uint64(2004));\n\n\tclient1.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((2.0, 3.0, 4.0)),\n\t);\n\tlet response = client2.roundtrip(update).await?;\n\n\tassert_eq!(response.players.len(), 1);\n\tassert_eq!(response.objects.len(), 1);\n\tassert_eq!(response.objects[\u0026obj1id].attributes.len(), 2);\n\tassert_eq!(\n\t\tresponse.objects[\u0026obj1id].attributes[\u0026(WellKnownAttribute::ClassId as u16)],\n\t\tValue::Uint64(2003)\n\t);\n\tassert_eq!(\n\t\tresponse.objects[\u0026obj1id].attributes[\u0026(WellKnownAttribute::OwnerId as u16)],\n\t\tValue::Uint32(client1.id())\n\t);\n\n\t// A case where the client two tries to despawn the object which\n\t// is not owned by anyone in the server. So no event should be received\n\tlet mut update = TickUpdate::default();\n\tupdate.events.push(OutboundEvent {\n\t\tclass: SystemEvents::ObjectsDespawned as u16,\n\t\tpayload: obj2id.to_le_bytes()[..].try_into().unwrap(),\n\t\trecipient: Recipient::default(),\n\t});\n\n\tclient2.roundtrip(update).await?;\n\tserver.wait_for_spatial_reindex().await;\n\n\t// Validating that no events received due to wrongful attempt  by the client2\n\tlet response = client1.pull().await?;\n\n\tassert_eq!(response.events.len(), 0);\n\n\t// Now the Client1 tries to despawn the object1 on which client1 has ownership\n\tlet mut update = TickUpdate::default();\n\tupdate.events.push(OutboundEvent {\n\t\tclass: SystemEvents::ObjectsDespawned as u16,\n\t\tpayload: obj1id.to_le_bytes()[..].try_into().unwrap(),\n\t\trecipient: Recipient::default(),\n\t});\n\n\tclient1.push(update).await?;\n\tserver.wait_for_spatial_reindex().await;\n\n\t// Validating that the object1 is despawned and the correct event is\n\t// propagated to client1\n\tlet response = client2.pull().await?;\n\n\tassert_eq!(response.events.len(), 1);\n\tassert_eq!(\n\t\tresponse.events[0].class,\n\t\tSystemEvents::ObjectsDespawned as u16\n\t);\n\tassert_eq!(response.events[0].sender, EntityId::SYSTEM_PLAYER);\n\tassert_eq!(response.events[0].payload[..], obj1id.to_le_bytes()[..]);\n\n\t// Validating that the object1 is despawned and the correct event is\n\t// propagated to client2\n\tlet response = client1.pull().await?;\n\n\tassert_eq!(response.events.len(), 1);\n\tassert_eq!(\n\t\tresponse.events[0].class,\n\t\tSystemEvents::ObjectsDespawned as u16\n\t);\n\tassert_eq!(response.events[0].sender, EntityId::SYSTEM_PLAYER);\n\tassert_eq!(response.events[0].payload[..], obj1id.to_le_bytes()[..]);\n\n\tOk(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","tests","entity.rs"],"content":"use {\n\tcrate::tests::mock::{MockServer, SessionTestExt, TickUpdate},\n\tquark_client_sdk::{Session, Value, WellKnownAttribute},\n\tstd::collections::HashMap,\n};\n\n#[tokio::test]\nasync fn single_player() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::default().await?;\n\n\tlet mut client1 = server.new_session().await?;\n\n\tlet mut update = TickUpdate::default();\n\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Rotation as u16,\n\t\tValue::Vec3((4.0, 5.0, 6.0)),\n\t);\n\n\tlet objectid = client1.derive_global_id(1);\n\tupdate.object(objectid).attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((10.0, 2.0, 3.0)),\n\t);\n\n\tupdate.object(objectid).attributes.insert(\n\t\tWellKnownAttribute::Rotation as u16,\n\t\tValue::Vec3((4.0, 5.0, 6.0)),\n\t);\n\n\tclient1.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet resp1 = client1.roundtrip(TickUpdate::default()).await?;\n\n\t// ensure that we don't get our own updates\n\tassert!(resp1.players.is_empty());\n\tassert!(resp1.objects.is_empty());\n\tassert!(resp1.events.is_empty());\n\n\tOk(())\n}\n\n#[tokio::test]\nasync fn multiple_players_and_objects_in_vicinity() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::default().await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\tlet mut client3 = server.new_session().await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Rotation as u16,\n\t\tValue::Vec3((4.0, 5.0, 6.0)),\n\t);\n\n\tlet objectid1 = client1.derive_global_id(1);\n\tupdate.object(objectid1).attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((10.0, 2.0, 3.0)),\n\t);\n\tupdate.object(objectid1).attributes.insert(\n\t\tWellKnownAttribute::Rotation as u16,\n\t\tValue::Vec3((4.0, 5.0, 6.0)),\n\t);\n\n\tlet pre1 = client1.roundtrip(update).await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((5.0, 2.0, 3.0)),\n\t);\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Rotation as u16,\n\t\tValue::Vec3((4.0, 5.0, 6.0)),\n\t);\n\n\tlet objectid2 = client2.derive_global_id(1);\n\tupdate.object(objectid2).attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((22.0, 2.0, 3.0)),\n\t);\n\tupdate.object(objectid2).attributes.insert(\n\t\tWellKnownAttribute::Rotation as u16,\n\t\tValue::Vec3((4.0, 5.0, 6.0)),\n\t);\n\n\tlet pre2 = client2.roundtrip(update).await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((20.0, 2.0, 3.0)),\n\t);\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Rotation as u16,\n\t\tValue::Vec3((4.0, 5.0, 6.0)),\n\t);\n\n\tlet objectid3 = client3.derive_global_id(1);\n\tupdate.object(objectid3).attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((24.0, 2.0, 3.0)),\n\t);\n\tupdate.object(objectid3).attributes.insert(\n\t\tWellKnownAttribute::Rotation as u16,\n\t\tValue::Vec3((4.0, 5.0, 6.0)),\n\t);\n\n\tlet pre3 = client3.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet objectid1 = client1.derive_global_id(1);\n\tlet objectid2 = client2.derive_global_id(1);\n\tlet objectid3 = client3.derive_global_id(1);\n\n\tlet client1id = client1.id();\n\tlet client2id = client2.id();\n\tlet client3id = client3.id();\n\n\tlet pres = [\n\t\t(client1id, pre1.clone()),\n\t\t(client2id, pre2.clone()),\n\t\t(client3id, pre3.clone()),\n\t]\n\t.iter()\n\t.cloned()\n\t.collect::\u003cHashMap\u003c_, _\u003e\u003e();\n\n\tlet ensure = |client: \u0026'static mut Session| async {\n\t\tlet mut resp = client.pull().await.unwrap();\n\t\tlet pre = pres[\u0026client.id()].clone();\n\n\t\t// merge pre and current updates\n\t\tresp\n\t\t\t.players\n\t\t\t.extend(pre.players.iter().map(|(k, v)| (*k, v.clone())));\n\n\t\tresp\n\t\t\t.objects\n\t\t\t.extend(pre.objects.iter().map(|(k, v)| (*k, v.clone())));\n\n\t\tresp.events.extend(pre.events.iter().cloned());\n\n\t\tassert_eq!(resp.players.len(), 2); // each player can see the other 2\n\t\tassert_eq!(resp.objects.len(), 2); // each player sees objects of others\n\t\tassert_eq!(resp.events.len(), 0);\n\n\t\tif client.id() != client1id {\n\t\t\tassert_eq!(resp.players[\u0026client1id].attributes.len(), 2);\n\t\t\tassert_eq!(\n\t\t\t\tresp.players[\u0026client1id].attributes\n\t\t\t\t\t[\u0026(WellKnownAttribute::Position as u16)],\n\t\t\t\tValue::Vec3((1.0, 2.0, 3.0))\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tresp.players[\u0026client1id].attributes\n\t\t\t\t\t[\u0026(WellKnownAttribute::Rotation as u16)],\n\t\t\t\tValue::Vec3((4.0, 5.0, 6.0))\n\t\t\t);\n\n\t\t\tassert_eq!(resp.objects[\u0026objectid1].attributes.len(), 3);\n\t\t\tassert_eq!(\n\t\t\t\tresp.objects[\u0026objectid1].attributes\n\t\t\t\t\t[\u0026(WellKnownAttribute::OwnerId as u16)],\n\t\t\t\tValue::Uint32(client1id)\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tresp.objects[\u0026objectid1].attributes\n\t\t\t\t\t[\u0026(WellKnownAttribute::Position as u16)],\n\t\t\t\tValue::Vec3((10.0, 2.0, 3.0))\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tresp.objects[\u0026objectid1].attributes\n\t\t\t\t\t[\u0026(WellKnownAttribute::Rotation as u16)],\n\t\t\t\tValue::Vec3((4.0, 5.0, 6.0))\n\t\t\t);\n\n\t\t\tif client.id() != client2id {\n\t\t\t\tassert_eq!(resp.objects[\u0026objectid2].attributes.len(), 3);\n\t\t\t\tassert_eq!(\n\t\t\t\t\tresp.objects[\u0026objectid2].attributes\n\t\t\t\t\t\t[\u0026(WellKnownAttribute::OwnerId as u16)],\n\t\t\t\t\tValue::Uint32(client2id)\n\t\t\t\t);\n\t\t\t\tassert_eq!(\n\t\t\t\t\tresp.objects[\u0026objectid2].attributes\n\t\t\t\t\t\t[\u0026(WellKnownAttribute::Position as u16)],\n\t\t\t\t\tValue::Vec3((22.0, 2.0, 3.0))\n\t\t\t\t);\n\t\t\t\tassert_eq!(\n\t\t\t\t\tresp.objects[\u0026objectid2].attributes\n\t\t\t\t\t\t[\u0026(WellKnownAttribute::Rotation as u16)],\n\t\t\t\t\tValue::Vec3((4.0, 5.0, 6.0))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif client.id() != client3id {\n\t\t\t\tassert_eq!(resp.objects[\u0026objectid3].attributes.len(), 3);\n\n\t\t\t\tassert_eq!(\n\t\t\t\t\tresp.objects[\u0026objectid3].attributes\n\t\t\t\t\t\t[\u0026(WellKnownAttribute::OwnerId as u16)],\n\t\t\t\t\tValue::Uint32(client3id)\n\t\t\t\t);\n\n\t\t\t\tassert_eq!(\n\t\t\t\t\tresp.objects[\u0026objectid3].attributes\n\t\t\t\t\t\t[\u0026(WellKnownAttribute::Position as u16)],\n\t\t\t\t\tValue::Vec3((24.0, 2.0, 3.0))\n\t\t\t\t);\n\t\t\t\tassert_eq!(\n\t\t\t\t\tresp.objects[\u0026objectid3].attributes\n\t\t\t\t\t\t[\u0026(WellKnownAttribute::Rotation as u16)],\n\t\t\t\t\tValue::Vec3((4.0, 5.0, 6.0))\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t};\n\n\tensure(unsafe {\n\t\tstd::mem::transmute::\u003c\n\t\t\t\u0026mut quark_client_sdk::Session,\n\t\t\t\u0026mut quark_client_sdk::Session,\n\t\t\u003e(\u0026mut client1)\n\t})\n\t.await;\n\tensure(unsafe {\n\t\tstd::mem::transmute::\u003c\n\t\t\t\u0026mut quark_client_sdk::Session,\n\t\t\t\u0026mut quark_client_sdk::Session,\n\t\t\u003e(\u0026mut client2)\n\t})\n\t.await;\n\tensure(unsafe {\n\t\tstd::mem::transmute::\u003c\n\t\t\t\u0026mut quark_client_sdk::Session,\n\t\t\t\u0026mut quark_client_sdk::Session,\n\t\t\u003e(\u0026mut client3)\n\t})\n\t.await;\n\n\tOk(())\n}\n\n#[tokio::test]\nasync fn delete_attribute() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::default().await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\tlet mut client3 = server.new_session().await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tupdate.player.attributes.insert(1002, Value::Uint32(989898));\n\tclient1.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((2.0, 3.0, 4.0)),\n\t);\n\tlet resp2 = client2.roundtrip(update).await?;\n\n\tassert_eq!(resp2.players[\u0026client1.id()].attributes.len(), 2);\n\tassert_eq!(\n\t\tresp2.players[\u0026client1.id()].attributes\n\t\t\t[\u0026(WellKnownAttribute::Position as u16)],\n\t\tValue::Vec3((1.0, 2.0, 3.0))\n\t);\n\tassert_eq!(\n\t\tresp2.players[\u0026client1.id()].attributes[\u00261002],\n\t\tValue::Uint32(989898)\n\t);\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(1002, Value::None);\n\tclient1.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\t// client 2 should see an update that the attribute is deleted\n\tlet resp2 = client2.pull().await?;\n\tassert_eq!(resp2.players[\u0026client1.id()].attributes.len(), 1);\n\tassert_eq!(resp2.players[\u0026client1.id()].attributes[\u00261002], Value::None);\n\n\t// client 3 that never got an update about the deleted attribute should\n\t// not receive any info about it\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((4.0, 5.0, 6.0)),\n\t);\n\tlet resp3 = client3.roundtrip(update).await?;\n\n\tassert_eq!(resp3.players.len(), 2);\n\tassert_eq!(resp3.players[\u0026client1.id()].attributes.len(), 1);\n\tassert_eq!(\n\t\tresp3.players[\u0026client1.id()].attributes\n\t\t\t[\u0026(WellKnownAttribute::Position as u16)],\n\t\tValue::Vec3((1.0, 2.0, 3.0))\n\t);\n\tassert_eq!(\n\t\tresp3.players[\u0026client2.id()].attributes\n\t\t\t[\u0026(WellKnownAttribute::Position as u16)],\n\t\tValue::Vec3((2.0, 3.0, 4.0)),\n\t);\n\n\t// client 1 sets the attribute value again\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(1002, Value::Uint32(8787));\n\tclient1.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet resp2 = client2.pull().await?;\n\tlet resp3 = client3.pull().await?;\n\n\t// now client 2 and 3 should see the attribute value again\n\tassert_eq!(\n\t\tresp2.players[\u0026client1.id()].attributes[\u00261002],\n\t\tValue::Uint32(8787)\n\t);\n\tassert_eq!(\n\t\tresp3.players[\u0026client1.id()].attributes[\u00261002],\n\t\tValue::Uint32(8787)\n\t);\n\n\tOk(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","tests","events.rs"],"content":"use {\n\tcrate::{\n\t\tstate::EntityId,\n\t\ttests::mock::{MockServer, SessionTestExt, TickUpdate},\n\t},\n\tquark_client_sdk::{\n\t\tEventsFilter,\n\t\tOutboundEvent,\n\t\tRecipient,\n\t\tRelevance,\n\t\tValue,\n\t\tWellKnownAttribute,\n\t},\n\tstd::time::Duration,\n};\n\n/// Tests that an application level event is propagated a relevant player.\n#[tokio::test]\nasync fn app_event_smoke() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::default().await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tclient1.roundtrip(update).await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((2.0, 3.0, 4.0)),\n\t);\n\tclient2.roundtrip(update).await?;\n\n\t// wait for spacial index to reindex players so they\n\t// become relevant to each other and app-level events are propagated\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.events.push(OutboundEvent {\n\t\tclass: 1500,\n\t\tpayload: [1, 2, 3, 4, 5, 6, 7, 8, 9, 0][..].try_into().unwrap(),\n\t\trecipient: Recipient::default(),\n\t});\n\tclient1.roundtrip(update).await?;\n\n\tlet resp1 = client1.pull().await?;\n\tlet resp2 = client2.pull().await?;\n\n\t// don't get our own events\n\tassert!(resp1.events.is_empty());\n\n\t// gets the event from client1\n\tassert_eq!(resp2.events.len(), 1);\n\tassert_eq!(resp2.events[0].class, 1500);\n\tassert_eq!(resp2.events[0].sender, EntityId::Player(client1.id()));\n\tassert_eq!(\n\t\tresp2.events[0].payload[..],\n\t\t[1u8, 2, 3, 4, 5, 6, 7, 8, 9, 0][..]\n\t);\n\n\tlet mut update = TickUpdate::default();\n\tupdate.events.push(OutboundEvent {\n\t\tclass: 1600,\n\t\tpayload: [2, 2, 3, 4, 5, 6, 7, 8, 9, 0][..].try_into().unwrap(),\n\t\trecipient: Recipient::default(),\n\t});\n\tclient2.roundtrip(update).await?;\n\n\tlet resp1 = client1.pull().await?;\n\n\tassert_eq!(resp1.events.len(), 1);\n\tassert_eq!(resp1.events[0].class, 1600);\n\tassert_eq!(resp1.events[0].sender, EntityId::Player(client2.id()));\n\tassert_eq!(\n\t\tresp1.events[0].payload[..],\n\t\t[2u8, 2, 3, 4, 5, 6, 7, 8, 9, 0][..]\n\t);\n\n\tOk(())\n}\n\n#[tokio::test]\nasync fn app_event_whitelist() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::default().await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server\n\t\t.build_session()\n\t\t.with_events_filter(EventsFilter::only(\u0026[1500, 1600]))\n\t\t.build()\n\t\t.await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tclient1.roundtrip(update).await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((2.0, 3.0, 4.0)),\n\t);\n\tclient2.roundtrip(update).await?;\n\n\t// wait for spacial index to reindex players so they\n\t// become relevant to each other and app-level events are propagated\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.events.push(OutboundEvent {\n\t\tclass: 1500,\n\t\tpayload: [1, 2, 3, 4, 5, 6, 7, 8, 9, 0][..].try_into().unwrap(),\n\t\trecipient: Recipient::default(),\n\t});\n\n\tupdate.events.push(OutboundEvent {\n\t\tclass: 1600,\n\t\tpayload: [2, 2, 3, 4, 5, 6, 7, 8, 9, 0][..].try_into().unwrap(),\n\t\trecipient: Recipient::default(),\n\t});\n\n\tupdate.events.push(OutboundEvent {\n\t\tclass: 1700,\n\t\tpayload: [3, 2, 3, 4, 5, 6, 7, 8, 9, 0][..].try_into().unwrap(),\n\t\trecipient: Recipient::default(),\n\t});\n\n\tupdate.events.push(OutboundEvent {\n\t\tclass: 1800,\n\t\tpayload: [4, 2, 3, 4, 5, 6, 7, 8, 9, 0][..].try_into().unwrap(),\n\t\trecipient: Recipient::default(),\n\t});\n\n\tclient1.roundtrip(update).await?;\n\n\t// give events some time to propagate\n\ttokio::time::sleep(Duration::from_millis(100)).await;\n\n\tlet mut resp2 = client2.pull().await?;\n\tresp2.events.sort_by_key(|e| e.class);\n\n\tassert_eq!(resp2.events.len(), 2);\n\tassert_eq!(resp2.events[0].class, 1500);\n\tassert_eq!(resp2.events[0].sender, EntityId::Player(client1.id()));\n\tassert_eq!(\n\t\tresp2.events[0].payload[..],\n\t\t[1u8, 2, 3, 4, 5, 6, 7, 8, 9, 0][..]\n\t);\n\n\tassert_eq!(resp2.events[1].class, 1600);\n\tassert_eq!(resp2.events[1].sender, EntityId::Player(client1.id()));\n\tassert_eq!(\n\t\tresp2.events[1].payload[..],\n\t\t[2u8, 2, 3, 4, 5, 6, 7, 8, 9, 0][..]\n\t);\n\n\tOk(())\n}\n\n#[tokio::test]\nasync fn app_event_blacklist() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::default().await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server\n\t\t.build_session()\n\t\t.with_events_filter(EventsFilter::except(\u0026[1500, 1600]))\n\t\t.build()\n\t\t.await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tclient1.roundtrip(update).await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((2.0, 3.0, 4.0)),\n\t);\n\tclient2.roundtrip(update).await?;\n\n\t// wait for spacial index to reindex players so they\n\t// become relevant to each other and app-level events are propagated\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.events.push(OutboundEvent {\n\t\tclass: 1500,\n\t\tpayload: [1, 2, 3, 4, 5, 6, 7, 8, 9, 0][..].try_into().unwrap(),\n\t\trecipient: Recipient::default(),\n\t});\n\n\tupdate.events.push(OutboundEvent {\n\t\tclass: 1600,\n\t\tpayload: [2, 2, 3, 4, 5, 6, 7, 8, 9, 0][..].try_into().unwrap(),\n\t\trecipient: Recipient::default(),\n\t});\n\n\tupdate.events.push(OutboundEvent {\n\t\tclass: 1700,\n\t\tpayload: [3, 2, 3, 4, 5, 6, 7, 8, 9, 0][..].try_into().unwrap(),\n\t\trecipient: Recipient::default(),\n\t});\n\n\tupdate.events.push(OutboundEvent {\n\t\tclass: 1800,\n\t\tpayload: [4, 2, 3, 4, 5, 6, 7, 8, 9, 0][..].try_into().unwrap(),\n\t\trecipient: Recipient::default(),\n\t});\n\n\tclient1.roundtrip(update).await?;\n\n\t// give events some time to propagate\n\ttokio::time::sleep(Duration::from_millis(100)).await;\n\n\tlet mut resp2 = client2.pull().await?;\n\tresp2.events.sort_by_key(|e| e.class);\n\n\tassert_eq!(resp2.events.len(), 2);\n\tassert_eq!(resp2.events[0].class, 1700);\n\tassert_eq!(resp2.events[0].sender, EntityId::Player(client1.id()));\n\tassert_eq!(\n\t\tresp2.events[0].payload[..],\n\t\t[3u8, 2, 3, 4, 5, 6, 7, 8, 9, 0][..]\n\t);\n\n\tassert_eq!(resp2.events[1].class, 1800);\n\tassert_eq!(resp2.events[1].sender, EntityId::Player(client1.id()));\n\tassert_eq!(\n\t\tresp2.events[1].payload[..],\n\t\t[4u8, 2, 3, 4, 5, 6, 7, 8, 9, 0][..]\n\t);\n\n\tOk(())\n}\n\n/// Here player inboxes should  be addressable by their delegated objects\n/// and senders of events with delegated objects should have the sender as the\n/// delegated object\n#[tokio::test]\nasync fn app_event_delegated_object() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::default().await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\n\tlet obj1 = client1.derive_global_id(1);\n\tlet mut update = TickUpdate::default();\n\tupdate\n\t\t.player\n\t\t.attributes\n\t\t.insert(WellKnownAttribute::Delegate as u16, Value::Uint64(obj1));\n\n\tupdate.object(obj1).attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tupdate.object(obj1).attributes.insert(\n\t\tWellKnownAttribute::OwnerId as u16,\n\t\tValue::Uint32(client1.id()),\n\t);\n\tclient1.roundtrip(update).await?;\n\n\tlet obj2 = client2.derive_global_id(2);\n\tlet mut update = TickUpdate::default();\n\tupdate\n\t\t.player\n\t\t.attributes\n\t\t.insert(WellKnownAttribute::Delegate as u16, Value::Uint64(obj2));\n\n\tupdate.object(obj2).attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((2.0, 3.0, 4.0)),\n\t);\n\tupdate.object(obj2).attributes.insert(\n\t\tWellKnownAttribute::OwnerId as u16,\n\t\tValue::Uint32(client2.id()),\n\t);\n\n\tclient2.roundtrip(update).await?;\n\n\t// wait for spacial index to reindex players so they\n\t// become relevant to each other and app-level events are propagated\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.events.push(OutboundEvent {\n\t\tclass: 1500,\n\t\tpayload: [1, 2, 3, 4, 5, 6, 7, 8, 9, 0][..].try_into().unwrap(),\n\t\trecipient: Recipient::default(),\n\t});\n\tclient1.roundtrip(update).await?;\n\n\t// give the event some time to propagate\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet resp1 = client1.pull().await?;\n\t// don't get our own events\n\tassert!(resp1.events.is_empty());\n\n\tlet resp2 = client2.pull().await?;\n\tassert_eq!(resp2.events.len(), 1);\n\tassert_eq!(resp2.events[0].class, 1500);\n\t// the sender should be the delegated object\n\tassert_eq!(resp2.events[0].sender, EntityId::Object(obj1));\n\tassert_eq!(\n\t\tresp2.events[0].payload[..],\n\t\t[1u8, 2, 3, 4, 5, 6, 7, 8, 9, 0][..]\n\t);\n\n\tlet mut update = TickUpdate::default();\n\tupdate.events.push(OutboundEvent {\n\t\tclass: 1600,\n\t\tpayload: [2, 2, 3, 4, 5, 6, 7, 8, 9, 0][..].try_into().unwrap(),\n\t\trecipient: Recipient::Entity(EntityId::Object(obj1)),\n\t});\n\tclient2.roundtrip(update).await?;\n\n\t// give the event some time to propagate\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet resp1 = client1.pull().await?;\n\tassert_eq!(resp1.events.len(), 1);\n\tassert_eq!(resp1.events[0].class, 1600);\n\tassert_eq!(resp1.events[0].sender, EntityId::Object(obj2));\n\tassert_eq!(\n\t\tresp1.events[0].payload[..],\n\t\t[2u8, 2, 3, 4, 5, 6, 7, 8, 9, 0][..]\n\t);\n\n\tlet resp2 = client2.pull().await?;\n\tassert!(resp2.events.is_empty());\n\n\tOk(())\n}\n\n/// Tests that an application level event is propagated object's owner.\n#[tokio::test]\nasync fn app_event_delivered_to_object_owner() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::default().await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\n\tlet obj1id = client1.derive_global_id(1);\n\n\tlet mut update = TickUpdate::default();\n\tupdate\n\t\t.object(obj1id)\n\t\t.attributes\n\t\t.insert(1909, Value::String(\"hello\".try_into()?));\n\tclient1.roundtrip(update).await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.events.push(OutboundEvent {\n\t\tclass: 1500,\n\t\tpayload: [1, 2, 3, 4, 5, 6, 7, 8, 9, 0][..].try_into().unwrap(),\n\t\trecipient: Recipient::Entity(EntityId::Object(obj1id)),\n\t});\n\tclient2.roundtrip(update).await?;\n\n\t// give the event some time to propagate\n\ttokio::time::sleep(Duration::from_millis(100)).await;\n\n\t// client 1 should receive the event, even through\n\t// client 1 \u0026 2 are not relevant to each other\n\t// not object1 and client 2\n\tlet resp1 = client1.pull().await?;\n\n\tassert_eq!(resp1.players.len(), 0);\n\tassert_eq!(resp1.objects.len(), 0);\n\tassert_eq!(resp1.events.len(), 1);\n\tassert_eq!(resp1.events[0].class, 1500);\n\tassert_eq!(resp1.events[0].sender, EntityId::Player(client2.id()));\n\tassert_eq!(\n\t\tresp1.events[0].payload[..],\n\t\t[1u8, 2, 3, 4, 5, 6, 7, 8, 9, 0][..]\n\t);\n\n\tOk(())\n}\n\n/// enusre that an event is not duplicated if the recipient object and its\n/// owning player are both relevant to the sender\n#[tokio::test]\nasync fn app_event_delivered_to_object_owner_no_duplicates(\n) -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::default().await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\n\tlet obj1id = client1.derive_global_id(1);\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tupdate.object(obj1id).attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tupdate\n\t\t.object(obj1id)\n\t\t.attributes\n\t\t.insert(1909, Value::String(\"hello\".try_into()?));\n\tclient1.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tupdate.events.push(OutboundEvent {\n\t\tclass: 1500,\n\t\tpayload: [1, 2, 3, 4, 5, 6, 7, 8, 9, 0][..].try_into().unwrap(),\n\t\trecipient: Recipient::Radius(Relevance::max()),\n\t});\n\tlet resp2 = client2.roundtrip(update).await?;\n\n\tassert_eq!(resp2.players.len(), 1);\n\tassert_eq!(resp2.objects.len(), 1);\n\n\tassert!(resp2.players.contains_key(\u0026client1.id()));\n\tassert!(resp2.objects.contains_key(\u0026obj1id));\n\tassert_eq!(resp2.objects[\u0026obj1id].attributes.len(), 3);\n\n\tassert_eq!(\n\t\tresp2.objects[\u0026obj1id].attributes[\u0026(WellKnownAttribute::Position as u16)],\n\t\tValue::Vec3((1.0, 2.0, 3.0))\n\t);\n\tassert_eq!(\n\t\tresp2.objects[\u0026obj1id].attributes[\u0026(WellKnownAttribute::OwnerId as u16)],\n\t\tValue::Uint32(client1.id())\n\t);\n\tassert_eq!(\n\t\tresp2.objects[\u0026obj1id].attributes[\u00261909],\n\t\tValue::String(\"hello\".try_into()?)\n\t);\n\n\t// event not delivered to the sender\n\tassert_eq!(resp2.events.len(), 0);\n\n\tserver.wait_for_spatial_reindex().await;\n\n\t// client 1 should receive the event, even through\n\t// client 1 \u0026 2 are not relevant to each other\n\t// not object1 and client 2\n\tlet resp1 = client1.pull().await?;\n\n\tassert_eq!(resp1.players.len(), 1);\n\tassert_eq!(resp1.objects.len(), 0);\n\tassert_eq!(resp1.events.len(), 1);\n\tassert_eq!(resp1.events[0].class, 1500);\n\tassert_eq!(resp1.events[0].sender, EntityId::Player(client2.id()));\n\tassert_eq!(\n\t\tresp1.events[0].payload[..],\n\t\t[1u8, 2, 3, 4, 5, 6, 7, 8, 9, 0][..]\n\t);\n\n\tOk(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","tests","forget.rs"],"content":"use {\n\tcrate::tests::mock::{MockServer, SessionTestExt, TickUpdate},\n\tquark_client_sdk::{\n\t\tprotocol::{events::SystemEvents, WellKnownAttribute},\n\t\tOutboundEvent,\n\t\tRecipient,\n\t\tValue,\n\t},\n};\n\n#[tokio::test]\nasync fn forget_objects() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::default().await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\tlet mut client3 = server.new_session().await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\n\tlet obj1id = client1.derive_global_id(1);\n\tupdate.object(obj1id).attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\n\tupdate\n\t\t.object(client1.derive_global_id(2))\n\t\t.attributes\n\t\t.insert(\n\t\t\tWellKnownAttribute::Position as u16,\n\t\t\tValue::Vec3((1.0, 5.0, 3.0)),\n\t\t);\n\tclient1.push(update).await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((2.0, 3.0, 4.0)),\n\t);\n\tclient2.push(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\t// get first update from both clients\n\tlet resp1 = client1.pull().await?;\n\tlet resp2 = client2.pull().await?;\n\n\tassert_eq!(resp1.players.len(), 1);\n\tassert_eq!(resp1.objects.len(), 0);\n\n\tassert_eq!(resp2.players.len(), 1);\n\tassert_eq!(resp2.objects.len(), 2);\n\n\t// no updates, should be an empty respose\n\t// as this data was already sent to the clients\n\t// and marked as delivered on the server\n\tlet resp1 = client1.pull().await?;\n\tlet resp2 = client2.pull().await?;\n\n\tassert!(resp1.players.is_empty());\n\tassert!(resp1.objects.is_empty());\n\tassert!(resp2.players.is_empty());\n\tassert!(resp2.objects.is_empty());\n\n\tlet mut update = TickUpdate::default();\n\tupdate.events.push(OutboundEvent {\n\t\tclass: SystemEvents::ForgetObjects as u16,\n\t\tpayload: obj1id.to_le_bytes()[..].try_into().unwrap(),\n\t\trecipient: Recipient::default(),\n\t});\n\tclient1.push(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet resp1 = client1.pull().await?;\n\tlet resp2 = client2.pull().await?;\n\n\tassert!(resp1.players.is_empty());\n\tassert_eq!(resp1.objects.len(), 1);\n\tassert_eq!(resp1.objects[\u0026obj1id].attributes.len(), 2);\n\tassert_eq!(\n\t\tresp1.objects[\u0026obj1id].attributes[\u0026(WellKnownAttribute::Position as u16)],\n\t\tValue::Vec3((1.0, 2.0, 3.0))\n\t);\n\tassert_eq!(\n\t\tresp1.objects[\u0026obj1id].attributes[\u0026(WellKnownAttribute::OwnerId as u16)],\n\t\tValue::Uint32(client1.id())\n\t);\n\n\tassert!(resp2.players.is_empty());\n\tassert!(resp2.objects.is_empty());\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((9.0, 3.0, 4.0)),\n\t);\n\tlet resp3 = client3.roundtrip(update).await?;\n\n\tassert_eq!(resp3.players.len(), 2);\n\tassert_eq!(resp3.objects.len(), 2);\n\n\tOk(())\n}\n\n#[tokio::test]\nasync fn forget_players() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::default().await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tclient1.push(update).await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((2.0, 3.0, 4.0)),\n\t);\n\tclient2.push(update).await?;\n\n\t// wait for spacial index to reindex players so they\n\t// become relevant to each other and app-level events are propagated\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet resp1 = client1.pull().await?;\n\tlet resp2 = client2.pull().await?;\n\n\tassert_eq!(resp1.players.len(), 1);\n\tassert_eq!(resp2.players.len(), 1);\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet resp1 = client1.pull().await?;\n\tlet resp2 = client2.pull().await?;\n\n\t// should be empty because no attributes were changed\n\t// and they both already got the latest version of each others state\n\tassert!(resp1.players.is_empty());\n\tassert!(resp2.players.is_empty());\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.events.push(OutboundEvent {\n\t\tclass: SystemEvents::ForgetPlayers as u16,\n\t\tpayload: client2.id().to_le_bytes()[..].try_into().unwrap(),\n\t\trecipient: Recipient::default(),\n\t});\n\tclient1.push(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet resp1 = client1.pull().await?;\n\tlet resp2 = client2.pull().await?;\n\n\tassert_eq!(resp1.players.len(), 1);\n\tassert_eq!(resp1.players[\u0026client2.id()].id, client2.id());\n\tassert_eq!(resp1.players[\u0026client2.id()].attributes.len(), 1);\n\tassert_eq!(\n\t\tresp1.players[\u0026client2.id()].attributes\n\t\t\t[\u0026(WellKnownAttribute::Position as u16)],\n\t\tValue::Vec3((2.0, 3.0, 4.0))\n\t);\n\n\tassert!(resp2.players.is_empty());\n\n\tOk(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","tests","interests.rs"],"content":"use {\n\tcrate::{\n\t\topts::{Profile, ServerOptions},\n\t\trelevance::{Relevance, SpatialIndexConfig},\n\t\ttests::mock::{MockServer, SessionTestExt, TickUpdate},\n\t},\n\tquark_client_sdk::{Value, WellKnownAttribute},\n\tstd::time::Duration,\n};\n\n#[tokio::test]\nasync fn interest_range_smoke() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::new(ServerOptions::with_profile(Profile {\n\t\tspatial_index: SpatialIndexConfig {\n\t\t\tmax_radius: 100,\n\t\t\tmap_width: 100000,\n\t\t\tmap_height: 100000,\n\t\t\tcells_count_x: 100,\n\t\t\tcells_count_y: 100,\n\t\t\treindex_interval: Duration::from_millis(50),\n\t\t},\n\n\t\t..Default::default()\n\t}))\n\t.await?;\n\n\tlet mut client1 = server.new_session().await?;\n\n\tlet mut client2 = server\n\t\t.build_session()\n\t\t.with_radius(Relevance::new(0.2))\n\t\t.build()\n\t\t.await?;\n\n\tlet mut client3 = server\n\t\t.build_session()\n\t\t.with_radius(Relevance::max())\n\t\t.build()\n\t\t.await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tclient1.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((38000.0, 3.0, 4.0)),\n\t);\n\tlet resp2 = client2.roundtrip(update).await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((38000.0, 3.0, 4.0)),\n\t);\n\tlet resp3 = client3.roundtrip(update).await?;\n\n\t// should not get an update about player 1\n\t// because it's interest range is set to 20 meters\n\t// and player 1 is 10 meters away\n\tassert!(resp2.players.is_empty());\n\n\t// now relevance radius is maxed, so should get an update about player 1\n\tassert_eq!(\n\t\tresp3.players[\u0026client1.id()].attributes\n\t\t\t[\u0026(WellKnownAttribute::Position as u16)],\n\t\tValue::Vec3((1.0, 2.0, 3.0))\n\t);\n\n\tOk(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","tests","mock.rs"],"content":"#![allow(dead_code)]\n\nuse {\n\tcrate::{\n\t\tevents::Event,\n\t\topts::{Profile, ServerOptions},\n\t\trelevance::Relevance,\n\t\tserver,\n\t\tstate::{entity::AttributeId, object::ObjectId, player::PlayerId},\n\t\ttopology::Topology,\n\t},\n\tquark_client_sdk::{\n\t\tEventsFilter,\n\t\tLocalUpdate,\n\t\tOutboundEvent,\n\t\tQoS,\n\t\tQuery,\n\t\tRemoteUpdate,\n\t\tSession,\n\t\tTimestamp,\n\t\tValue,\n\t},\n\tstd::{\n\t\tcollections::{hash_map, HashMap},\n\t\tnet::SocketAddr,\n\t\tops::Index,\n\t\tpath::PathBuf,\n\t\tsync::{\n\t\t\tatomic::{AtomicBool, AtomicU16, Ordering},\n\t\t\tArc,\n\t\t},\n\t\ttime::Duration,\n\t},\n\ttokio::time::timeout,\n\ttracing::trace,\n};\n\nconst TIMEOUT: Duration = Duration::from_secs(10);\n\n// Binding a listener to the port 0 to ask OS for the available port\npub fn get_next_listen_address() -\u003e SocketAddr {\n\tlet socket = SocketAddr::from(([127, 0, 0, 1], 0));\n\tloop {\n\t\tlet addr = match std::net::TcpListener::bind(socket) {\n\t\t\tOk(lstnr) =\u003e lstnr.local_addr().unwrap(),\n\t\t\t_ =\u003e continue,\n\t\t};\n\n\t\treturn addr;\n\t}\n}\n\npub struct FileGen(pub PathBuf);\n\nimpl FileGen {\n\tpub fn new(dir: PathBuf) -\u003e Self {\n\t\tstatic mut SEQ: AtomicU16 = AtomicU16::new(0);\n\t\tSelf(dir.join(format!(\"file-{}\", unsafe {\n\t\t\tSEQ.fetch_add(1, Ordering::SeqCst)\n\t\t})))\n\t}\n}\n\nimpl Drop for FileGen {\n\tfn drop(\u0026mut self) {\n\t\tlet _ = std::fs::remove_file(\u0026self.0);\n\t}\n}\n\npub struct DirGen(pub PathBuf);\n\nimpl DirGen {\n\tpub fn new(dir: PathBuf) -\u003e anyhow::Result\u003cSelf\u003e {\n\t\tstatic mut SEQ: AtomicU16 = AtomicU16::new(0);\n\t\tlet dir = PathBuf::from(format!(\"{}-{}\", dir.display(), unsafe {\n\t\t\tSEQ.fetch_add(1, Ordering::SeqCst)\n\t\t}));\n\t\tlet _ = std::fs::remove_dir_all(\u0026dir);\n\t\tstd::fs::create_dir(\u0026dir)?;\n\t\tOk(Self(dir))\n\t}\n}\n\nimpl Drop for DirGen {\n\tfn drop(\u0026mut self) {\n\t\tlet _ = std::fs::remove_dir_all(\u0026self.0);\n\t}\n}\n\n/// Used in tests to create a local in-process server for testing.\npub struct MockServer {\n\tprofile: Profile,\n\tlisten_addr: SocketAddr,\n\tgroup_reindex_interval: Duration,\n\tspatial_reindex_interval: Duration,\n\tglobal_reindex_interval: Duration,\n}\n\nimpl MockServer {\n\tpub async fn default() -\u003e anyhow::Result\u003cSelf\u003e {\n\t\ttimeout(TIMEOUT, MockServer::new(ServerOptions::default()))\n\t\t\t.await\n\t\t\t.unwrap()\n\t}\n\n\tpub async fn new(opts: ServerOptions) -\u003e anyhow::Result\u003cSelf\u003e {\n\t\tif let Ok(v) = std::env::var(\"QUARK_TEST_TRACE\") {\n\t\t\tif v == \"1\" {\n\t\t\t\tenable_trace_logging();\n\t\t\t}\n\t\t}\n\n\t\tlet mut opts = opts;\n\t\topts.listen_addr = get_next_listen_address();\n\n\t\tlet listen_addr = opts.listen_addr;\n\t\tlet profile = opts.profile().clone();\n\t\tlet group_reindex_interval = opts.profile().group_index.reindex_interval;\n\t\tlet spatial_reindex_interval =\n\t\t\topts.profile().spatial_index.reindex_interval;\n\t\tlet global_reindex_interval = opts.profile().global_index.reindex_interval;\n\n\t\tlet topology = Arc::new(Topology::default());\n\t\ttokio::spawn(server::run(opts, topology));\n\n\t\t// give the server some time to start\n\t\ttokio::time::sleep(Duration::from_millis(100)).await;\n\n\t\tOk(Self {\n\t\t\tprofile,\n\t\t\tgroup_reindex_interval,\n\t\t\tspatial_reindex_interval,\n\t\t\tglobal_reindex_interval,\n\t\t\tlisten_addr,\n\t\t})\n\t}\n\n\tpub fn profile(\u0026self) -\u003e \u0026Profile {\n\t\t\u0026self.profile\n\t}\n\n\tpub fn listen_addr(\u0026self) -\u003e SocketAddr {\n\t\tself.listen_addr\n\t}\n}\n\n#[derive(Debug, Clone)]\npub struct AttributeValue {\n\tpub value: Value,\n\tpub timestamp: Timestamp,\n}\n\nimpl PartialEq for AttributeValue {\n\tfn eq(\u0026self, other: \u0026Self) -\u003e bool {\n\t\tself.value == other.value\n\t}\n}\n\nimpl Eq for AttributeValue {}\n\nimpl From\u003cValue\u003e for AttributeValue {\n\tfn from(value: Value) -\u003e Self {\n\t\tSelf {\n\t\t\tvalue,\n\t\t\ttimestamp: Timestamp::default(),\n\t\t}\n\t}\n}\n\n#[derive(Debug, Clone, Default)]\npub struct AttributesMap(HashMap\u003cAttributeId, AttributeValue\u003e);\n\nimpl AttributesMap {\n\tpub fn new() -\u003e Self {\n\t\tSelf(HashMap::new())\n\t}\n\n\tpub fn insert(\u0026mut self, id: AttributeId, value: Value) {\n\t\tself.0.insert(id, AttributeValue {\n\t\t\tvalue,\n\t\t\ttimestamp: Timestamp::default(),\n\t\t});\n\t}\n\n\tpub fn insert_with_timestamp(\n\t\t\u0026mut self,\n\t\tid: AttributeId,\n\t\tvalue: Value,\n\t\ttimestamp: Timestamp,\n\t) {\n\t\tself.0.insert(id, AttributeValue { value, timestamp });\n\t}\n\n\tpub fn len(\u0026self) -\u003e usize {\n\t\tself.0.len()\n\t}\n\n\tpub fn is_empty(\u0026self) -\u003e bool {\n\t\tself.0.is_empty()\n\t}\n\n\tpub fn iter(\u0026self) -\u003e impl Iterator\u003cItem = (\u0026AttributeId, \u0026AttributeValue)\u003e {\n\t\tself.0.iter()\n\t}\n\n\tpub fn get(\u0026self, id: \u0026AttributeId) -\u003e Option\u003c\u0026AttributeValue\u003e {\n\t\tself.0.get(id)\n\t}\n}\n\nimpl IntoIterator for AttributesMap {\n\ttype IntoIter = hash_map::IntoIter\u003cAttributeId, AttributeValue\u003e;\n\ttype Item = (AttributeId, AttributeValue);\n\n\tfn into_iter(self) -\u003e Self::IntoIter {\n\t\tself.0.into_iter()\n\t}\n}\n\nimpl PartialEq for AttributesMap {\n\tfn eq(\u0026self, other: \u0026Self) -\u003e bool {\n\t\tself.0 == other.0\n\t}\n}\n\nimpl Eq for AttributesMap {}\n\nimpl Index\u003c\u0026AttributeId\u003e for AttributesMap {\n\ttype Output = Value;\n\n\tfn index(\u0026self, id: \u0026AttributeId) -\u003e \u0026Self::Output {\n\t\t\u0026self.0[id].value\n\t}\n}\n\n#[derive(Default, Debug, PartialEq, Clone)]\npub struct Player {\n\tpub id: PlayerId,\n\tpub attributes: AttributesMap,\n}\n\n#[derive(Default, Debug, PartialEq, Clone)]\npub struct Object {\n\tpub id: ObjectId,\n\tpub attributes: AttributesMap,\n}\n\n#[derive(Default, Debug, Clone)]\npub struct TickUpdate {\n\tpub player: Player,\n\tpub objects: HashMap\u003cObjectId, Object\u003e,\n\tpub events: Vec\u003cOutboundEvent\u003e,\n}\n\nimpl TickUpdate {\n\tpub fn object(\u0026mut self, id: ObjectId) -\u003e \u0026mut Object {\n\t\tlet obj = self.objects.entry(id).or_default();\n\t\tobj.id = id;\n\t\tobj\n\t}\n}\n\n#[derive(Default, Debug, Clone)]\npub struct TickResponse {\n\tpub players: HashMap\u003cPlayerId, Player\u003e,\n\tpub objects: HashMap\u003cObjectId, Object\u003e,\n\tpub events: Vec\u003cEvent\u003e,\n}\n\nconst TICK_INTERVAL: Duration = Duration::from_millis(100);\nconst TICK_RESPONSE_INTERVAL: Duration = Duration::from_millis(500);\n\npub struct SessionBuilder\u003c's\u003e {\n\tserver: \u0026's MockServer,\n\tevents: EventsFilter,\n\ttags: Vec\u003cString\u003e,\n\tinterval: Duration,\n\tauth: \u0026's [u8],\n\tradius: Relevance,\n\tqueries: Vec\u003c(Query, QoS)\u003e,\n\tno_queries: bool,\n}\n\nimpl\u003c's\u003e SessionBuilder\u003c's\u003e {\n\tpub fn new(server: \u0026's MockServer) -\u003e Self {\n\t\tSelf {\n\t\t\tserver,\n\t\t\tevents: EventsFilter::all(),\n\t\t\tradius: Relevance::max(),\n\t\t\tinterval: TICK_INTERVAL,\n\t\t\ttags: vec![],\n\t\t\tauth: \u0026[],\n\t\t\tqueries: vec![],\n\t\t\tno_queries: false,\n\t\t}\n\t}\n\n\tpub fn with_radius(mut self, radius: Relevance) -\u003e Self {\n\t\tself.radius = radius;\n\t\tself\n\t}\n\n\tpub fn with_interval(mut self, interval: Duration) -\u003e Self {\n\t\tself.interval = interval;\n\t\tself\n\t}\n\n\tpub fn with_tags(mut self, tags: \u0026[\u0026str]) -\u003e Self {\n\t\tself.tags = tags.iter().map(|s| s.to_string()).collect();\n\t\tself\n\t}\n\n\tpub fn with_events_filter(mut self, events: EventsFilter) -\u003e Self {\n\t\tself.events = events;\n\t\tself\n\t}\n\n\tpub fn with_auth(mut self, auth: \u0026's [u8]) -\u003e Self {\n\t\tself.auth = auth;\n\t\tself\n\t}\n\n\tpub fn with_no_queries(mut self) -\u003e Self {\n\t\tself.no_queries = true;\n\t\tself\n\t}\n\n\tpub fn with_default_query(mut self) -\u003e Self {\n\t\tself.queries.push((\n\t\t\tQuery {\n\t\t\t\tradius: Relevance::max(),\n\t\t\t\tinterval: TICK_INTERVAL,\n\t\t\t\tevents: EventsFilter::all(),\n\t\t\t\t..Default::default()\n\t\t\t},\n\t\t\tQoS::Reliable,\n\t\t));\n\n\t\tself\n\t}\n\n\tpub fn with_query(mut self, query: Query, qos: QoS) -\u003e Self {\n\t\tself.queries.push((query, qos));\n\t\tself\n\t}\n\n\tpub async fn build(mut self) -\u003e anyhow::Result\u003cSession\u003e {\n\t\tlet mut session = timeout(\n\t\t\tDuration::from_secs(5),\n\t\t\tSession::start(\u0026self.server.listen_addr.to_string(), self.auth),\n\t\t)\n\t\t.await\n\t\t.unwrap()?;\n\n\t\tif self.queries.is_empty() \u0026\u0026 !self.no_queries {\n\t\t\tself.queries.push((\n\t\t\t\tQuery {\n\t\t\t\t\tradius: self.radius,\n\t\t\t\t\tinterval: self.interval,\n\t\t\t\t\tevents: self.events,\n\t\t\t\t\ttags: self.tags,\n\t\t\t\t\t..Default::default()\n\t\t\t\t},\n\t\t\t\tQoS::Reliable,\n\t\t\t));\n\t\t}\n\n\t\tfor (query, qos) in self.queries {\n\t\t\tsession.streams().subscribe(query, qos)?;\n\t\t}\n\n\t\tOk(session)\n\t}\n}\n\nimpl MockServer {\n\tpub async fn new_session(\u0026self) -\u003e anyhow::Result\u003cSession\u003e {\n\t\tSessionBuilder::new(self).with_default_query().build().await\n\t}\n\n\tpub fn build_session(\u0026self) -\u003e SessionBuilder {\n\t\tSessionBuilder::new(self)\n\t}\n\n\tpub async fn resume_session(\u0026self, token: \u0026[u8]) -\u003e anyhow::Result\u003cSession\u003e {\n\t\tOk(\n\t\t\ttimeout(\n\t\t\t\tDuration::from_secs(5),\n\t\t\t\tSession::resume(\u0026self.listen_addr.to_string(), token),\n\t\t\t)\n\t\t\t.await\n\t\t\t.unwrap()?,\n\t\t)\n\t}\n\n\tpub async fn wait_for_tick_interval(\u0026self) {\n\t\ttokio::time::sleep(TICK_RESPONSE_INTERVAL).await;\n\t}\n\n\tpub async fn wait_for_spatial_reindex(\u0026self) {\n\t\ttokio::time::sleep(self.spatial_reindex_interval * 2).await;\n\t}\n\n\tpub async fn wait_for_group_reindex(\u0026self) {\n\t\ttokio::time::sleep(self.group_reindex_interval * 2).await;\n\t}\n\n\tpub async fn wait_for_global_reindex(\u0026self) {\n\t\ttokio::time::sleep(self.global_reindex_interval * 2).await;\n\t}\n}\n\npub trait SessionTestExt {\n\tasync fn push(\u0026mut self, tick: TickUpdate) -\u003e anyhow::Result\u003c()\u003e;\n\tasync fn roundtrip(\n\t\t\u0026mut self,\n\t\ttick: TickUpdate,\n\t) -\u003e anyhow::Result\u003cTickResponse\u003e;\n\tasync fn pull(\u0026mut self) -\u003e anyhow::Result\u003cTickResponse\u003e;\n\tasync fn wait_for_query_tick(\u0026self) {\n\t\ttokio::time::sleep(TICK_RESPONSE_INTERVAL).await;\n\t}\n}\n\nimpl SessionTestExt for Session {\n\tasync fn push(\u0026mut self, tick: TickUpdate) -\u003e anyhow::Result\u003c()\u003e {\n\t\ttrace!(session = self.id(), \"sending updates: {tick:?}\");\n\t\tfor (key, value) in tick.player.attributes {\n\t\t\tself\n\t\t\t\t.streams()\n\t\t\t\t.send(LocalUpdate::Player(key, value.value), QoS::Reliable)?;\n\t\t}\n\n\t\tfor (id, object) in tick.objects {\n\t\t\tfor (key, value) in object.attributes {\n\t\t\t\tself\n\t\t\t\t\t.streams()\n\t\t\t\t\t.send(LocalUpdate::Object(id, key, value.value), QoS::Reliable)?;\n\t\t\t}\n\t\t}\n\n\t\tfor event in tick.events {\n\t\t\tself.streams().send(\n\t\t\t\tLocalUpdate::Event(\n\t\t\t\t\tevent.class,\n\t\t\t\t\tevent.payload.to_vec().into_boxed_slice(),\n\t\t\t\t\tevent.recipient,\n\t\t\t\t),\n\t\t\t\tQoS::Reliable,\n\t\t\t)?;\n\t\t}\n\n\t\tself.streams().flush()?;\n\n\t\tOk(())\n\t}\n\n\tasync fn roundtrip(\n\t\t\u0026mut self,\n\t\ttick: TickUpdate,\n\t) -\u003e anyhow::Result\u003cTickResponse\u003e {\n\t\tself.push(tick).await?;\n\t\tself.wait_for_query_tick().await;\n\t\tself.pull().await\n\t}\n\n\tasync fn pull(\u0026mut self) -\u003e anyhow::Result\u003cTickResponse\u003e {\n\t\tself.wait_for_query_tick().await;\n\t\tlet mut response = TickResponse::default();\n\t\tfor update in self.streams() {\n\t\t\tmatch update {\n\t\t\t\tRemoteUpdate::Player(id, key, value, timestamp) =\u003e {\n\t\t\t\t\tlet player = response.players.entry(id).or_default();\n\n\t\t\t\t\tplayer.id = id;\n\t\t\t\t\tplayer\n\t\t\t\t\t\t.attributes\n\t\t\t\t\t\t.insert_with_timestamp(key, value, timestamp);\n\t\t\t\t}\n\t\t\t\tRemoteUpdate::Object(id, key, value, timestamp) =\u003e {\n\t\t\t\t\tlet object = response.objects.entry(id).or_default();\n\t\t\t\t\tobject.id = id;\n\t\t\t\t\tobject\n\t\t\t\t\t\t.attributes\n\t\t\t\t\t\t.insert_with_timestamp(key, value, timestamp);\n\t\t\t\t}\n\t\t\t\tRemoteUpdate::Event(class, payload, sender, timestamp) =\u003e {\n\t\t\t\t\tresponse.events.push(Event {\n\t\t\t\t\t\tclass,\n\t\t\t\t\t\tpayload: payload.to_vec().as_slice().try_into().unwrap(),\n\t\t\t\t\t\tsender,\n\t\t\t\t\t\ttimestamp,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\ttrace!(session = self.id(), \"received updates: {response:?}\");\n\t\tOk(response)\n\t}\n}\n\npub fn enable_trace_logging() {\n\tstatic mut INITIALIZED: AtomicBool = AtomicBool::new(false);\n\n\tif unsafe {\n\t\tINITIALIZED\n\t\t\t.compare_exchange(false, true, Ordering::SeqCst, Ordering::SeqCst)\n\t\t\t.is_err()\n\t} {\n\t\treturn;\n\t}\n\n\ttracing_subscriber::util::SubscriberInitExt::init(\n\t\ttracing_subscriber::layer::SubscriberExt::with(\n\t\t\ttracing_subscriber::registry(),\n\t\t\ttracing_subscriber::Layer::with_filter(\n\t\t\t\ttracing_subscriber::fmt::layer(),\n\t\t\t\ttracing_subscriber::filter::filter_fn(move |metadata| {\n\t\t\t\t\tmetadata.level() \u003c= \u0026tracing::Level::TRACE\n\t\t\t\t\t\t\u0026\u0026 !metadata\n\t\t\t\t\t\t\t.target()\n\t\t\t\t\t\t\t.starts_with(\"tokio_util::codec::framed_impl\")\n\t\t\t\t\t\t\u0026\u0026 !metadata.target().starts_with(\"mio::poll\")\n\t\t\t\t}),\n\t\t\t),\n\t\t),\n\t);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","tests","mod.rs"],"content":"mod admin;\nmod authenticate;\nmod authority;\nmod blend;\nmod despawn;\nmod entity;\nmod events;\nmod forget;\nmod interests;\nmod ownership;\nmod relevance;\nmod replication;\nmod resume;\nmod schema;\nmod spec;\nmod stream;\nmod tags;\nmod time;\nmod topology;\n\npub(crate) mod mock;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","tests","ownership.rs"],"content":"use {\n\tcrate::{\n\t\topts::ServerOptions,\n\t\tschema::{self, Object, Ownership, Schema},\n\t\tstate::object::ObjectId,\n\t\ttests::mock::{MockServer, SessionTestExt, TickUpdate},\n\t},\n\tquark_client_sdk::{\n\t\tderive_shared_id,\n\t\tAttributeId,\n\t\tValue,\n\t\tWellKnownAttribute,\n\t},\n\trand::random,\n\tstd::time::Duration,\n};\n\n/// Ensure that if a player is relevant, then all objects owned by that player\n/// are also relevant.\n#[tokio::test]\nasync fn owned_object_relevant_with_player_manual() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::default().await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\n\tlet obj1id = client1.derive_global_id(1);\n\tupdate.object(obj1id).attributes.insert(\n\t\tWellKnownAttribute::OwnerId as u16,\n\t\tValue::Uint32(client1.id()),\n\t);\n\n\tupdate\n\t\t.object(obj1id)\n\t\t.attributes\n\t\t.insert(1002, Value::String(\"test_val1\".try_into().unwrap()));\n\n\t// an object is created and owned by client1 player\n\t// the object doesn't have a position attribute but\n\t// it should be relevant whenever the player is relevant\n\tclient1.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((2.0, 3.0, 4.0)),\n\t);\n\n\tlet resp2 = client2.roundtrip(update).await?;\n\n\tassert_eq!(resp2.players.len(), 1);\n\tassert_eq!(resp2.objects.len(), 1);\n\tassert_eq!(resp2.events.len(), 0);\n\n\tassert_eq!(\n\t\tresp2.players[\u0026client1.id()].attributes\n\t\t\t[\u0026(WellKnownAttribute::Position as u16)],\n\t\tValue::Vec3((1.0, 2.0, 3.0))\n\t);\n\n\tassert_eq!(\n\t\tresp2.objects[\u0026obj1id].attributes[\u00261002],\n\t\tValue::String(\"test_val1\".try_into().unwrap())\n\t);\n\n\tOk(())\n}\n\n#[tokio::test]\nasync fn orphan_object_attached_after_missing_parent_created(\n) -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::default().await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\n\tlet obj1id = client1.derive_global_id(1);\n\tlet obj2id = client1.derive_global_id(2);\n\n\tupdate\n\t\t.object(obj1id)\n\t\t.attributes\n\t\t.insert(WellKnownAttribute::OwnerId as u16, Value::Uint64(obj2id));\n\n\tupdate\n\t\t.object(obj1id)\n\t\t.attributes\n\t\t.insert(1002, Value::String(\"test_val1\".try_into().unwrap()));\n\n\t// we're creating an object that does not have a position so it is not\n\t// picked up by the spatial index. It's owner is another object that\n\t// does not exist yet. The object should not be returned to client 2\n\t// in the current tick.\n\tclient1.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((2.0, 3.0, 4.0)),\n\t);\n\n\tlet resp2 = client2.roundtrip(update).await?;\n\n\tassert_eq!(resp2.players.len(), 1);\n\tassert_eq!(resp2.objects.len(), 0);\n\tassert_eq!(resp2.events.len(), 0);\n\n\tassert_eq!(\n\t\tresp2.players[\u0026client1.id()].attributes\n\t\t\t[\u0026(WellKnownAttribute::Position as u16)],\n\t\tValue::Vec3((1.0, 2.0, 3.0))\n\t);\n\n\t// Now create the parent object by client1 and the next tick of client2\n\t// should return 2 objects, the parent and the child.\n\n\tlet mut update = TickUpdate::default();\n\tupdate.object(obj2id).attributes.insert(\n\t\tWellKnownAttribute::OwnerId as u16,\n\t\tValue::Uint32(client1.id()),\n\t);\n\n\tupdate\n\t\t.object(obj2id)\n\t\t.attributes\n\t\t.insert(1002, Value::String(\"test_val2\".try_into().unwrap()));\n\n\tclient1.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet resp2 = client2.pull().await?;\n\n\t// no new players, nothing changed on the client1 player entity.\n\tassert_eq!(resp2.players.len(), 0);\n\n\t// two new objects, the immediate child of client1 and its child\n\t// that was previously orphaned.\n\tassert_eq!(resp2.objects.len(), 2);\n\n\tassert_eq!(\n\t\tresp2.objects[\u0026obj1id].attributes[\u00261002],\n\t\tValue::String(\"test_val1\".try_into().unwrap())\n\t);\n\n\tassert_eq!(\n\t\tresp2.objects[\u0026obj2id].attributes[\u00261002],\n\t\tValue::String(\"test_val2\".try_into().unwrap())\n\t);\n\n\tOk(())\n}\n\n#[tokio::test]\nasync fn only_owner_can_change_ownership() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server =\n\t\tMockServer::new(ServerOptions::with_schema(Schema::with_objects(vec![\n\t\t\tObject {\n\t\t\t\tname: \"test-object\".to_string(),\n\n\t\t\t\tclass_id: 2003,\n\t\t\t\townership: Ownership::Creator,\n\t\t\t\tlifetime: schema::Lifetime::Owner,\n\t\t\t\tblend: schema::Blend::default(),\n\t\t\t\t..Default::default()\n\t\t\t},\n\t\t])?))\n\t\t.await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\tlet mut client3 = server.new_session().await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tclient3.push(update).await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\n\tlet objectid = client1.derive_global_id(1);\n\tupdate\n\t\t.object(objectid)\n\t\t.attributes\n\t\t.insert(WellKnownAttribute::ClassId as u16, Value::Uint64(2003));\n\n\tclient1.push(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tlet resp2 = client2.roundtrip(update).await?;\n\n\tassert_eq!(resp2.players.len(), 2);\n\tassert_eq!(resp2.objects.len(), 1);\n\n\tassert_eq!(resp2.players[\u0026client1.id()].attributes.len(), 1);\n\tassert_eq!(resp2.objects[\u0026objectid].attributes.len(), 2);\n\n\tassert_eq!(\n\t\tresp2.objects[\u0026objectid].attributes[\u0026(WellKnownAttribute::OwnerId as u16)],\n\t\tValue::Uint32(client1.id())\n\t);\n\n\tassert_eq!(\n\t\tresp2.objects[\u0026objectid].attributes[\u0026(WellKnownAttribute::ClassId as u16)],\n\t\tValue::Uint64(2003)\n\t);\n\n\tlet mut update = TickUpdate::default();\n\tupdate.object(objectid).attributes.insert(\n\t\tWellKnownAttribute::OwnerId as u16,\n\t\tValue::Uint32(client2.id()),\n\t);\n\n\tclient2.roundtrip(update).await?;\n\n\tlet resp3 = client3.pull().await?;\n\tassert_eq!(resp3.players.len(), 2);\n\tassert_eq!(resp3.objects.len(), 1);\n\tassert_eq!(resp3.objects[\u0026objectid].attributes.len(), 2);\n\n\t// the ownership change should not have been applied and reverted to old owner\n\tassert_eq!(\n\t\tresp3.objects[\u0026objectid].attributes[\u0026(WellKnownAttribute::OwnerId as u16)],\n\t\tValue::Uint32(client1.id())\n\t);\n\n\tassert_eq!(\n\t\tresp2.objects[\u0026objectid].attributes[\u0026(WellKnownAttribute::ClassId as u16)],\n\t\tValue::Uint64(2003)\n\t);\n\n\t// give some time for the last update score to decay with time\n\t// so the authority mechanism allows this write through, because\n\t// it is coming from a different client and that halfs that score.\n\ttokio::time::sleep(Duration::from_millis(500)).await;\n\n\t// client 1 as the current owner should be able\n\t// to transfer ownership to client 2.\n\tlet mut update = TickUpdate::default();\n\tupdate.object(objectid).attributes.insert(\n\t\tWellKnownAttribute::OwnerId as u16,\n\t\tValue::Uint32(client2.id()),\n\t);\n\tlet resp1 = client1.roundtrip(update).await?;\n\n\tassert_eq!(resp1.players.len(), 2);\n\tassert_eq!(resp1.objects.len(), 0);\n\n\t// client 2 should now see an updated ownership\n\t// of object1\n\tlet resp2 = client2.pull().await?;\n\tassert_eq!(resp2.players.len(), 0);\n\tassert_eq!(resp2.objects.len(), 1);\n\tassert_eq!(resp2.objects[\u0026objectid].attributes.len(), 1);\n\tassert_eq!(\n\t\tresp2.objects[\u0026objectid].attributes[\u0026(WellKnownAttribute::OwnerId as u16)],\n\t\tValue::Uint32(client2.id())\n\t);\n\n\t// give some time for the last update score to decay with time\n\t// so the authority mechanism allows this write through, because\n\t// it is coming from a different client and that halfs that score.\n\ttokio::time::sleep(Duration::from_millis(500)).await;\n\n\t// new owner can reassign ownership to the old owner\n\tlet mut update = TickUpdate::default();\n\tupdate.object(objectid).attributes.insert(\n\t\tWellKnownAttribute::OwnerId as u16,\n\t\tValue::Uint32(client1.id()),\n\t);\n\tlet resp2 = client2.roundtrip(update).await?;\n\n\tassert_eq!(resp2.players.len(), 0);\n\tassert_eq!(resp2.objects.len(), 0);\n\n\tlet resp1 = client1.pull().await?;\n\tassert_eq!(resp1.objects.len(), 1);\n\tassert_eq!(resp1.objects[\u0026objectid].attributes.len(), 1);\n\tassert_eq!(\n\t\tresp1.objects[\u0026objectid].attributes[\u0026(WellKnownAttribute::OwnerId as u16)],\n\t\tValue::Uint32(client1.id())\n\t);\n\n\tOk(())\n}\n\n/// shared objects do not have an owner automatically assigned to\n/// them, players however are free to assume ownership of shared\n/// objects.\n#[tokio::test]\nasync fn shared_objects() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::default().await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\n\t// this object should be allowed to be spawned by client 1\n\t// because it is derived from its session id. It will have\n\t// the owner assigned to it by default.\n\tlet obj1 = client1.derive_global_id(1);\n\n\t// this object should be allowd to be spawned by client 1\n\t// because it is in the shared namespace, it should however\n\t// not have an owner assigned to it by default.\n\tlet obj2 = derive_shared_id(2);\n\n\t// this object should not be allowed to be spawned by client1\n\t// because it is not in the client1 or shared namespace.\n\tlet obj3: ObjectId = random();\n\n\tupdate.object(obj1).attributes.insert(\n\t\tWellKnownAttribute::Position as AttributeId,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\n\tupdate.object(obj2).attributes.insert(\n\t\tWellKnownAttribute::Position as AttributeId,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\n\tupdate.object(obj3).attributes.insert(\n\t\tWellKnownAttribute::Position as AttributeId,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\n\tclient1.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((2.0, 3.0, 4.0)),\n\t);\n\n\tlet resp2 = client2.roundtrip(update).await?;\n\n\tassert_eq!(resp2.players.len(), 1);\n\tassert_eq!(resp2.objects.len(), 2);\n\n\tassert_eq!(resp2.objects[\u0026obj1].attributes.len(), 2);\n\tassert_eq!(\n\t\tresp2.objects[\u0026obj1].attributes[\u0026(WellKnownAttribute::OwnerId as u16)],\n\t\tValue::Uint32(client1.id())\n\t);\n\tassert_eq!(\n\t\tresp2.objects[\u0026obj1].attributes[\u0026(WellKnownAttribute::Position as u16)],\n\t\tValue::Vec3((1.0, 2.0, 3.0))\n\t);\n\n\tassert_eq!(resp2.objects[\u0026obj2].attributes.len(), 1);\n\tassert_eq!(\n\t\tresp2.objects[\u0026obj2].attributes[\u0026(WellKnownAttribute::Position as u16)],\n\t\tValue::Vec3((1.0, 2.0, 3.0))\n\t);\n\tOk(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","tests","relevance.rs"],"content":"use {\n\tcrate::{\n\t\topts::{Profile, ServerOptions},\n\t\trelevance::{GroupIndexConfig, SpatialIndexConfig},\n\t\tschema::{Object, Ownership, Schema},\n\t\ttests::mock::{MockServer, SessionTestExt, TickUpdate},\n\t},\n\tquark_client_sdk::{Session, Value, WellKnownAttribute},\n\tstd::time::Duration,\n};\n\n#[tokio::test]\nasync fn two_players_group_membership_index() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::new(ServerOptions::with_profile_and_schema(\n\t\tProfile {\n\t\t\tspatial_index: SpatialIndexConfig {\n\t\t\t\tmax_radius: 10,\n\t\t\t\tmap_width: 100000,\n\t\t\t\tmap_height: 100000,\n\t\t\t\tcells_count_x: 1000,\n\t\t\t\tcells_count_y: 1000,\n\t\t\t\treindex_interval: Duration::from_millis(500),\n\t\t\t},\n\t\t\tgroup_index: GroupIndexConfig {\n\t\t\t\treindex_interval: Duration::from_millis(500),\n\t\t\t},\n\t\t\t..Default::default()\n\t\t},\n\t\tSchema::with_objects(vec![Object {\n\t\t\tname: \"test\".to_string(),\n\t\t\tclass_id: 2001,\n\t\t\townership: Ownership::Detached,\n\t\t\t..Default::default()\n\t\t}])?,\n\t))\n\t.await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\n\tupdate\n\t\t.object(client1.derive_global_id(3))\n\t\t.attributes\n\t\t.insert(\n\t\t\tWellKnownAttribute::Position as u16,\n\t\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t\t);\n\tupdate\n\t\t.object(client1.derive_global_id(3))\n\t\t.attributes\n\t\t.insert(WellKnownAttribute::ClassId as u16, Value::Uint32(2001));\n\n\tclient1.roundtrip(update).await?;\n\tserver.wait_for_group_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((10000.0, 20000.0, 30000.0)),\n\t);\n\n\t// should not be relevant\n\tlet client2_resp = client2.roundtrip(update).await?;\n\tassert!(client2_resp.players.is_empty());\n\tassert!(client2_resp.objects.is_empty());\n\n\t// now player one joins group 8\n\tlet mut update = TickUpdate::default();\n\tupdate\n\t\t.player\n\t\t.attributes\n\t\t.insert(WellKnownAttribute::GroupId as u16, Value::Uint32(8));\n\tclient1.roundtrip(update).await?;\n\n\tserver.wait_for_group_reindex().await;\n\n\t// now ensure that client2 receives the update\n\tlet mut update = TickUpdate::default();\n\tupdate\n\t\t.player\n\t\t.attributes\n\t\t.insert(WellKnownAttribute::GroupId as u16, Value::Uint32(8));\n\n\tlet client2_resp = client2.roundtrip(update).await?;\n\tassert_eq!(client2_resp.players.len(), 1);\n\tassert_eq!(client2_resp.objects.len(), 0);\n\n\tassert_eq!(\n\t\tclient2_resp.players[\u0026client1.id()].attributes\n\t\t\t[\u0026(WellKnownAttribute::GroupId as u16)],\n\t\tValue::Uint32(8)\n\t);\n\n\tassert_eq!(\n\t\tclient2_resp.players[\u0026client1.id()].attributes\n\t\t\t[\u0026(WellKnownAttribute::Position as u16)],\n\t\tValue::Vec3((1.0, 2.0, 3.0))\n\t);\n\n\t// still not seeing object3\n\n\tlet mut update = TickUpdate::default();\n\tupdate\n\t\t.object(client1.derive_global_id(3))\n\t\t.attributes\n\t\t.insert(WellKnownAttribute::GroupId as u16, Value::Uint32(8));\n\tclient1.roundtrip(update).await?;\n\n\tserver.wait_for_group_reindex().await;\n\n\t// now client 2 should see the object because they're both in\n\t// the same group\n\tlet client2_resp = client2.pull().await?;\n\n\tassert_eq!(client2_resp.players.len(), 0);\n\tassert_eq!(client2_resp.objects.len(), 1);\n\tassert_eq!(client2_resp.events.len(), 0);\n\n\tassert_eq!(\n\t\tclient2_resp.objects[\u0026client1.derive_global_id(3)].attributes\n\t\t\t[\u0026(WellKnownAttribute::Position as u16)],\n\t\tValue::Vec3((1.0, 2.0, 3.0))\n\t);\n\n\tOk(())\n}\n\n#[tokio::test]\nasync fn relevance_centroid_delegation() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::new(ServerOptions::default()).await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\n\tlet object1id = client1.derive_global_id(1);\n\tlet mut update = TickUpdate::default();\n\tupdate.object(object1id).attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\n\tclient1.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet object2id = client2.derive_global_id(2);\n\tlet mut update = TickUpdate::default();\n\tupdate.object(object2id).attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((2.0, 3.0, 4.0)),\n\t);\n\tlet resp2 = client2.roundtrip(update).await?;\n\n\t// player has no position or any other attributes\n\t// should not see any objects from player1\n\tassert!(resp2.players.is_empty());\n\tassert!(resp2.objects.is_empty());\n\n\t// wait for relevance query cache to expire\n\tserver.wait_for_spatial_reindex().await;\n\n\t// now delegate the centroid of interest of player2\n\t// to object2 and ensure that client2 receives\n\t// updates about objects relevant to object2.\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Delegate as u16,\n\t\tValue::Uint64(object2id),\n\t);\n\tlet resp2 = client2.roundtrip(update).await?;\n\n\tassert!(resp2.players.is_empty());\n\tassert_eq!(resp2.objects.len(), 1);\n\tassert_eq!(\n\t\tresp2.objects[\u0026object1id].attributes\n\t\t\t[\u0026(WellKnownAttribute::Position as u16)],\n\t\tValue::Vec3((1.0, 2.0, 3.0))\n\t);\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Delegate as u16,\n\t\tValue::Uint64(object1id),\n\t);\n\tlet resp1 = client1.roundtrip(update).await?;\n\n\tassert!(resp1.players.is_empty());\n\tassert_eq!(resp1.objects.len(), 1);\n\tassert_eq!(\n\t\tresp1.objects[\u0026object2id].attributes\n\t\t\t[\u0026(WellKnownAttribute::Position as u16)],\n\t\tValue::Vec3((2.0, 3.0, 4.0))\n\t);\n\n\tOk(())\n}\n\n/// same test as above, except the system should reject the interest\n/// delegation because the object is not owned by the player.\n#[tokio::test]\nasync fn relevance_centroid_delegation_permissions() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::new(ServerOptions::default()).await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\n\tlet object1id = client1.derive_global_id(1);\n\tlet mut update = TickUpdate::default();\n\tupdate.object(object1id).attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\n\tclient1.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet object2id = client2.derive_global_id(2);\n\tlet mut update = TickUpdate::default();\n\tupdate.object(object2id).attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((2.0, 3.0, 4.0)),\n\t);\n\tlet resp2 = client2.roundtrip(update).await?;\n\n\t// player has no position or any other attributes\n\t// should not see any objects from player1\n\tassert!(resp2.players.is_empty());\n\tassert!(resp2.objects.is_empty());\n\n\t// wait for relevance query cache to expire\n\tserver.wait_for_spatial_reindex().await;\n\n\t// now delegate the centroid of interest of player2\n\t// to object2 and ensure that client2 receives\n\t// updates about objects relevant to object2.\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Delegate as u16,\n\t\tValue::Uint64(object1id),\n\t);\n\tlet resp2 = client2.roundtrip(update).await?;\n\n\tassert!(resp2.players.is_empty());\n\tassert!(resp2.objects.is_empty());\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Delegate as u16,\n\t\tValue::Uint64(object2id),\n\t);\n\tlet resp1 = client1.roundtrip(update).await?;\n\n\tassert!(resp1.players.is_empty());\n\tassert!(resp1.objects.is_empty());\n\n\tOk(())\n}\n\n#[tokio::test]\nasync fn spatial_index_different_levels() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::new(ServerOptions::default()).await?;\n\n\tlet mut client1 = server.new_session().await?; // default level\n\tlet mut client2 = server.new_session().await?; // default level\n\tlet mut client3 = server.new_session().await?; // level 1\n\tlet mut client4 = server.new_session().await?; // level 1\n\tlet mut client5 = server.new_session().await?; // level 2\n\tlet mut client6 = server.new_session().await?; // level 2\n\n\tasync fn set_position(\n\t\tclient: \u0026mut Session,\n\t\tlevel: u32,\n\t\tposition: (f32, f32, f32),\n\t) -\u003e anyhow::Result\u003c()\u003e {\n\t\tlet mut update = TickUpdate::default();\n\t\tif level == 0 {\n\t\t\tupdate\n\t\t\t\t.player\n\t\t\t\t.attributes\n\t\t\t\t.insert(WellKnownAttribute::Position as u16, Value::Vec3(position));\n\t\t} else {\n\t\t\tupdate.player.attributes.insert(\n\t\t\t\tWellKnownAttribute::Position as u16,\n\t\t\t\tValue::Vec4((position.0, position.1, position.2, level as f32)),\n\t\t\t);\n\t\t}\n\n\t\tclient.push(update).await?;\n\n\t\tOk(())\n\t}\n\n\tset_position(\u0026mut client1, 0, (1.0, 2.0, 3.0)).await?;\n\tset_position(\u0026mut client2, 0, (1.0, 2.0, 3.0)).await?;\n\tset_position(\u0026mut client3, 1, (1.0, 2.0, 3.0)).await?;\n\tset_position(\u0026mut client4, 1, (1.0, 2.0, 3.0)).await?;\n\tset_position(\u0026mut client5, 2, (1.0, 2.0, 3.0)).await?;\n\tset_position(\u0026mut client6, 2, (1.0, 2.0, 3.0)).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet resp1 = client1.pull().await?;\n\tlet resp2 = client2.pull().await?;\n\tlet resp3 = client3.pull().await?;\n\tlet resp4 = client4.pull().await?;\n\tlet resp5 = client5.pull().await?;\n\tlet resp6 = client6.pull().await?;\n\n\t// level 0 players should see each other\n\tassert_eq!(resp1.players.keys().cloned().collect::\u003cVec\u003c_\u003e\u003e(), vec![\n\t\tclient2.id()\n\t]);\n\tassert_eq!(resp2.players.keys().cloned().collect::\u003cVec\u003c_\u003e\u003e(), vec![\n\t\tclient1.id()\n\t]);\n\n\t// level 1 players should see each other\n\tassert_eq!(resp3.players.keys().cloned().collect::\u003cVec\u003c_\u003e\u003e(), vec![\n\t\tclient4.id()\n\t]);\n\tassert_eq!(resp4.players.keys().cloned().collect::\u003cVec\u003c_\u003e\u003e(), vec![\n\t\tclient3.id()\n\t]);\n\n\t// level 2 players should see each other\n\tassert_eq!(resp5.players.keys().cloned().collect::\u003cVec\u003c_\u003e\u003e(), vec![\n\t\tclient6.id()\n\t]);\n\tassert_eq!(resp6.players.keys().cloned().collect::\u003cVec\u003c_\u003e\u003e(), vec![\n\t\tclient5.id()\n\t]);\n\n\tOk(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","tests","replication.rs"],"content":"use {\n\tcrate::{\n\t\topts::ServerOptions,\n\t\tstate::EntityId,\n\t\ttests::mock::{\n\t\t\tget_next_listen_address,\n\t\t\tDirGen,\n\t\t\tMockServer,\n\t\t\tSessionTestExt,\n\t\t\tTickUpdate,\n\t\t},\n\t},\n\tquark_client_sdk::{\n\t\tprotocol::events::SystemEvents,\n\t\tEventClass,\n\t\tOutboundEvent,\n\t\tRecipient,\n\t\tSession,\n\t\tValue,\n\t\tWellKnownAttribute,\n\t},\n\tstd::{collections::HashMap, time::Duration},\n\turl::Url,\n};\n\n#[tokio::test]\nasync fn replicate_player() -\u003e anyhow::Result\u003c()\u003e {\n\tlet mut url: Url = format!(\"udp://{}\", get_next_listen_address()).parse()?;\n\n\tlet produceropts = ServerOptions {\n\t\treplicate_to: vec![url.clone()],\n\t\t..Default::default()\n\t};\n\n\turl.set_query(Some(\"accept_own_addr=true\"));\n\tlet consumeropts = ServerOptions {\n\t\treplicate_from: vec![url],\n\t\t..Default::default()\n\t};\n\n\tlet producer = MockServer::new(produceropts).await?;\n\n\tlet consumer = MockServer::new(consumeropts).await?;\n\n\tlet mut producer_session = producer.new_session().await?;\n\tlet mut consumer_session = consumer.new_session().await?;\n\n\ttracing::trace!(\"producer id: {}\", producer_session.id());\n\ttracing::trace!(\"consumer id: {}\", consumer_session.id());\n\n\t// on server 1 we create a new player\n\t// and publish it to the server.\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tupdate.player.attributes.insert(15, Value::Uint32(42));\n\n\tproducer_session.roundtrip(update).await?;\n\n\tconsumer.wait_for_spatial_reindex().await;\n\n\t// on server 2 we should see the player published\n\t// by server 1. Both players have the same position\n\t// to make them relevant to each other.\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((2.0, 3.0, 4.0)),\n\t);\n\n\tlet consumer_resp = consumer_session.roundtrip(update).await?;\n\n\tassert_eq!(consumer_resp.players.len(), 1);\n\tassert!(consumer_resp.players.contains_key(\u0026producer_session.id()));\n\tassert_eq!(consumer_resp.players.keys().collect::\u003cVec\u003c_\u003e\u003e(), vec![\n\t\t\u0026producer_session.id()\n\t]);\n\n\tassert_eq!(\n\t\tconsumer_resp.players[\u0026producer_session.id()].attributes[\u00261],\n\t\tValue::Vec3((1.0, 2.0, 3.0))\n\t);\n\n\tassert_eq!(\n\t\tconsumer_resp.players[\u0026producer_session.id()].attributes[\u002615],\n\t\tValue::Uint32(42)\n\t);\n\n\t// initial replication works, now producer updates an existing attribute and\n\t// it should be replicated to the consumer asap.\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((3.0, 4.0, 5.0)),\n\t);\n\tupdate.player.attributes.insert(15, Value::Uint32(43));\n\n\tproducer_session.roundtrip(update).await?;\n\n\t// wait for UDP propagation\n\ttokio::time::sleep(Duration::from_millis(50)).await;\n\n\tlet consumer_resp2 = consumer_session.pull().await?;\n\n\tassert_eq!(consumer_resp2.players.len(), 1);\n\tassert!(consumer_resp2.players.contains_key(\u0026producer_session.id()));\n\tassert_eq!(\n\t\tconsumer_resp2.players[\u0026producer_session.id()].attributes[\u00261],\n\t\tValue::Vec3((3.0, 4.0, 5.0))\n\t);\n\n\tassert_eq!(\n\t\tconsumer_resp2.players[\u0026producer_session.id()].attributes[\u002615],\n\t\tValue::Uint32(43)\n\t);\n\n\tOk(())\n}\n\n#[tokio::test]\nasync fn replicate_objects() -\u003e anyhow::Result\u003c()\u003e {\n\tlet mut url: Url = format!(\"udp://{}\", get_next_listen_address()).parse()?;\n\n\tlet produceropts = ServerOptions {\n\t\treplicate_to: vec![url.clone()],\n\t\t..Default::default()\n\t};\n\n\turl.set_query(Some(\"accept_own_addr=true\"));\n\tlet consumeropts = ServerOptions {\n\t\treplicate_from: vec![url],\n\t\t..Default::default()\n\t};\n\n\tlet producer = MockServer::new(produceropts).await?;\n\n\tlet consumer = MockServer::new(consumeropts).await?;\n\n\tlet mut producer_session = producer.new_session().await?;\n\tlet mut consumer_session = consumer.new_session().await?;\n\n\t// on server 1 we create a new player\n\t// and publish it to the server.\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tupdate.player.attributes.insert(15, Value::Uint32(42));\n\n\tlet obj1id = producer_session.derive_global_id(15);\n\tupdate.object(obj1id).attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((2.0, 3.0, 4.0)),\n\t);\n\n\tupdate\n\t\t.object(obj1id)\n\t\t.attributes\n\t\t.insert(16, Value::Uint32(43));\n\n\tproducer_session.roundtrip(update).await?;\n\n\t// wait for UDP propagation\n\ttokio::time::sleep(Duration::from_millis(100)).await;\n\n\t// wait for consumer server to reindex\n\tconsumer.wait_for_spatial_reindex().await;\n\n\t// on server 2 we should see the player published\n\t// by server 1. Both players have the same position\n\t// to make them relevant to each other.\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\n\tlet consumer_resp = consumer_session.roundtrip(update).await?;\n\n\tassert_eq!(consumer_resp.players.len(), 1);\n\tassert!(consumer_resp.players.contains_key(\u0026producer_session.id()));\n\tassert_eq!(\n\t\tconsumer_resp.players[\u0026producer_session.id()].attributes[\u002615],\n\t\tValue::Uint32(42)\n\t);\n\n\tassert_eq!(consumer_resp.objects.len(), 1);\n\tassert!(consumer_resp.objects.contains_key(\u0026obj1id));\n\tassert_eq!(\n\t\tconsumer_resp.objects[\u0026obj1id].attributes[\u002616],\n\t\tValue::Uint32(43)\n\t);\n\n\t// initial replication works, now producer updates an existing object and\n\t// it should be replicated to the consumer asap.\n\n\tlet mut update = TickUpdate::default();\n\tupdate\n\t\t.object(obj1id)\n\t\t.attributes\n\t\t.insert(15, Value::Uint32(43));\n\n\tproducer_session.roundtrip(update).await?;\n\n\t// wait for UDP propagation\n\ttokio::time::sleep(Duration::from_millis(50)).await;\n\n\tlet consumer_resp2 = consumer_session.pull().await?;\n\n\tassert_eq!(consumer_resp2.players.len(), 0);\n\tassert_eq!(consumer_resp2.objects.len(), 1);\n\tassert!(consumer_resp2.objects.contains_key(\u0026obj1id));\n\tassert_eq!(\n\t\tconsumer_resp2.objects[\u0026obj1id].attributes[\u002615],\n\t\tValue::Uint32(43)\n\t);\n\n\tOk(())\n}\n\n#[tokio::test]\nasync fn replicate_events() -\u003e anyhow::Result\u003c()\u003e {\n\tlet mut url: Url = format!(\"udp://{}\", get_next_listen_address()).parse()?;\n\n\tlet produceropts = ServerOptions {\n\t\treplicate_to: vec![url.clone()],\n\t\t..Default::default()\n\t};\n\n\turl.set_query(Some(\"accept_own_addr=true\"));\n\tlet consumeropts = ServerOptions {\n\t\treplicate_from: vec![url],\n\t\t..Default::default()\n\t};\n\n\tlet producer = MockServer::new(produceropts).await?;\n\n\tlet consumer = MockServer::new(consumeropts).await?;\n\n\tlet mut producer_session = producer.new_session().await?;\n\tlet mut producer_session2 = producer.new_session().await?;\n\tlet mut consumer_session = consumer.new_session().await?;\n\n\ttracing::trace!(\"producer1 id: {}\", producer_session.id());\n\ttracing::trace!(\"producer2 id: {}\", producer_session2.id());\n\ttracing::trace!(\"consumer id: {}\", consumer_session.id());\n\n\t// on server 1 we create a new player\n\t// and publish it to the server.\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tupdate.player.attributes.insert(15, Value::Uint32(42));\n\n\tproducer_session.roundtrip(update).await?;\n\n\t// on server 1 we create another player\n\t// and publish it to the server. It should receive\n\t// the event from the first player.\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((4.0, 5.0, 6.0)),\n\t);\n\tupdate.player.attributes.insert(12, Value::Uint32(12));\n\n\tproducer_session2.roundtrip(update).await?;\n\n\t// wait for reindex\n\tconsumer.wait_for_spatial_reindex().await;\n\n\t// on server 2 we should see the player published\n\t// by server 1. Both players have the same position\n\t// to make them relevant to each other.\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\n\tlet consumer_resp = consumer_session.roundtrip(update).await?;\n\n\tassert_eq!(consumer_resp.players.len(), 2);\n\tassert!(consumer_resp.players.contains_key(\u0026producer_session.id()));\n\tassert_eq!(\n\t\tconsumer_resp.players[\u0026producer_session.id()].attributes[\u002615],\n\t\tValue::Uint32(42)\n\t);\n\n\tassert!(consumer_resp.players.contains_key(\u0026producer_session2.id()));\n\tassert_eq!(\n\t\tconsumer_resp.players[\u0026producer_session2.id()].attributes[\u002612],\n\t\tValue::Uint32(12)\n\t);\n\n\t// wait for reindex\n\tconsumer.wait_for_spatial_reindex().await;\n\n\t// producer's sessions are visible and relevant to the consumer session\n\t// now produce an event by one of the producers sessions and ensure\n\t// that both the second producer session and the consumer receive it.\n\n\tlet mut update = TickUpdate::default();\n\tupdate.events.push(OutboundEvent {\n\t\tclass: 2001,\n\t\tpayload: (\u0026[1, 2, 3, 4, 5, 6, 7, 8][..]).try_into().unwrap(),\n\t\trecipient: Recipient::default(),\n\t});\n\n\tproducer_session.roundtrip(update).await?;\n\n\t// wait for UDP propagation\n\ttokio::time::sleep(Duration::from_millis(150)).await;\n\n\tlet consumer_resp2 = consumer_session.pull().await?;\n\tassert_eq!(consumer_resp2.players.len(), 0);\n\tassert_eq!(consumer_resp2.objects.len(), 0);\n\tassert_eq!(consumer_resp2.events.len(), 1);\n\tassert_eq!(consumer_resp2.events[0].class, 2001);\n\tassert_eq!(\n\t\tconsumer_resp2.events[0].sender,\n\t\tEntityId::Player(producer_session.id())\n\t);\n\tassert_eq!(\n\t\t\u0026consumer_resp2.events[0].payload[..],\n\t\t\u0026[1, 2, 3, 4, 5, 6, 7, 8][..]\n\t);\n\n\t// also ensure that the event was received by a player on the same\n\t// server as the event publisher\n\n\tlet producer2_resp = producer_session2.pull().await?;\n\tassert_eq!(producer2_resp.events.len(), 1);\n\tassert_eq!(producer2_resp.events[0].class, 2001);\n\tassert_eq!(\n\t\tproducer2_resp.events[0].sender,\n\t\tEntityId::Player(producer_session.id())\n\t);\n\tassert_eq!(\n\t\t\u0026producer2_resp.events[0].payload[..],\n\t\t\u0026[1, 2, 3, 4, 5, 6, 7, 8][..]\n\t);\n\n\tOk(())\n}\n\n#[tokio::test]\nasync fn replicate_player_disconnect() -\u003e anyhow::Result\u003c()\u003e {\n\tlet mut url: Url = format!(\"udp://{}\", get_next_listen_address()).parse()?;\n\n\tlet produceropts = ServerOptions {\n\t\treplicate_to: vec![url.clone()],\n\t\t..Default::default()\n\t};\n\n\turl.set_query(Some(\"accept_own_addr=true\"));\n\tlet consumeropts = ServerOptions {\n\t\treplicate_from: vec![url],\n\t\t..Default::default()\n\t};\n\n\tlet producer = MockServer::new(produceropts).await?;\n\tlet consumer = MockServer::new(consumeropts).await?;\n\n\tlet mut producer_session = producer.new_session().await?;\n\tlet mut consumer_session = consumer.new_session().await?;\n\n\ttracing::trace!(\"producer id: {}\", producer_session.id());\n\ttracing::trace!(\"consumer id: {}\", consumer_session.id());\n\n\t// on server 1 we create a new player\n\t// and publish it to the server.\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tupdate.player.attributes.insert(15, Value::Uint32(42));\n\n\tproducer_session.roundtrip(update).await?;\n\n\tconsumer.wait_for_spatial_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((2.0, 3.0, 4.0)),\n\t);\n\n\tlet consumer_resp = consumer_session.roundtrip(update).await?;\n\n\t// consumer sees producer player and is relevant to it and it\n\t// has received an update about it. From this point on it should\n\t// receive an event if it disconnects.\n\tassert_eq!(consumer_resp.players.len(), 1);\n\tassert!(consumer_resp.players.contains_key(\u0026producer_session.id()));\n\tassert_eq!(consumer_resp.players.keys().collect::\u003cVec\u003c_\u003e\u003e(), vec![\n\t\t\u0026producer_session.id()\n\t]);\n\n\tassert_eq!(\n\t\tconsumer_resp.players[\u0026producer_session.id()].attributes[\u00261],\n\t\tValue::Vec3((1.0, 2.0, 3.0))\n\t);\n\n\tassert_eq!(\n\t\tconsumer_resp.players[\u0026producer_session.id()].attributes[\u002615],\n\t\tValue::Uint32(42)\n\t);\n\n\t// disconnect producer player\n\tlet producer_session_id = producer_session.id();\n\tdrop(producer_session);\n\n\t// wait for UDP propagation\n\ttokio::time::sleep(Duration::from_millis(50)).await;\n\n\tlet consumer_resp2 = consumer_session.pull().await?;\n\tassert_eq!(consumer_resp2.players.len(), 0);\n\tassert_eq!(consumer_resp2.objects.len(), 0);\n\tassert_eq!(consumer_resp2.events.len(), 1);\n\tassert_eq!(\n\t\tconsumer_resp2.events[0].class,\n\t\tSystemEvents::PlayerDisconnected as EventClass\n\t);\n\tassert_eq!(consumer_resp2.events[0].sender, EntityId::SYSTEM_PLAYER); // server\n\tassert_eq!(\n\t\t\u0026consumer_resp2.events[0].payload[..],\n\t\t\u0026producer_session_id.to_le_bytes()[..]\n\t);\n\n\tOk(())\n}\n\n#[tokio::test]\nasync fn replicate_object_despawn() -\u003e anyhow::Result\u003c()\u003e {\n\tlet mut url: Url = format!(\"udp://{}\", get_next_listen_address()).parse()?;\n\n\tlet produceropts = ServerOptions {\n\t\treplicate_to: vec![url.clone()],\n\t\t..Default::default()\n\t};\n\n\turl.set_query(Some(\"accept_own_addr=true\"));\n\tlet consumeropts = ServerOptions {\n\t\treplicate_from: vec![url],\n\t\t..Default::default()\n\t};\n\n\tlet producer = MockServer::new(produceropts).await?;\n\n\tlet consumer = MockServer::new(consumeropts).await?;\n\n\tlet mut producer_session = producer.new_session().await?;\n\tlet mut consumer_session = consumer.new_session().await?;\n\n\ttracing::trace!(\"producer id: {}\", producer_session.id());\n\ttracing::trace!(\"consumer id: {}\", consumer_session.id());\n\n\t// on server 1 we create a new player\n\t// and publish it to the server.\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tupdate.player.attributes.insert(15, Value::Uint32(42));\n\n\tlet obj1id = producer_session.derive_global_id(15);\n\tupdate.object(obj1id).attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((2.0, 3.0, 4.0)),\n\t);\n\n\tupdate\n\t\t.object(obj1id)\n\t\t.attributes\n\t\t.insert(16, Value::Uint32(43));\n\n\tproducer_session.roundtrip(update).await?;\n\n\t// wait for UDP propagation\n\ttokio::time::sleep(Duration::from_millis(100)).await;\n\n\t// wait for consumer server to reindex\n\tconsumer.wait_for_spatial_reindex().await;\n\n\t// on server 2 we should see the player published\n\t// by server 1. Both players have the same position\n\t// to make them relevant to each other.\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\n\tlet consumer_resp = consumer_session.roundtrip(update).await?;\n\n\tassert_eq!(consumer_resp.players.len(), 1);\n\tassert!(consumer_resp.players.contains_key(\u0026producer_session.id()));\n\tassert_eq!(\n\t\tconsumer_resp.players[\u0026producer_session.id()].attributes[\u002615],\n\t\tValue::Uint32(42)\n\t);\n\n\tassert_eq!(consumer_resp.objects.len(), 1);\n\tassert!(consumer_resp.objects.contains_key(\u0026obj1id));\n\tassert_eq!(\n\t\tconsumer_resp.objects[\u0026obj1id].attributes[\u002616],\n\t\tValue::Uint32(43)\n\t);\n\n\t// good so far, now producer despawns object\n\tlet mut update = TickUpdate::default();\n\tupdate.events.push(OutboundEvent {\n\t\tclass: SystemEvents::ObjectsDespawned as EventClass,\n\t\tpayload: obj1id.to_le_bytes()[..].try_into().unwrap(),\n\t\trecipient: Recipient::default(),\n\t});\n\n\tproducer_session.roundtrip(update).await?;\n\n\t// wait for UDP propagation\n\ttokio::time::sleep(Duration::from_millis(50)).await;\n\n\t// consumer should see the despawn event\n\tlet consumer_resp2 = consumer_session.pull().await?;\n\tassert_eq!(consumer_resp2.players.len(), 0);\n\tassert_eq!(consumer_resp2.objects.len(), 0);\n\tassert_eq!(consumer_resp2.events.len(), 1);\n\tassert_eq!(\n\t\tconsumer_resp2.events[0].class,\n\t\tSystemEvents::ObjectsDespawned as EventClass\n\t);\n\n\tassert_eq!(\n\t\t\u0026consumer_resp2.events[0].payload[..],\n\t\t\u0026obj1id.to_le_bytes()[..]\n\t);\n\n\tOk(())\n}\n\n// same as replicate_player but with ignore_self set to true\n// on the consumer. this means that the consumer will ignore packets\n// coming from its own address.\n#[tokio::test]\nasync fn replicate_ignore_self() -\u003e anyhow::Result\u003c()\u003e {\n\tlet url: Url = format!(\"udp://{}\", get_next_listen_address()).parse()?;\n\n\tlet produceropts = ServerOptions {\n\t\treplicate_to: vec![url.clone()],\n\t\t..Default::default()\n\t};\n\n\tlet consumeropts = ServerOptions {\n\t\treplicate_from: vec![url],\n\t\t..Default::default()\n\t};\n\n\tlet producer = MockServer::new(produceropts).await?;\n\n\tlet consumer = MockServer::new(consumeropts).await?;\n\n\tlet mut producer_session = producer.new_session().await?;\n\tlet mut consumer_session = consumer.new_session().await?;\n\n\ttracing::trace!(\"producer id: {}\", producer_session.id());\n\ttracing::trace!(\"consumer id: {}\", consumer_session.id());\n\n\t// on server 1 we create a new player\n\t// and publish it to the server.\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tupdate.player.attributes.insert(15, Value::Uint32(42));\n\n\tproducer_session.roundtrip(update).await?;\n\n\tconsumer.wait_for_spatial_reindex().await;\n\n\t// on server 2 we should see the player published\n\t// by server 1. Both players have the same position\n\t// to make them relevant to each other.\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((2.0, 3.0, 4.0)),\n\t);\n\n\tlet consumer_resp = consumer_session.roundtrip(update).await?;\n\n\tassert_eq!(consumer_resp.players.len(), 0);\n\tassert!(!consumer_resp.players.contains_key(\u0026producer_session.id()));\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((3.0, 4.0, 5.0)),\n\t);\n\tupdate.player.attributes.insert(15, Value::Uint32(43));\n\n\tproducer_session.roundtrip(update).await?;\n\n\t// wait for UDP propagation\n\ttokio::time::sleep(Duration::from_millis(50)).await;\n\n\tlet consumer_resp2 = consumer_session.pull().await?;\n\n\tassert_eq!(consumer_resp2.players.len(), 0);\n\tassert!(!consumer_resp2.players.contains_key(\u0026producer_session.id()));\n\n\tOk(())\n}\n\nmacro_rules! make_attribute_replication_test {\n\t($name:ident, $value:expr, $value2:expr) =\u003e {\n\t\t#[tokio::test]\n\t\tasync fn $name() -\u003e anyhow::Result\u003c()\u003e {\n\t\t\tuse crate::state::entity::AttributeId;\n\t\t\tconst TEST_ATTRIBUTE_ID: AttributeId = 1020;\n\n\t\t\tlet mut url: Url =\n\t\t\t\tformat!(\"udp://{}\", get_next_listen_address()).parse()?;\n\n\t\t\tlet produceropts = ServerOptions {\n\t\t\t\treplicate_to: vec![url.clone()],\n\t\t\t\t..Default::default()\n\t\t\t};\n\n\t\t\turl.set_query(Some(\"accept_own_addr=true\"));\n\t\t\tlet consumeropts = ServerOptions {\n\t\t\t\treplicate_from: vec![url],\n\t\t\t\t..Default::default()\n\t\t\t};\n\n\t\t\tlet producer = MockServer::new(produceropts).await?;\n\n\t\t\tlet consumer = MockServer::new(consumeropts).await?;\n\n\t\t\tlet mut producer_session = producer.new_session().await?;\n\t\t\tlet mut consumer_session = consumer.new_session().await?;\n\n\t\t\ttracing::trace!(\"producer id: {}\", producer_session.id());\n\t\t\ttracing::trace!(\"consumer id: {}\", consumer_session.id());\n\n\t\t\t// on server 1 we create a new player\n\t\t\t// and publish it to the server.\n\t\t\tlet mut update = TickUpdate::default();\n\t\t\tupdate.player.attributes.insert(\n\t\t\t\tWellKnownAttribute::Position as u16,\n\t\t\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t\t\t);\n\t\t\tupdate.player.attributes.insert(TEST_ATTRIBUTE_ID, $value);\n\n\t\t\tproducer_session.roundtrip(update).await?;\n\n\t\t\tconsumer.wait_for_spatial_reindex().await;\n\n\t\t\t// on server 2 we should see the player published\n\t\t\t// by server 1. Both players have the same position\n\t\t\t// to make them relevant to each other.\n\t\t\tlet mut update = TickUpdate::default();\n\t\t\tupdate.player.attributes.insert(\n\t\t\t\tWellKnownAttribute::Position as u16,\n\t\t\t\tValue::Vec3((2.0, 3.0, 4.0)),\n\t\t\t);\n\n\t\t\tlet consumer_resp = consumer_session.roundtrip(update).await?;\n\n\t\t\tassert_eq!(consumer_resp.players.len(), 1);\n\t\t\tassert!(consumer_resp.players.contains_key(\u0026producer_session.id()));\n\t\t\tassert_eq!(consumer_resp.players.keys().collect::\u003cVec\u003c_\u003e\u003e(), vec![\n\t\t\t\t\u0026producer_session.id()\n\t\t\t]);\n\n\t\t\tassert_eq!(\n\t\t\t\tconsumer_resp.players[\u0026producer_session.id()].attributes[\u00261],\n\t\t\t\tValue::Vec3((1.0, 2.0, 3.0))\n\t\t\t);\n\n\t\t\tassert_eq!(\n\t\t\t\tconsumer_resp.players[\u0026producer_session.id()].attributes\n\t\t\t\t\t[\u0026TEST_ATTRIBUTE_ID],\n\t\t\t\t$value\n\t\t\t);\n\n\t\t\t// initial replication works, now producer updates an existing attribute\n\t\t\t// and it should be replicated to the consumer asap.\n\n\t\t\tlet mut update = TickUpdate::default();\n\t\t\tupdate.player.attributes.insert(TEST_ATTRIBUTE_ID, $value2);\n\n\t\t\tproducer_session.roundtrip(update).await?;\n\n\t\t\t// wait for UDP propagation\n\t\t\ttokio::time::sleep(Duration::from_millis(50)).await;\n\n\t\t\tlet consumer_resp2 = consumer_session.pull().await?;\n\n\t\t\tassert_eq!(consumer_resp2.players.len(), 1);\n\t\t\tassert!(consumer_resp2.players.contains_key(\u0026producer_session.id()));\n\n\t\t\tassert_eq!(\n\t\t\t\tconsumer_resp2.players[\u0026producer_session.id()].attributes\n\t\t\t\t\t[\u0026TEST_ATTRIBUTE_ID],\n\t\t\t\t$value2\n\t\t\t);\n\n\t\t\tOk(())\n\t\t}\n\t};\n}\n\nmake_attribute_replication_test!(\n\tattribute_bool,\n\tValue::Bool(true),\n\tValue::Bool(false)\n);\n\nmake_attribute_replication_test!(\n\tattribute_int8,\n\tValue::Int8(-8),\n\tValue::Uint8(200)\n);\n\nmake_attribute_replication_test!(\n\tattribute_int16,\n\tValue::Int16(-16),\n\tValue::Uint16(200)\n);\n\nmake_attribute_replication_test!(\n\tattribute_int32,\n\tValue::Int32(-32),\n\tValue::Uint32(200)\n);\n\nmake_attribute_replication_test!(\n\tattribute_int64,\n\tValue::Int64(-64),\n\tValue::Uint64(200)\n);\n\nmake_attribute_replication_test!(\n\tattribute_float32,\n\tValue::Float32(-32.32),\n\tValue::Float32(200.200)\n);\n\nmake_attribute_replication_test!(\n\tattribute_float64,\n\tValue::Float64(-64.64),\n\tValue::Float64(200.200)\n);\n\nmake_attribute_replication_test!(\n\tattribute_string,\n\tValue::String(\"Hello\".try_into()?),\n\tValue::String(\"World\".try_into()?)\n);\n\nmake_attribute_replication_test!(\n\tattribute_bytes,\n\tValue::Bytes([1u8, 2, 3, 4, 5, 6, 7, 8][..].try_into()?),\n\tValue::Bytes([8u8, 7, 6, 5, 4, 3, 2, 1][..].try_into()?)\n);\n\nmake_attribute_replication_test!(\n\tattribute_vec2,\n\tValue::Vec2((1.0, 2.0)),\n\tValue::Vec2((2.0, 3.0))\n);\n\nmake_attribute_replication_test!(\n\tattribute_vec3,\n\tValue::Vec3((1.0, 2.0, 3.0)),\n\tValue::Vec3((2.0, 3.0, 4.0))\n);\n\nmake_attribute_replication_test!(\n\tattribute_vec4,\n\tValue::Vec4((1.0, 2.0, 3.0, 4.0)),\n\tValue::Vec4((2.0, 3.0, 4.0, 5.0))\n);\n\nmake_attribute_replication_test!(\n\tattribute_vec2d,\n\tValue::Vec2d((1.0, 2.0)),\n\tValue::Vec2d((2.0, 3.0))\n);\n\nmake_attribute_replication_test!(\n\tattribute_vec3d,\n\tValue::Vec3d((1.0, 2.0, 3.0)),\n\tValue::Vec3d((2.0, 3.0, 4.0))\n);\n\nmake_attribute_replication_test!(\n\tattribute_vec4d,\n\tValue::Vec4d((1.0, 2.0, 3.0, 4.0)),\n\tValue::Vec4d((2.0, 3.0, 4.0, 5.0))\n);\n\n/// tests as if the server crashes with 1 player connected, then tries to\n/// recover that player's data and sees if when we connect another client\n/// that client will see the recovered player's data\n#[tokio::test]\nasync fn file_replicate_player() -\u003e anyhow::Result\u003c()\u003e {\n\tlet path = DirGen::new(std::env::current_dir()?.join(\"snapshot-tests\"))?;\n\tlet rto: Url = format!(\"file://{}?delay=10ms\", path.0.display()).parse()?;\n\n\tlet server = MockServer::new(ServerOptions {\n\t\treplicate_to: vec![rto.clone()],\n\t\t..Default::default()\n\t})\n\t.await?;\n\tlet mut session = server.new_session().await?;\n\tlet id = session.id();\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tupdate.player.attributes.insert(15, Value::Uint32(42));\n\tsession.roundtrip(update).await?;\n\n\t// wait for sync\n\ttokio::time::sleep(Duration::from_millis(50)).await;\n\n\tlet server = MockServer::new(ServerOptions {\n\t\treplicate_to: vec![rto],\n\t\t..Default::default()\n\t})\n\t.await?;\n\tlet mut session = server\n\t\t.build_session()\n\t\t.with_auth(id.to_be_bytes().as_slice())\n\t\t.build()\n\t\t.await?;\n\tsession.roundtrip(TickUpdate::default()).await?;\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut session2 = server.new_session().await?;\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((2.0, 2.0, 3.0)),\n\t);\n\tupdate.player.attributes.insert(15, Value::Uint32(41));\n\tlet r = session2.roundtrip(update).await?;\n\tassert_eq!(r.players.len(), 1);\n\n\tlet p = \u0026r.players[\u0026id];\n\tassert_eq!(\n\t\tp.attributes[\u0026(WellKnownAttribute::Position as u16)],\n\t\tValue::Vec3((1.0, 2.0, 3.0))\n\t);\n\tassert_eq!(p.attributes[\u002615], Value::Uint32(42));\n\tOk(())\n}\n\n/// tests as if the server crashes with 1 player connected and 1 object, then\n/// tries to recover that player's data and sees if when we connect another\n/// client that client will see the recovered player's data\n#[tokio::test]\nasync fn file_replicate_object() -\u003e anyhow::Result\u003c()\u003e {\n\tlet path = DirGen::new(std::env::current_dir()?.join(\"snapshot-tests\"))?;\n\tlet rto: Url = format!(\"file://{}?delay=10ms\", path.0.display()).parse()?;\n\n\tlet server = MockServer::new(ServerOptions {\n\t\treplicate_to: vec![rto.clone()],\n\t\t..Default::default()\n\t})\n\t.await?;\n\tlet mut session = server.new_session().await?;\n\tlet id = session.id();\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tupdate.player.attributes.insert(15, Value::Uint32(42));\n\n\tlet obj1id = session.derive_global_id(15);\n\tupdate.object(obj1id).attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((2.0, 3.0, 4.0)),\n\t);\n\n\tupdate\n\t\t.object(obj1id)\n\t\t.attributes\n\t\t.insert(16, Value::Uint32(43));\n\n\tsession.roundtrip(update).await?;\n\n\t// wait for sync\n\ttokio::time::sleep(Duration::from_millis(50)).await;\n\n\tlet server = MockServer::new(ServerOptions {\n\t\treplicate_to: vec![rto.clone()],\n\t\treplicate_from: vec![rto],\n\t\t..Default::default()\n\t})\n\t.await?;\n\tlet mut session = server\n\t\t.build_session()\n\t\t.with_auth(id.to_be_bytes().as_slice())\n\t\t.build()\n\t\t.await?;\n\tsession.roundtrip(TickUpdate::default()).await?;\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut session2 = server.new_session().await?;\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((2.0, 2.0, 3.0)),\n\t);\n\tupdate.player.attributes.insert(15, Value::Uint32(41));\n\n\tlet r = session2.roundtrip(update).await?;\n\tassert_eq!(r.players.len(), 1);\n\n\tlet p = \u0026r.players[\u0026id];\n\tassert_eq!(\n\t\tp.attributes[\u0026(WellKnownAttribute::Position as u16)],\n\t\tValue::Vec3((1.0, 2.0, 3.0))\n\t);\n\tassert_eq!(p.attributes[\u002615], Value::Uint32(42));\n\n\tassert_eq!(r.objects.len(), 1);\n\tassert!(r.objects.contains_key(\u0026obj1id));\n\tassert_eq!(r.objects[\u0026obj1id].attributes[\u002616], Value::Uint32(43));\n\n\tOk(())\n}\n\n/// same as file_replicate_crash but with many players\n#[tokio::test]\nasync fn file_replicate_many() -\u003e anyhow::Result\u003c()\u003e {\n\tlet path = DirGen::new(std::env::current_dir()?.join(\"snapshot-tests\"))?;\n\tlet rto: Url = format!(\"file://{}?delay=10ms\", path.0.display()).parse()?;\n\n\tlet server = MockServer::new(ServerOptions {\n\t\treplicate_to: vec![rto.clone()],\n\t\t..Default::default()\n\t})\n\t.await?;\n\tlet mut sessions = Vec::new();\n\tlet mut keepalive = Vec::new();\n\tfor i in 0..5 {\n\t\tlet mut session = server.new_session().await?;\n\t\tlet id = session.id();\n\t\tlet mut update = TickUpdate::default();\n\t\tupdate.player.attributes.insert(\n\t\t\tWellKnownAttribute::Position as u16,\n\t\t\tValue::Vec3((1.0 + i as f32, 2.0 + i as f32, 3.0)),\n\t\t);\n\t\tupdate.player.attributes.insert(15, Value::Uint32(42 + id));\n\t\tsession.roundtrip(update).await?;\n\t\tsessions.push(id);\n\t\tkeepalive.push(session);\n\t}\n\n\t// wait for sync\n\ttokio::time::sleep(Duration::from_millis(50)).await;\n\n\t// avoid dropping of the sessions because this will clear\n\t// entries on disk and we won't be able to recover them.\n\tlet _ = std::mem::ManuallyDrop::new(keepalive);\n\n\t// try to recover sessions now...\n\tlet server = MockServer::new(ServerOptions {\n\t\treplicate_to: vec![rto],\n\t\t..Default::default()\n\t})\n\t.await?;\n\n\t// reconnect all players\n\tlet mut keepalive = Vec::new();\n\tfor id in \u0026sessions {\n\t\tlet mut session = server\n\t\t\t.build_session()\n\t\t\t.with_auth(id.to_be_bytes().as_slice())\n\t\t\t.build()\n\t\t\t.await?;\n\t\tsession.roundtrip(TickUpdate::default()).await?;\n\t\tkeepalive.push(session);\n\t}\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut session2 = server.new_session().await?;\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tupdate.player.attributes.insert(15, Value::Uint32(42));\n\n\tlet r = session2.roundtrip(update).await?;\n\tassert_eq!(r.players.len(), 5);\n\n\tfor (i, id) in sessions.iter().enumerate() {\n\t\tlet p = \u0026r.players[id];\n\t\tassert_eq!(\n\t\t\tp.attributes[\u0026(WellKnownAttribute::Position as u16)],\n\t\t\tValue::Vec3((1.0 + i as f32, 2.0 + i as f32, 3.0))\n\t\t);\n\t\tassert_eq!(p.attributes[\u002615], Value::Uint32(42 + id));\n\t}\n\n\tOk(())\n}\n\n/// same as file_replicate_many but drop 1 player in the middle then try to\n/// re-use their slot.\n#[tokio::test]\nasync fn file_replicate_many_one_disconnect() -\u003e anyhow::Result\u003c()\u003e {\n\tlet path = DirGen::new(std::env::current_dir()?.join(\"snapshot-tests\"))?;\n\tlet rto: Url = format!(\"file://{}?delay=10ms\", path.0.display()).parse()?;\n\n\tlet server = MockServer::new(ServerOptions {\n\t\treplicate_to: vec![rto.clone()],\n\t\t..Default::default()\n\t})\n\t.await?;\n\tlet mut sessions = Vec::new();\n\tlet mut keepalive = Vec::new();\n\tfor i in 0..5 {\n\t\tlet mut session = server.new_session().await?;\n\t\tlet id = session.id();\n\t\tlet mut update = TickUpdate::default();\n\t\tupdate.player.attributes.insert(\n\t\t\tWellKnownAttribute::Position as u16,\n\t\t\tValue::Vec3((1.0 + i as f32, 2.0 + i as f32, 3.0)),\n\t\t);\n\t\tupdate.player.attributes.insert(15, Value::Uint32(42 + id));\n\t\tsession.roundtrip(update).await?;\n\t\tsessions.push(id);\n\n\t\t// allow entry 2 to be dropped so it can be cleared from disk.\n\t\tif i != 2 {\n\t\t\tkeepalive.push(session);\n\t\t}\n\t}\n\n\t// wait for sync\n\ttokio::time::sleep(Duration::from_millis(50)).await;\n\n\t// avoid dropping of the sessions because this will clear\n\t// entries on disk and we won't be able to recover them.\n\tlet _ = std::mem::ManuallyDrop::new(keepalive);\n\n\t// try to recover sessions now...\n\tlet server = MockServer::new(ServerOptions {\n\t\treplicate_to: vec![rto],\n\t\t..Default::default()\n\t})\n\t.await?;\n\n\t// reconnect all players\n\tlet mut keepalive = Vec::new();\n\tfor id in \u0026sessions {\n\t\tlet mut session = server\n\t\t\t.build_session()\n\t\t\t.with_auth(id.to_be_bytes().as_slice())\n\t\t\t.build()\n\t\t\t.await?;\n\t\tsession.roundtrip(TickUpdate::default()).await?;\n\t\tkeepalive.push(session);\n\t}\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut session2 = server.new_session().await?;\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tupdate.player.attributes.insert(15, Value::Uint32(42));\n\tlet r = session2.roundtrip(update).await?;\n\tassert_eq!(r.players.len(), 4);\n\n\tfor (i, id) in sessions.iter().enumerate() {\n\t\tif i == 2 {\n\t\t\t// entry 2 was removed, so it shouldn't be recovered, so it shouldn't be\n\t\t\t// seen by that session.\n\t\t\tassert!(!r.players.contains_key(id));\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet p = \u0026r.players[id];\n\t\tassert_eq!(\n\t\t\tp.attributes[\u0026(WellKnownAttribute::Position as u16)],\n\t\t\tValue::Vec3((1.0 + i as f32, 2.0 + i as f32, 3.0))\n\t\t);\n\t\tassert_eq!(p.attributes[\u002615], Value::Uint32(42 + id));\n\t}\n\n\tOk(())\n}\n\n/// see if we can recover resumable sessions\n#[tokio::test]\nasync fn file_replicate_resumables() -\u003e anyhow::Result\u003c()\u003e {\n\tlet path = DirGen::new(std::env::current_dir()?.join(\"snapshot-tests\"))?;\n\tlet rto: Url = format!(\"file://{}?delay=10ms\", path.0.display()).parse()?;\n\n\tlet server = MockServer::new(ServerOptions {\n\t\treplicate_to: vec![rto.clone()],\n\t\t..Default::default()\n\t})\n\t.await?;\n\tlet mut rsessions = HashMap::new();\n\tfor _ in 0..5 {\n\t\tlet mut session = server.new_session().await?;\n\t\tlet mut update = TickUpdate::default();\n\t\tupdate.player.attributes.insert(\n\t\t\tWellKnownAttribute::Position as u16,\n\t\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t\t);\n\t\tupdate\n\t\t\t.player\n\t\t\t.attributes\n\t\t\t.insert(15, Value::Uint32(42 + session.id()));\n\t\tsession.roundtrip(update).await?;\n\n\t\trsessions.insert(session.id(), session.resume_token().to_vec());\n\t}\n\n\t// wait for sync\n\ttokio::time::sleep(Duration::from_millis(50)).await;\n\n\t// try to recover sessions now...\n\tlet server2 = MockServer::new(ServerOptions {\n\t\treplicate_from: vec![rto],\n\t\t..Default::default()\n\t})\n\t.await?;\n\n\tfor (id, token) in rsessions {\n\t\tlet session =\n\t\t\tSession::resume(\u0026server2.listen_addr().to_string(), \u0026token).await?;\n\t\tassert_eq!(session.id(), id);\n\t}\n\n\tOk(())\n}\n\n/// tests when a player disconnects (despawns) then tries to recover their\n/// attributes which should fail, because we zero out their data on despawn.\n#[tokio::test]\nasync fn file_replicate_despawn() -\u003e anyhow::Result\u003c()\u003e {\n\tlet path = DirGen::new(std::env::current_dir()?.join(\"snapshot-tests\"))?;\n\tlet rto: Url = format!(\"file://{}?delay=10ms\", path.0.display()).parse()?;\n\n\tlet server = MockServer::new(ServerOptions {\n\t\treplicate_to: vec![rto.clone()],\n\t\t..Default::default()\n\t})\n\t.await?;\n\tlet mut session = server.new_session().await?;\n\tlet id = session.id();\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tupdate.player.attributes.insert(15, Value::Uint32(42));\n\tsession.roundtrip(update).await?;\n\n\t// disconnect (despawn)\n\tdrop(session);\n\n\t// wait for sync\n\ttokio::time::sleep(Duration::from_millis(50)).await;\n\n\t// reconnect with same id\n\tlet mut session = server\n\t\t.build_session()\n\t\t.with_auth(id.to_be_bytes().as_slice())\n\t\t.build()\n\t\t.await?;\n\n\tsession.roundtrip(TickUpdate::default()).await?;\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut session2 = server.new_session().await?;\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((2.0, 2.0, 3.0)),\n\t);\n\tupdate.player.attributes.insert(15, Value::Uint32(41));\n\tlet r = session2.roundtrip(update).await?;\n\tassert!(r.players.is_empty());\n\tOk(())\n}\n\n/// same as file_replicate_many_one_disconnect but with some objects.\n#[tokio::test]\nasync fn file_replicate_many_despawn() -\u003e anyhow::Result\u003c()\u003e {\n\tlet path = DirGen::new(std::env::current_dir()?.join(\"snapshot-tests\"))?;\n\tlet rto: Url = format!(\"file://{}?delay=10ms\", path.0.display()).parse()?;\n\n\tlet server = MockServer::new(ServerOptions {\n\t\treplicate_to: vec![rto.clone()],\n\t\t..Default::default()\n\t})\n\t.await?;\n\tlet mut sessions = Vec::new();\n\tlet mut keepalive = Vec::new();\n\tlet mut objects = Vec::new();\n\tfor i in 0..5 {\n\t\tlet mut session = server.new_session().await?;\n\t\tlet id = session.id();\n\t\tlet mut update = TickUpdate::default();\n\t\tupdate.player.attributes.insert(\n\t\t\tWellKnownAttribute::Position as u16,\n\t\t\tValue::Vec3((1.0 + i as f32, 2.0 + i as f32, 3.0)),\n\t\t);\n\t\tupdate.player.attributes.insert(15, Value::Uint32(42 + id));\n\n\t\t// allow entry 2 to be dropped so it can be cleared from disk.\n\t\tlet dc_session = i == 2;\n\t\tif dc_session {\n\t\t\t// spawn an object\n\t\t\tlet objid = session.derive_global_id(15);\n\t\t\tupdate.object(objid).attributes.insert(\n\t\t\t\tWellKnownAttribute::Position as u16,\n\t\t\t\tValue::Vec3((2.0, 3.0, 4.0)),\n\t\t\t);\n\n\t\t\tupdate\n\t\t\t\t.object(objid)\n\t\t\t\t.attributes\n\t\t\t\t.insert(16, Value::Uint32(43));\n\t\t} else {\n\t\t\tlet objid = session.derive_global_id(15);\n\t\t\tupdate.object(objid).attributes.insert(\n\t\t\t\tWellKnownAttribute::Position as u16,\n\t\t\t\tValue::Vec3((4.0, 4.0, 4.0)),\n\t\t\t);\n\n\t\t\tupdate\n\t\t\t\t.object(objid)\n\t\t\t\t.attributes\n\t\t\t\t.insert(16, Value::Uint32(74));\n\t\t\tobjects.push(objid);\n\t\t}\n\n\t\tsession.roundtrip(update).await?;\n\t\tsessions.push(id);\n\t\tif !dc_session {\n\t\t\tkeepalive.push(session);\n\t\t}\n\t}\n\n\t// wait for sync\n\ttokio::time::sleep(Duration::from_millis(50)).await;\n\n\t// avoid dropping of the sessions because this will clear\n\t// entries on disk and we won't be able to recover them.\n\tlet _ = std::mem::ManuallyDrop::new(keepalive);\n\n\t// try to recover sessions now...\n\tlet server = MockServer::new(ServerOptions {\n\t\treplicate_to: vec![rto.clone()],\n\t\treplicate_from: vec![rto],\n\t\t..Default::default()\n\t})\n\t.await?;\n\n\t// reconnect all players\n\tlet mut keepalive = Vec::new();\n\tfor id in \u0026sessions {\n\t\tlet mut session = server\n\t\t\t.build_session()\n\t\t\t.with_auth(id.to_be_bytes().as_slice())\n\t\t\t.build()\n\t\t\t.await?;\n\n\t\tsession.roundtrip(TickUpdate::default()).await?;\n\t\tkeepalive.push(session);\n\t}\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut session2 = server.new_session().await?;\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tupdate.player.attributes.insert(15, Value::Uint32(42));\n\tlet r = session2.roundtrip(update).await?;\n\n\tassert_eq!(r.players.len(), 4);\n\tassert_eq!(r.objects.len(), 4);\n\n\tfor objid in objects.into_iter() {\n\t\tassert!(r.objects.contains_key(\u0026objid));\n\t\tlet obj = \u0026r.objects[\u0026objid];\n\t\tassert_eq!(\n\t\t\tobj.attributes[\u0026(WellKnownAttribute::Position as u16)],\n\t\t\tValue::Vec3((4.0, 4.0, 4.0)),\n\t\t);\n\t\tassert_eq!(obj.attributes[\u002616], Value::Uint32(74));\n\t}\n\n\tfor (i, id) in sessions.iter().enumerate() {\n\t\tif i == 2 {\n\t\t\t// entry 2 was removed, so it shouldn't be recovered, so it shouldn't be\n\t\t\t// seen by that session.\n\t\t\tassert!(!r.players.contains_key(id));\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet p = \u0026r.players[id];\n\t\tassert_eq!(\n\t\t\tp.attributes[\u0026(WellKnownAttribute::Position as u16)],\n\t\t\tValue::Vec3((1.0 + i as f32, 2.0 + i as f32, 3.0))\n\t\t);\n\t\tassert_eq!(p.attributes[\u002615], Value::Uint32(42 + id));\n\t}\n\n\tOk(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","tests","resume.rs"],"content":"use {\n\tcrate::tests::mock::{MockServer, SessionTestExt, TickUpdate},\n\tquark_client_sdk::{Value, WellKnownAttribute},\n};\n\n#[tokio::test]\npub async fn resume_token_smoke() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::default().await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\tlet mut client3 = server.new_session().await?;\n\tlet mut client4 = server.new_session().await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tupdate.player.attributes.insert(1002, Value::Uint32(1900));\n\tclient1.roundtrip(update).await?;\n\n\tlet client1_id = client1.id();\n\tlet client1_resume_token = client1.resume_token().to_vec();\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((2.0, 3.0, 4.0)),\n\t);\n\tlet resp2 = client2.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tassert_eq!(resp2.players[\u0026client1.id()].attributes.len(), 2);\n\tassert_eq!(\n\t\tresp2.players[\u0026client1.id()].attributes\n\t\t\t[\u0026(WellKnownAttribute::Position as u16)],\n\t\tValue::Vec3((1.0, 2.0, 3.0))\n\t);\n\tassert_eq!(\n\t\tresp2.players[\u0026client1.id()].attributes[\u00261002],\n\t\tValue::Uint32(1900)\n\t);\n\n\tdrop(client1); // disconnect client 1\n\n\t// client 3 should only see client 2\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((3.0, 4.0, 5.0)),\n\t);\n\tlet resp3 = client3.roundtrip(update).await?;\n\tserver.wait_for_spatial_reindex().await;\n\n\tassert_eq!(resp3.players.len(), 1);\n\tassert!(resp3.players.contains_key(\u0026client2.id()));\n\n\tlet client1_resumed = server.resume_session(\u0026client1_resume_token).await?;\n\tassert_eq!(client1_resumed.id(), client1_id);\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((4.0, 5.0, 6.0)),\n\t);\n\tlet resp4 = client4.roundtrip(update).await?;\n\n\tassert_eq!(resp4.players.len(), 3);\n\tassert!(resp4.players.contains_key(\u0026client1_resumed.id()));\n\tassert_eq!(resp4.players[\u0026client1_resumed.id()].attributes.len(), 2);\n\tassert_eq!(\n\t\tresp4.players[\u0026client1_resumed.id()].attributes\n\t\t\t[\u0026(WellKnownAttribute::Position as u16)],\n\t\tValue::Vec3((1.0, 2.0, 3.0))\n\t);\n\tassert_eq!(\n\t\tresp4.players[\u0026client1_resumed.id()].attributes[\u00261002],\n\t\tValue::Uint32(1900)\n\t);\n\tOk(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","tests","schema.rs"],"content":"use {\n\tcrate::{\n\t\tobjects::AverageParams,\n\t\trelevance::Relevance,\n\t\tschema::{Blend, Error, GetByKey, Lifetime, Ownership, Schema},\n\t},\n\tstd::{fs::File, time::Duration},\n};\n\n#[test]\nfn correct_schema_smoke() -\u003e anyhow::Result\u003c()\u003e {\n\tlet schema = Schema::from_yaml_file(\"src/tests/assets/full.yml\")?;\n\n\tassert_eq!(schema.players.len(), 2);\n\tassert_eq!(schema.objects.len(), 4);\n\tassert_eq!(schema.events.len(), 3);\n\n\tlet p2001 = schema.players.get_by_key(\u00262001).unwrap();\n\tassert_eq!(p2001.name, \"Human Character\");\n\tassert_eq!(p2001.class_id, 2001);\n\tassert_eq!(p2001.attributes.len(), 9);\n\n\tassert!(p2001.attributes.iter().all(|a| a.blend == Blend::Owner));\n\n\tlet p2002 = schema.players.get_by_key(\u00262002).unwrap();\n\tassert_eq!(p2002.name, \"Vehicle Character\");\n\n\tlet o3001 = schema.objects.get_by_key(\u00263001).unwrap();\n\tassert_eq!(o3001.name, \"Pet\");\n\tassert_eq!(o3001.class_id, 3001);\n\tassert_eq!(o3001.lifetime, Lifetime::Owner);\n\tassert_eq!(o3001.blend, Blend::Owner);\n\tassert_eq!(o3001.ownership, Ownership::Creator);\n\n\tassert!(o3001.attributes.iter().all(|a| a.blend == Blend::Owner));\n\n\tlet o3002 = schema.objects.get_by_key(\u00263002).unwrap();\n\tassert_eq!(o3002.name, \"Projectile1\");\n\tassert_eq!(o3002.class_id, 3002);\n\tassert_eq!(o3002.lifetime, Lifetime::Timeout(Duration::from_secs(5)));\n\tassert_eq!(o3002.blend, Blend::default_average());\n\tassert_eq!(o3002.ownership, Ownership::Creator);\n\n\tassert_eq!(\n\t\to3002.attributes.as_slice().get_by_key(\u00261).unwrap().name,\n\t\t\"Position\"\n\t);\n\tassert_eq!(\n\t\to3002.attributes.as_slice().get_by_key(\u00261).unwrap().blend,\n\t\tBlend::default_average()\n\t);\n\n\tassert_eq!(\n\t\to3002.attributes.as_slice().get_by_key(\u00261001).unwrap().name,\n\t\t\"Velocity\"\n\t);\n\tassert_eq!(\n\t\to3002.attributes.as_slice().get_by_key(\u00261001).unwrap().blend,\n\t\tBlend::Average(AverageParams {\n\t\t\tperiod: Duration::from_millis(20),\n\t\t\tsamples: 8,\n\t\t\t..Default::default()\n\t\t})\n\t);\n\n\tassert_eq!(\n\t\to3002.attributes.as_slice().get_by_key(\u00263019).unwrap().blend,\n\t\tBlend::Owner\n\t);\n\n\tlet e4001 = schema.events.get_by_key(\u00264001).unwrap();\n\tassert_eq!(e4001.name, \"Shoot\");\n\tassert_eq!(e4001.class_id, 4001);\n\tassert!(e4001.volatile);\n\tassert_eq!(e4001.radius, Relevance::new(0.3));\n\n\tOk(())\n}\n\n#[test]\nfn import_schema_smoke() -\u003e anyhow::Result\u003c()\u003e {\n\t// given\n\n\t// when\n\tlet schema = Schema::from_yaml_file(\n\t\t\"src/tests/assets/imports/minimal_with_imports.yml\",\n\t)?;\n\n\t// then\n\tlet manualy_resolved = serde_yaml::from_reader(File::open(\n\t\t\"src/tests/assets/imports/minimal_imports_resolved.yml\",\n\t)?)?;\n\tassert_eq!(schema, manualy_resolved);\n\n\tOk(())\n}\n\n#[test]\nfn import_schema_cycle_of_two_detected() -\u003e anyhow::Result\u003c()\u003e {\n\t// given\n\n\t// when\n\tlet res =\n\t\tSchema::from_yaml_file(\"src/tests/assets/imports/cyclic_import1_2.yml\");\n\n\t// then\n\tassert!(matches!(res, Err(Error::DuplicateImportFile(_path))));\n\tOk(())\n}\n\n#[test]\nfn import_schema_cycle_of_three_detected() -\u003e anyhow::Result\u003c()\u003e {\n\t// given\n\n\t// when\n\tlet res =\n\t\tSchema::from_yaml_file(\"src/tests/assets/imports/cyclic_import1_3.yml\");\n\n\t// then\n\tassert!(matches!(res, Err(Error::DuplicateImportFile(_path))));\n\tOk(())\n}\n\n#[test]\nfn import_schema_with_identical_entities_merged() -\u003e anyhow::Result\u003c()\u003e {\n\t// given\n\n\t// when\n\tlet res = Schema::from_yaml_file(\n\t\t\"src/tests/assets/imports/parent_with_identical_entities.yml\",\n\t)?;\n\n\t// then\n\tassert_eq!(\n\t\tres,\n\t\tserde_yaml::from_reader(File::open(\n\t\t\t\"src/tests/assets/imports/parent_with_identical_entities_resolved.yml\"\n\t\t)?)?\n\t);\n\n\tOk(())\n}\n\n#[test]\nfn import_schema_with_conflicting_player() -\u003e anyhow::Result\u003c()\u003e {\n\t// given\n\n\t// when\n\tlet res = Schema::from_yaml_file(\n\t\t\"src/tests/assets/imports/parent_with_conflicting_player.yml\",\n\t);\n\n\t// then\n\tassert!(matches!(res, Err(Error::DuplicateClassId(2001))));\n\n\tOk(())\n}\n\n#[test]\nfn import_schema_with_conflicting_object() -\u003e anyhow::Result\u003c()\u003e {\n\t// given\n\n\t// when\n\tlet res = Schema::from_yaml_file(\n\t\t\"src/tests/assets/imports/parent_with_conflicting_object.yml\",\n\t);\n\n\t// then\n\tassert!(matches!(res, Err(Error::DuplicateClassId(5006))));\n\n\tOk(())\n}\n\n#[test]\nfn import_schema_with_conflicting_event() -\u003e anyhow::Result\u003c()\u003e {\n\t// given\n\n\t// when\n\tlet res = Schema::from_yaml_file(\n\t\t\"src/tests/assets/imports/parent_with_conflicting_event.yml\",\n\t);\n\n\t// then\n\tassert!(matches!(res, Err(Error::DuplicateClassId(4001))));\n\n\tOk(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","tests","spec.rs"],"content":"use {\n\tcrate::{\n\t\topts::ServerOptions,\n\t\tschema::{\n\t\t\tself,\n\t\t\tAttribute,\n\t\t\tBlend,\n\t\t\tLifetime,\n\t\t\tObject,\n\t\t\tOwnership,\n\t\t\tPlayer,\n\t\t\tSchema,\n\t\t},\n\t\tstate::EntityId,\n\t\ttests::mock::{MockServer, SessionTestExt, TickUpdate},\n\t},\n\tquark_client_sdk::{\n\t\tAttributeType,\n\t\tOutboundEvent,\n\t\tRecipient,\n\t\tValue,\n\t\tWellKnownAttribute,\n\t},\n\tstd::time::Duration,\n};\n\n/// An object spcification configured to make all object with class id 2003\n/// automatically owned by the creator.\n#[tokio::test]\nasync fn owner_automatically_applied() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server =\n\t\tMockServer::new(ServerOptions::with_schema(Schema::with_objects(vec![\n\t\t\tObject {\n\t\t\t\tname: \"test-object\".to_string(),\n\t\t\t\tclass_id: 2003,\n\t\t\t\townership: Ownership::Creator,\n\t\t\t\tlifetime: schema::Lifetime::Owner,\n\t\t\t\tblend: schema::Blend::default(),\n\t\t\t\t..Default::default()\n\t\t\t},\n\t\t])?))\n\t\t.await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\n\tlet objectid = client1.derive_global_id(1);\n\tupdate\n\t\t.object(objectid)\n\t\t.attributes\n\t\t.insert(WellKnownAttribute::ClassId as u16, Value::Uint64(2003));\n\n\tclient1.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tlet resp2 = client2.roundtrip(update).await?;\n\n\tassert_eq!(resp2.players.len(), 1);\n\tassert_eq!(resp2.objects.len(), 1);\n\n\tassert_eq!(resp2.players[\u0026client1.id()].attributes.len(), 1);\n\tassert_eq!(resp2.objects[\u0026objectid].attributes.len(), 2);\n\n\tassert_eq!(\n\t\tresp2.objects[\u0026objectid].attributes[\u0026(WellKnownAttribute::OwnerId as u16)],\n\t\tValue::Uint32(client1.id())\n\t);\n\n\tassert_eq!(\n\t\tresp2.objects[\u0026objectid].attributes[\u0026(WellKnownAttribute::ClassId as u16)],\n\t\tValue::Uint64(2003)\n\t);\n\n\tOk(())\n}\n\n#[tokio::test]\nasync fn class_id_on_objects_can_be_set_only_once() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server =\n\t\tMockServer::new(ServerOptions::with_schema(Schema::with_objects(vec![\n\t\t\tObject {\n\t\t\t\tname: \"test-object\".to_string(),\n\t\t\t\tclass_id: 2003,\n\t\t\t\townership: Ownership::Creator,\n\t\t\t\tlifetime: schema::Lifetime::Owner,\n\t\t\t\tblend: schema::Blend::default(),\n\t\t\t\t..Default::default()\n\t\t\t},\n\t\t])?))\n\t\t.await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\tlet mut client3 = server.new_session().await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\n\tlet objectid = client1.derive_global_id(1);\n\tupdate\n\t\t.object(objectid)\n\t\t.attributes\n\t\t.insert(WellKnownAttribute::ClassId as u16, Value::Uint64(2003));\n\n\tclient1.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tlet resp2 = client2.roundtrip(update).await?;\n\n\tassert_eq!(resp2.players.len(), 1);\n\tassert_eq!(resp2.objects.len(), 1);\n\n\tassert_eq!(resp2.players[\u0026client1.id()].attributes.len(), 1);\n\tassert_eq!(resp2.objects[\u0026objectid].attributes.len(), 2);\n\n\tassert_eq!(\n\t\tresp2.objects[\u0026objectid].attributes[\u0026(WellKnownAttribute::OwnerId as u16)],\n\t\tValue::Uint32(client1.id())\n\t);\n\n\tassert_eq!(\n\t\tresp2.objects[\u0026objectid].attributes[\u0026(WellKnownAttribute::ClassId as u16)],\n\t\tValue::Uint64(2003)\n\t);\n\n\t// now try to change the class id\n\tlet mut update = TickUpdate::default();\n\tupdate\n\t\t.object(objectid)\n\t\t.attributes\n\t\t.insert(WellKnownAttribute::ClassId as u16, Value::Uint64(2004));\n\tlet resp = client1.roundtrip(update).await?;\n\n\t// the class id should not be updated\n\tassert!(resp.objects.is_empty());\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\n\tlet resp3 = client3.roundtrip(update).await?;\n\n\t// ensure that class id was not changed for the observer\n\tassert_eq!(resp3.objects.len(), 1);\n\tassert_eq!(resp3.objects[\u0026objectid].attributes.len(), 2);\n\tassert_eq!(\n\t\tresp3.objects[\u0026objectid].attributes[\u0026(WellKnownAttribute::OwnerId as u16)],\n\t\tValue::Uint32(client1.id())\n\t);\n\tassert_eq!(\n\t\tresp3.objects[\u0026objectid].attributes[\u0026(WellKnownAttribute::ClassId as u16)],\n\t\tValue::Uint64(2003)\n\t);\n\n\tOk(())\n}\n\n#[tokio::test]\nasync fn class_id_on_players_can_be_changed() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::new(ServerOptions::with_schema(\n\t\tSchema::with_players_and_objects(\n\t\t\tvec![Player {\n\t\t\t\tname: \"test-player\".to_string(),\n\n\t\t\t\tclass_id: 2006,\n\t\t\t\t..Default::default()\n\t\t\t}],\n\t\t\tvec![Object {\n\t\t\t\tname: \"test-object\".to_string(),\n\n\t\t\t\tclass_id: 2003,\n\t\t\t\townership: Ownership::Creator,\n\t\t\t\tlifetime: schema::Lifetime::Owner,\n\t\t\t\tblend: schema::Blend::default(),\n\t\t\t\t..Default::default()\n\t\t\t}],\n\t\t)?,\n\t))\n\t.await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tupdate\n\t\t.player\n\t\t.attributes\n\t\t.insert(WellKnownAttribute::ClassId as u16, Value::Uint64(2006));\n\n\tlet objectid = client1.derive_global_id(1);\n\tupdate\n\t\t.object(objectid)\n\t\t.attributes\n\t\t.insert(WellKnownAttribute::ClassId as u16, Value::Uint64(2003));\n\n\tclient1.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tlet resp2 = client2.roundtrip(update).await?;\n\n\tassert_eq!(resp2.players.len(), 1);\n\tassert_eq!(resp2.objects.len(), 1);\n\n\tassert_eq!(resp2.players[\u0026client1.id()].attributes.len(), 2);\n\tassert_eq!(resp2.objects[\u0026objectid].attributes.len(), 2);\n\n\tassert_eq!(\n\t\tresp2.players[\u0026client1.id()].attributes\n\t\t\t[\u0026(WellKnownAttribute::ClassId as u16)],\n\t\tValue::Uint64(2006)\n\t);\n\n\tassert_eq!(\n\t\tresp2.objects[\u0026objectid].attributes[\u0026(WellKnownAttribute::OwnerId as u16)],\n\t\tValue::Uint32(client1.id())\n\t);\n\n\tassert_eq!(\n\t\tresp2.objects[\u0026objectid].attributes[\u0026(WellKnownAttribute::ClassId as u16)],\n\t\tValue::Uint64(2003)\n\t);\n\n\t// now try to change the class id\n\tlet mut update = TickUpdate::default();\n\tupdate\n\t\t.player\n\t\t.attributes\n\t\t.insert(WellKnownAttribute::ClassId as u16, Value::Uint64(2007));\n\tupdate\n\t\t.object(objectid)\n\t\t.attributes\n\t\t.insert(WellKnownAttribute::ClassId as u16, Value::Uint64(2004));\n\tclient1.roundtrip(update).await?;\n\n\tlet resp2 = client2.pull().await?;\n\n\t// class id on the player should be changed\n\tassert_eq!(resp2.players.len(), 1);\n\tassert_eq!(resp2.players[\u0026client1.id()].attributes.len(), 1);\n\tassert_eq!(\n\t\tresp2.players[\u0026client1.id()].attributes\n\t\t\t[\u0026(WellKnownAttribute::ClassId as u16)],\n\t\tValue::Uint64(2007)\n\t);\n\n\tOk(())\n}\n\n#[tokio::test]\nasync fn strict_schema_rejects_unknown_attributes() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server =\n\t\tMockServer::new(ServerOptions::with_schema(Schema::with_objects(vec![\n\t\t\tObject {\n\t\t\t\tname: \"test-object\".to_string(),\n\t\t\t\tstrict: true,\n\t\t\t\tclass_id: 2003,\n\t\t\t\townership: Ownership::Creator,\n\t\t\t\tlifetime: schema::Lifetime::Owner,\n\t\t\t\tblend: schema::Blend::default(),\n\t\t\t\tattributes: vec![\n\t\t\t\t\tAttribute {\n\t\t\t\t\t\tname: \"Position\".to_string(),\n\t\t\t\t\t\tkey: 1,\n\t\t\t\t\t\t..Default::default()\n\t\t\t\t\t},\n\t\t\t\t\tAttribute {\n\t\t\t\t\t\tname: \"Rotation\".to_string(),\n\t\t\t\t\t\tkey: 2,\n\t\t\t\t\t\t..Default::default()\n\t\t\t\t\t},\n\t\t\t\t\tAttribute {\n\t\t\t\t\t\tkey: 1001,\n\t\t\t\t\t\tr#type: Some(AttributeType::Uint32),\n\t\t\t\t\t\t..Default::default()\n\t\t\t\t\t},\n\t\t\t\t\tAttribute {\n\t\t\t\t\t\tkey: 1003,\n\t\t\t\t\t\tr#type: Some(AttributeType::Bool),\n\t\t\t\t\t\t..Default::default()\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t..Default::default()\n\t\t\t},\n\t\t])?))\n\t\t.await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\n\tlet objectid = client1.derive_global_id(1);\n\tlet mut update = TickUpdate::default();\n\tupdate\n\t\t.object(objectid)\n\t\t.attributes\n\t\t.insert(WellKnownAttribute::ClassId as u16, Value::Uint64(2003));\n\tupdate\n\t\t.object(objectid)\n\t\t.attributes\n\t\t.insert(1, Value::Vec3((1.0, 2.0, 3.0)));\n\tupdate\n\t\t.object(objectid)\n\t\t.attributes\n\t\t.insert(2, Value::Vec3((4.0, 5.0, 6.0)));\n\tupdate\n\t\t.object(objectid)\n\t\t.attributes\n\t\t.insert(1001, Value::Uint32(100)); // in schema and correct type\n\tupdate\n\t\t.object(objectid)\n\t\t.attributes\n\t\t.insert(1002, Value::Uint32(100)); // not in schema\n\tupdate\n\t\t.object(objectid)\n\t\t.attributes\n\t\t.insert(1003, Value::Uint16(18)); // in schema incorrect type\n\n\tclient1.roundtrip(update).await?;\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tlet resp2 = client2.roundtrip(update).await?;\n\n\tassert_eq!(resp2.players.len(), 0);\n\tassert_eq!(resp2.objects.len(), 1);\n\n\t// only the attributes that are in the schema should be accepted +\n\t// the server sets the owner id by default if the object is not\n\t// marked as detached. All other attributes that are not in the schema\n\t// or have invalid type should be ignored.\n\tassert_eq!(resp2.objects[\u0026objectid].attributes.len(), 5);\n\tassert_eq!(\n\t\tresp2.objects[\u0026objectid].attributes[\u0026(WellKnownAttribute::OwnerId as u16)],\n\t\tValue::Uint32(client1.id())\n\t);\n\tassert_eq!(\n\t\tresp2.objects[\u0026objectid].attributes[\u0026(WellKnownAttribute::ClassId as u16)],\n\t\tValue::Uint64(2003)\n\t);\n\tassert_eq!(\n\t\tresp2.objects[\u0026objectid].attributes[\u00261],\n\t\tValue::Vec3((1.0, 2.0, 3.0))\n\t);\n\n\tassert_eq!(\n\t\tresp2.objects[\u0026objectid].attributes[\u00262],\n\t\tValue::Vec3((4.0, 5.0, 6.0))\n\t);\n\n\tassert_eq!(\n\t\tresp2.objects[\u0026objectid].attributes[\u00261001],\n\t\tValue::Uint32(100)\n\t);\n\n\tOk(())\n}\n\n#[tokio::test]\nasync fn global_objects() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server =\n\t\tMockServer::new(ServerOptions::with_schema(Schema::with_objects(vec![\n\t\t\tObject {\n\t\t\t\tname: \"leaderboard\".to_string(),\n\t\t\t\tglobal: true,\n\t\t\t\tclass_id: 2010,\n\t\t\t\townership: Ownership::Creator,\n\t\t\t\tlifetime: schema::Lifetime::Detached,\n\t\t\t\tblend: schema::Blend::default(),\n\t\t\t\t..Default::default()\n\t\t\t},\n\t\t\tObject {\n\t\t\t\tname: \"regular\".to_string(),\n\t\t\t\tclass_id: 2011,\n\t\t\t\townership: Ownership::Creator,\n\t\t\t\tlifetime: schema::Lifetime::Detached,\n\t\t\t\tblend: schema::Blend::Owner,\n\t\t\t\t..Default::default()\n\t\t\t},\n\t\t])?))\n\t\t.await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\n\tlet object1 = client1.derive_global_id(1);\n\tlet object2 = client2.derive_global_id(2);\n\n\tlet mut update = TickUpdate::default();\n\n\t// this object should be relevant to everyone\n\tupdate\n\t\t.object(object1)\n\t\t.attributes\n\t\t.insert(WellKnownAttribute::ClassId as u16, Value::Uint64(2010));\n\n\tupdate.object(object1).attributes.insert(\n\t\tWellKnownAttribute::DisplayName as u16,\n\t\tValue::String(\"leaderboard\".try_into().unwrap()),\n\t);\n\n\t// this object should not be relevant to client2\n\tupdate\n\t\t.object(object2)\n\t\t.attributes\n\t\t.insert(WellKnownAttribute::ClassId as u16, Value::Uint64(2011));\n\n\tupdate.object(object2).attributes.insert(\n\t\tWellKnownAttribute::DisplayName as u16,\n\t\tValue::String(\"regular\".try_into().unwrap()),\n\t);\n\tclient1.roundtrip(update).await?;\n\n\tserver.wait_for_global_reindex().await;\n\n\tlet resp2 = client2.pull().await?;\n\n\tassert_eq!(resp2.players.len(), 0);\n\tassert_eq!(resp2.objects.len(), 1);\n\tassert!(resp2.objects.contains_key(\u0026object1));\n\tassert_eq!(resp2.objects[\u0026object1].attributes.len(), 3);\n\tassert_eq!(\n\t\tresp2.objects[\u0026object1].attributes[\u0026(WellKnownAttribute::ClassId as u16)],\n\t\tValue::Uint64(2010)\n\t);\n\tassert_eq!(\n\t\tresp2.objects[\u0026object1].attributes[\u0026(WellKnownAttribute::OwnerId as u16)],\n\t\tValue::Uint32(client1.id())\n\t);\n\tassert_eq!(\n\t\tresp2.objects[\u0026object1].attributes\n\t\t\t[\u0026(WellKnownAttribute::DisplayName as u16)],\n\t\tValue::String(\"leaderboard\".try_into().unwrap())\n\t);\n\n\t// the server should reject any updates to global objects\n\t// by sessions that are irrelevant to the object.\n\tlet mut update = TickUpdate::default();\n\tupdate.object(object1).attributes.insert(\n\t\tWellKnownAttribute::DisplayName as u16,\n\t\tValue::String(\"new\".try_into().unwrap()),\n\t);\n\tclient2.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet resp1 = client1.pull().await?;\n\n\t// no updates should have occured\n\tassert!(resp1.players.is_empty());\n\tassert!(resp1.objects.is_empty());\n\n\t// owner should be able to update the object\n\tlet mut update = TickUpdate::default();\n\tupdate.object(object1).attributes.insert(\n\t\tWellKnownAttribute::DisplayName as u16,\n\t\tValue::String(\"new2\".try_into().unwrap()),\n\t);\n\tclient1.roundtrip(update).await?;\n\n\tserver.wait_for_global_reindex().await;\n\n\tlet resp2 = client2.pull().await?;\n\tassert_eq!(resp2.objects.len(), 1);\n\tassert_eq!(\n\t\tresp2.objects[\u0026object1].attributes\n\t\t\t[\u0026(WellKnownAttribute::DisplayName as u16)],\n\t\tValue::String(\"new2\".try_into().unwrap())\n\t);\n\n\tOk(())\n}\n\n#[tokio::test]\nasync fn global_objects_events_delivery() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server =\n\t\tMockServer::new(ServerOptions::with_schema(Schema::with_objects(vec![\n\t\t\tObject {\n\t\t\t\tname: \"leaderboard\".to_string(),\n\t\t\t\tglobal: true,\n\t\t\t\tclass_id: 2010,\n\t\t\t\townership: Ownership::Creator,\n\t\t\t\tlifetime: Lifetime::Owner,\n\t\t\t\tblend: Blend::Owner,\n\t\t\t\t..Default::default()\n\t\t\t},\n\t\t])?))\n\t\t.await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\tlet mut leaderboard_client = server.new_session().await?;\n\n\t// leaderboard client creates a global leaderboard object\n\t// that is visible by everyone and delegates its interest\n\t// to the server.\n\t//\n\t// this object should be visible by everyone and it should\n\t// receive events from everyone\n\n\tlet leaderbord_object_id = leaderboard_client.derive_global_id(1);\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Delegate as u16,\n\t\tValue::Uint64(leaderbord_object_id),\n\t);\n\tupdate\n\t\t.object(leaderbord_object_id)\n\t\t.attributes\n\t\t.insert(WellKnownAttribute::ClassId as u16, Value::Uint64(2010));\n\tupdate\n\t\t.object(leaderbord_object_id)\n\t\t.attributes\n\t\t.insert(6003, Value::String(\"Rank1 Player\".try_into().unwrap()));\n\tupdate\n\t\t.object(leaderbord_object_id)\n\t\t.attributes\n\t\t.insert(6004, Value::String(\"Rank2 Player\".try_into().unwrap()));\n\tupdate\n\t\t.object(leaderbord_object_id)\n\t\t.attributes\n\t\t.insert(6005, Value::String(\"Rank3 Player\".try_into().unwrap()));\n\tleaderboard_client.roundtrip(update).await?;\n\n\tserver.wait_for_global_reindex().await;\n\n\tlet resp1 = client1.pull().await?;\n\tlet resp2 = client2.pull().await?;\n\n\tassert!(resp1.events.is_empty());\n\tassert!(resp1.players.is_empty());\n\tassert_eq!(resp1.objects.len(), 1);\n\tassert_eq!(resp1.objects[\u0026leaderbord_object_id].attributes.len(), 5);\n\tassert_eq!(\n\t\tresp1.objects[\u0026leaderbord_object_id].attributes\n\t\t\t[\u0026(WellKnownAttribute::ClassId as u16)],\n\t\tValue::Uint64(2010)\n\t);\n\tassert_eq!(\n\t\tresp1.objects[\u0026leaderbord_object_id].attributes\n\t\t\t[\u0026(WellKnownAttribute::OwnerId as u16)],\n\t\tValue::Uint32(leaderboard_client.id())\n\t);\n\tassert_eq!(\n\t\tresp1.objects[\u0026leaderbord_object_id].attributes[\u00266003],\n\t\tValue::String(\"Rank1 Player\".try_into().unwrap())\n\t);\n\tassert_eq!(\n\t\tresp2.objects[\u0026leaderbord_object_id].attributes[\u00266004],\n\t\tValue::String(\"Rank2 Player\".try_into().unwrap())\n\t);\n\tassert_eq!(\n\t\tresp1.objects[\u0026leaderbord_object_id].attributes[\u00266005],\n\t\tValue::String(\"Rank3 Player\".try_into().unwrap())\n\t);\n\n\tassert_eq!(resp1.players, resp2.players);\n\tassert_eq!(resp1.objects, resp2.objects);\n\tassert_eq!(resp1.events, resp2.events);\n\n\tlet mut update = TickUpdate::default();\n\tupdate.events.push(OutboundEvent {\n\t\tclass: 3004, // player shot event\n\t\tpayload: b\"player1_shot\"[..].try_into()?,\n\t\trecipient: Recipient::Entity(EntityId::Object(leaderbord_object_id)),\n\t});\n\tclient2.roundtrip(update).await?;\n\n\t// give some time for the event to propagate\n\ttokio::time::sleep(Duration::from_millis(50)).await;\n\n\tlet lb_resp = leaderboard_client.pull().await?;\n\tassert_eq!(lb_resp.events.len(), 1);\n\tassert_eq!(lb_resp.events[0].class, 3004);\n\tassert_eq!(lb_resp.events[0].sender, EntityId::Player(client2.id()));\n\tassert_eq!(lb_resp.events[0].payload[..], b\"player1_shot\"[..]);\n\tOk(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","tests","stream.rs"],"content":"use {\n\tcrate::tests::mock::{MockServer, SessionTestExt, TickUpdate},\n\tfxhash::FxHashSet,\n\tnanoid::nanoid,\n\tquark_client_sdk::{\n\t\tAttributeId,\n\t\tEntityId,\n\t\tEventsFilter,\n\t\tLocalUpdate,\n\t\tQoS,\n\t\tQuery,\n\t\tRecipient,\n\t\tRelevance,\n\t\tRemoteUpdate,\n\t\tTimestamp,\n\t\tValue,\n\t\tWellKnownAttribute,\n\t},\n\tstd::{collections::HashMap, time::Duration},\n\ttokio::time::sleep,\n};\n\n#[tokio::test]\nasync fn tcp_stream_send_ticks_receive() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::default().await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\n\tclient1\n\t\t.streams()\n\t\t.send(\n\t\t\tLocalUpdate::Player(\n\t\t\t\tWellKnownAttribute::Position as u16,\n\t\t\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t\t\t),\n\t\t\tQoS::Reliable,\n\t\t)\n\t\t.unwrap();\n\n\tclient1\n\t\t.streams()\n\t\t.send(\n\t\t\tLocalUpdate::Player(\n\t\t\t\tWellKnownAttribute::Rotation as u16,\n\t\t\t\tValue::Vec3((84.0, 85.0, 86.0)),\n\t\t\t),\n\t\t\tQoS::Reliable,\n\t\t)\n\t\t.unwrap();\n\n\tlet obj1id = client1.derive_global_id(1);\n\tlet obj2id = client1.derive_global_id(2);\n\n\tclient1\n\t\t.streams()\n\t\t.send(\n\t\t\tLocalUpdate::Object(obj1id, 15, Value::Uint64(1773)),\n\t\t\tQoS::Reliable,\n\t\t)\n\t\t.unwrap();\n\n\tclient1\n\t\t.streams()\n\t\t.send(\n\t\t\tLocalUpdate::Object(\n\t\t\t\tobj1id,\n\t\t\t\t16,\n\t\t\t\tValue::String(\"hello\".try_into().unwrap()),\n\t\t\t),\n\t\t\tQoS::Reliable,\n\t\t)\n\t\t.unwrap();\n\n\tclient1\n\t\t.streams()\n\t\t.send(\n\t\t\tLocalUpdate::Object(obj2id, 17, Value::Uint64(1774)),\n\t\t\tQoS::Reliable,\n\t\t)\n\t\t.unwrap();\n\n\tclient1\n\t\t.streams()\n\t\t.send(\n\t\t\tLocalUpdate::Object(\n\t\t\t\tobj2id,\n\t\t\t\t18,\n\t\t\t\tValue::String(\"world\".try_into().unwrap()),\n\t\t\t),\n\t\t\tQoS::Reliable,\n\t\t)\n\t\t.unwrap();\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tlet resp2 = client2.roundtrip(update).await?;\n\n\tassert_eq!(resp2.players.len(), 1);\n\tassert!(resp2.players.contains_key(\u0026client1.id()));\n\tassert_eq!(resp2.players[\u0026client1.id()].attributes.len(), 2);\n\n\tassert_eq!(\n\t\tresp2.players[\u0026client1.id()].attributes\n\t\t\t[\u0026(WellKnownAttribute::Position as u16)],\n\t\tValue::Vec3((1.0, 2.0, 3.0))\n\t);\n\n\tassert_eq!(\n\t\tresp2.players[\u0026client1.id()].attributes\n\t\t\t[\u0026(WellKnownAttribute::Rotation as u16)],\n\t\tValue::Vec3((84.0, 85.0, 86.0))\n\t);\n\n\tassert_eq!(resp2.objects.len(), 2);\n\tassert!(resp2.objects.contains_key(\u0026obj1id));\n\tassert!(resp2.objects.contains_key(\u0026obj2id));\n\n\tassert_eq!(resp2.objects[\u0026obj1id].attributes.len(), 3);\n\tassert_eq!(resp2.objects[\u0026obj2id].attributes.len(), 3);\n\n\tassert_eq!(resp2.objects[\u0026obj1id].attributes[\u002615], Value::Uint64(1773));\n\n\tassert_eq!(\n\t\tresp2.objects[\u0026obj1id].attributes\n\t\t\t[\u0026(WellKnownAttribute::OwnerId as AttributeId)],\n\t\tValue::Uint32(client1.id())\n\t);\n\n\tassert_eq!(\n\t\tresp2.objects[\u0026obj1id].attributes[\u002616],\n\t\tValue::String(\"hello\".try_into().unwrap())\n\t);\n\n\tassert_eq!(\n\t\tresp2.objects[\u0026obj2id].attributes\n\t\t\t[\u0026(WellKnownAttribute::OwnerId as AttributeId)],\n\t\tValue::Uint32(client1.id())\n\t);\n\n\tassert_eq!(resp2.objects[\u0026obj2id].attributes[\u002617], Value::Uint64(1774));\n\n\tassert_eq!(\n\t\tresp2.objects[\u0026obj2id].attributes[\u002618],\n\t\tValue::String(\"world\".try_into().unwrap())\n\t);\n\n\tOk(())\n}\n\n#[tokio::test]\nasync fn udp_send_tcp_receive() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::default().await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tclient1.push(update).await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((4.0, 5.0, 6.0)),\n\t);\n\tclient2.push(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tfor i in 0..30 {\n\t\tclient1\n\t\t\t.streams()\n\t\t\t.send(\n\t\t\t\tLocalUpdate::Player(i + 1000, Value::Uint64(i as u64 + 12323234)),\n\t\t\t\tQoS::Unreliable,\n\t\t\t)\n\t\t\t.unwrap();\n\n\t\tclient1\n\t\t\t.streams()\n\t\t\t.send(\n\t\t\t\tLocalUpdate::Player(\n\t\t\t\t\ti + 287,\n\t\t\t\t\tValue::String(format!(\"world {}\", i).as_str().try_into().unwrap()),\n\t\t\t\t),\n\t\t\t\tQoS::Unreliable,\n\t\t\t)\n\t\t\t.unwrap();\n\t\tclient1.streams().time().move_forward();\n\t}\n\n\tfor i in 0..60 {\n\t\tlet object_id = client1.derive_global_id(i % 10);\n\t\tclient1\n\t\t\t.streams()\n\t\t\t.send(\n\t\t\t\tLocalUpdate::Object(\n\t\t\t\t\tobject_id,\n\t\t\t\t\ti as u16 + 1000,\n\t\t\t\t\tValue::Uint64(989873 + i as u64),\n\t\t\t\t),\n\t\t\t\tQoS::Unreliable,\n\t\t\t)\n\t\t\t.unwrap();\n\n\t\tclient1\n\t\t\t.streams()\n\t\t\t.send(\n\t\t\t\tLocalUpdate::Object(\n\t\t\t\t\tobject_id,\n\t\t\t\t\ti as u16 + 2000,\n\t\t\t\t\tValue::String(format!(\"hello {}\", i).as_str().try_into().unwrap()),\n\t\t\t\t),\n\t\t\t\tQoS::Unreliable,\n\t\t\t)\n\t\t\t.unwrap();\n\t\tclient1.streams().time().move_forward();\n\t}\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet resp2 = client2.pull().await?;\n\n\tassert_eq!(resp2.players.len(), 1);\n\tassert_eq!(resp2.players[\u0026client1.id()].attributes.len(), 61);\n\n\tfor i in 0..30 {\n\t\tassert_eq!(\n\t\t\tresp2.players[\u0026client1.id()].attributes[\u0026(i + 1000)],\n\t\t\tValue::Uint64(i as u64 + 12323234)\n\t\t);\n\n\t\tassert_eq!(\n\t\t\tresp2.players[\u0026client1.id()].attributes[\u0026(i + 287)],\n\t\t\tValue::String(format!(\"world {}\", i).as_str().try_into().unwrap())\n\t\t);\n\t}\n\n\tassert_eq!(resp2.objects.len(), 10);\n\n\tfor i in 0..60 {\n\t\tlet object_id = client1.derive_global_id(i % 10);\n\t\tlet attribute_a_id = i as u16 + 1000;\n\t\tlet attribute_b_id = i as u16 + 2000;\n\t\tassert_eq!(\n\t\t\tresp2.objects[\u0026object_id].attributes[\u0026attribute_a_id],\n\t\t\tValue::Uint64(989873 + i as u64)\n\t\t);\n\n\t\tassert_eq!(\n\t\t\tresp2.objects[\u0026object_id].attributes[\u0026attribute_b_id],\n\t\t\tValue::String(format!(\"hello {}\", i).as_str().try_into().unwrap())\n\t\t);\n\n\t\t// 12 streamed + owner id assigned by the server\n\t\tassert_eq!(resp2.objects[\u0026object_id].attributes.len(), 13);\n\t}\n\n\tOk(())\n}\n\n#[tokio::test]\nasync fn udp_send_pathological_packets() -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::default().await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\n\tlet mut sent_strings = FxHashSet::default();\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tclient1.roundtrip(update).await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((4.0, 5.0, 6.0)),\n\t);\n\tclient2.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tfor i in 0..60 {\n\t\tclient1\n\t\t\t.streams()\n\t\t\t.send(\n\t\t\t\tLocalUpdate::Player(i + 1000, Value::Uint64(i as u64 + 12323234)),\n\t\t\t\tQoS::Unreliable,\n\t\t\t)\n\t\t\t.unwrap();\n\n\t\tlet s = nanoid!(32);\n\t\tsent_strings.insert(s.clone());\n\t\tclient1\n\t\t\t.streams()\n\t\t\t.send(\n\t\t\t\tLocalUpdate::Player(\n\t\t\t\t\ti + 100,\n\t\t\t\t\tValue::String(s.as_str().try_into().unwrap()),\n\t\t\t\t),\n\t\t\t\tQoS::Unreliable,\n\t\t\t)\n\t\t\t.unwrap();\n\t}\n\n\tassert_eq!(sent_strings.len(), 60);\n\n\t// give some time for the packets to arriver at the server\n\t// and be processed\n\tsleep(Duration::from_millis(100)).await;\n\n\tlet resp2 = client2.pull().await?;\n\n\tassert_eq!(resp2.players.len(), 1);\n\n\tfor i in 0..60 {\n\t\tassert_eq!(\n\t\t\tresp2.players[\u0026client1.id()].attributes[\u0026(i + 1000)],\n\t\t\tValue::Uint64(i as u64 + 12323234)\n\t\t);\n\n\t\tlet Value::String(s) = resp2.players[\u0026client1.id()].attributes[\u0026(i + 100)]\n\t\telse {\n\t\t\tpanic!(\n\t\t\t\t\"Expected Value::String, got {:?}\",\n\t\t\t\tresp2.players[\u0026client1.id()].attributes[\u0026(i + 100)]\n\t\t\t);\n\t\t};\n\n\t\tassert_eq!(s.len(), 32);\n\t\tassert!(sent_strings.remove(s.as_str()));\n\t}\n\n\tassert!(sent_strings.is_empty());\n\n\t// maximum overhead, each attribute has an object id attached to it\n\t// and uses maximum attribute size with uncompressable random string.\n\tlet mut sent_strings = FxHashSet::default();\n\tfor i in 0..60 {\n\t\tlet object_id = client1.derive_global_id(i);\n\t\tlet s = nanoid!(32);\n\t\tsent_strings.insert(s.clone());\n\t\tclient1\n\t\t\t.streams()\n\t\t\t.send(\n\t\t\t\tLocalUpdate::Object(\n\t\t\t\t\tobject_id,\n\t\t\t\t\ti as u16 + 2000,\n\t\t\t\t\tValue::String(s.as_str().try_into().unwrap()),\n\t\t\t\t),\n\t\t\t\tQoS::Unreliable,\n\t\t\t)\n\t\t\t.unwrap();\n\t}\n\n\tassert_eq!(sent_strings.len(), 60);\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet resp2 = client2.pull().await?;\n\n\tassert_eq!(resp2.objects.len(), 60);\n\n\tfor i in 0..60 {\n\t\tlet object_id = client1.derive_global_id(i);\n\t\tlet attribute_id = i as u16 + 2000;\n\n\t\tassert!(matches!(\n\t\t\tresp2.objects[\u0026object_id].attributes[\u0026attribute_id],\n\t\t\tValue::String(_)\n\t\t));\n\n\t\tlet Value::String(s) = resp2.objects[\u0026object_id].attributes[\u0026attribute_id]\n\t\telse {\n\t\t\tpanic!(\n\t\t\t\t\"Expected Value::String, got {:?}\",\n\t\t\t\tresp2.objects[\u0026object_id].attributes[\u0026attribute_id]\n\t\t\t);\n\t\t};\n\n\t\tassert_eq!(s.len(), 32);\n\t\tassert!(sent_strings.remove(s.as_str()));\n\t}\n\n\tassert!(sent_strings.is_empty());\n\n\tOk(())\n}\n\n#[tokio::test]\nasync fn udp_subscribe_udp_produce() -\u003e anyhow::Result\u003c()\u003e {\n\tsubscribe_produce_base(\n\t\tQoS::Unreliable,\n\t\tQoS::Unreliable,\n\t\tQoS::Unreliable,\n\t\tQoS::Unreliable,\n\t\tQoS::Unreliable,\n\t\tQoS::Unreliable,\n\t\tQoS::Unreliable,\n\t)\n\t.await\n}\n\n#[tokio::test]\nasync fn udp_subscribe_tcp_produce() -\u003e anyhow::Result\u003c()\u003e {\n\tsubscribe_produce_base(\n\t\tQoS::Unreliable,\n\t\tQoS::Reliable,\n\t\tQoS::Reliable,\n\t\tQoS::Reliable,\n\t\tQoS::Reliable,\n\t\tQoS::Reliable,\n\t\tQoS::Reliable,\n\t)\n\t.await\n}\n\n#[tokio::test]\nasync fn tcp_subscribe_tcp_produce() -\u003e anyhow::Result\u003c()\u003e {\n\tsubscribe_produce_base(\n\t\tQoS::Reliable,\n\t\tQoS::Reliable,\n\t\tQoS::Reliable,\n\t\tQoS::Reliable,\n\t\tQoS::Reliable,\n\t\tQoS::Reliable,\n\t\tQoS::Reliable,\n\t)\n\t.await\n}\n\n#[tokio::test]\nasync fn tcp_subscribe_udp_produce() -\u003e anyhow::Result\u003c()\u003e {\n\tsubscribe_produce_base(\n\t\tQoS::Reliable,\n\t\tQoS::Unreliable,\n\t\tQoS::Unreliable,\n\t\tQoS::Unreliable,\n\t\tQoS::Unreliable,\n\t\tQoS::Unreliable,\n\t\tQoS::Unreliable,\n\t)\n\t.await\n}\n\n#[tokio::test]\nasync fn udp_subscribe_mix_produce() -\u003e anyhow::Result\u003c()\u003e {\n\tsubscribe_produce_base(\n\t\tQoS::Unreliable,\n\t\tQoS::Reliable,\n\t\tQoS::Unreliable,\n\t\tQoS::Reliable,\n\t\tQoS::Unreliable,\n\t\tQoS::Reliable,\n\t\tQoS::Unreliable,\n\t)\n\t.await?;\n\n\tsubscribe_produce_base(\n\t\tQoS::Unreliable,\n\t\tQoS::Unreliable,\n\t\tQoS::Reliable,\n\t\tQoS::Unreliable,\n\t\tQoS::Reliable,\n\t\tQoS::Unreliable,\n\t\tQoS::Reliable,\n\t)\n\t.await\n}\n\nasync fn subscribe_produce_base(\n\tsubscribe: QoS,\n\tproduce1: QoS,\n\tproduce2: QoS,\n\tproduce3: QoS,\n\tproduce4: QoS,\n\tproduce5: QoS,\n\tproduce6: QoS,\n) -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::default().await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\n\tclient2.streams().subscribe(\n\t\tQuery {\n\t\t\tradius: Relevance::default(),\n\t\t\tinterval: Duration::from_millis(100),\n\t\t\tevents: EventsFilter::only(\u0026[2001, 2002, 2003]),\n\t\t\t..Default::default()\n\t\t},\n\t\tsubscribe,\n\t)?;\n\n\tclient1.streams().send(\n\t\tLocalUpdate::Player(\n\t\t\tWellKnownAttribute::Position as u16,\n\t\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t\t),\n\t\tproduce1,\n\t)?;\n\tclient1.streams().flush()?;\n\n\t// make client 1 and client 2 positionally relevant to each other\n\t// so that events are delivered within relevancy radius\n\tclient2.streams().send(\n\t\tLocalUpdate::Player(\n\t\t\tWellKnownAttribute::Position as u16,\n\t\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t\t),\n\t\tproduce5,\n\t)?;\n\tclient2.streams().flush()?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tclient1.streams().send(\n\t\tLocalUpdate::Player(\n\t\t\tWellKnownAttribute::Rotation as u16,\n\t\t\tValue::Vec3((84.0, 85.0, 86.0)),\n\t\t),\n\t\tproduce2,\n\t)?;\n\n\tlet client1id = client1.id();\n\tlet obj1id = client1.derive_global_id(1);\n\n\tclient1.streams().send(\n\t\tLocalUpdate::Object(\n\t\t\tobj1id,\n\t\t\tWellKnownAttribute::OwnerId as AttributeId,\n\t\t\tValue::Uint32(client1id),\n\t\t),\n\t\tproduce3,\n\t)?;\n\n\tclient1.streams().send(\n\t\tLocalUpdate::Object(\n\t\t\tobj1id,\n\t\t\t1100,\n\t\t\tValue::String(\"Hello UDP\".try_into().unwrap()),\n\t\t),\n\t\tproduce4,\n\t)?;\n\n\tclient1.streams().send(\n\t\tLocalUpdate::Event(\n\t\t\t2003,\n\t\t\t\"test-event-payload\".as_bytes().to_vec().into_boxed_slice(),\n\t\t\tRecipient::Radius(Relevance::max()),\n\t\t),\n\t\tproduce6,\n\t)?;\n\n\t// wait for the tick to be picked up and for\n\t// spatial reindex to happen\n\ttokio::time::sleep(Duration::from_secs(1)).await;\n\tserver.wait_for_spatial_reindex().await;\n\n\t#[derive(Debug, Default)]\n\tstruct Accum {\n\t\tentities: HashMap\u003cEntityId, HashMap\u003cAttributeId, Value\u003e\u003e,\n\t\tevents: Vec\u003c(u16, Vec\u003cu8\u003e, EntityId, Timestamp)\u003e, // class, payload, sender\n\t}\n\n\tlet received =\n\t\tclient2\n\t\t\t.streams()\n\t\t\t.fold(Accum::default(), |mut acc: Accum, update| match update {\n\t\t\t\tRemoteUpdate::Player(id, attr, value, _timestamp) =\u003e {\n\t\t\t\t\tacc\n\t\t\t\t\t\t.entities\n\t\t\t\t\t\t.entry(EntityId::Player(id))\n\t\t\t\t\t\t.or_default()\n\t\t\t\t\t\t.insert(attr, value);\n\t\t\t\t\tacc\n\t\t\t\t}\n\t\t\t\tRemoteUpdate::Object(id, attr, value, _timestamp) =\u003e {\n\t\t\t\t\tacc\n\t\t\t\t\t\t.entities\n\t\t\t\t\t\t.entry(EntityId::Object(id))\n\t\t\t\t\t\t.or_default()\n\t\t\t\t\t\t.insert(attr, value);\n\t\t\t\t\tacc\n\t\t\t\t}\n\t\t\t\tRemoteUpdate::Event(class, payload, sender, timestamp) =\u003e {\n\t\t\t\t\tacc\n\t\t\t\t\t\t.events\n\t\t\t\t\t\t.push((class, payload.to_vec(), sender, timestamp));\n\t\t\t\t\tacc\n\t\t\t\t}\n\t\t\t});\n\n\ttracing::info!(\"Received: {:?}\", received);\n\n\tassert_eq!(received.entities.len(), 2);\n\tassert_eq!(received.entities[\u0026EntityId::Player(client1.id())].len(), 2);\n\tassert_eq!(\n\t\treceived.entities[\u0026EntityId::Player(client1.id())]\n\t\t\t[\u0026(WellKnownAttribute::Position as u16)],\n\t\tValue::Vec3((1.0, 2.0, 3.0))\n\t);\n\tassert_eq!(\n\t\treceived.entities[\u0026EntityId::Player(client1.id())]\n\t\t\t[\u0026(WellKnownAttribute::Rotation as u16)],\n\t\tValue::Vec3((84.0, 85.0, 86.0))\n\t);\n\n\tassert_eq!(received.entities[\u0026EntityId::Object(obj1id)].len(), 2);\n\tassert_eq!(\n\t\treceived.entities[\u0026EntityId::Object(obj1id)]\n\t\t\t[\u0026(WellKnownAttribute::OwnerId as AttributeId)],\n\t\tValue::Uint32(client1id)\n\t);\n\tassert_eq!(\n\t\treceived.entities[\u0026EntityId::Object(obj1id)][\u00261100],\n\t\tValue::String(\"Hello UDP\".try_into().unwrap())\n\t);\n\n\tassert_eq!(received.events.len(), 1);\n\tassert_eq!(received.events[0].0, 2003);\n\tassert_eq!(received.events[0].1, \"test-event-payload\".as_bytes());\n\tassert_eq!(received.events[0].2, EntityId::Player(client1.id()));\n\n\tOk(())\n}\n\n#[tokio::test]\nasync fn udp_subscribe_udp_produce_large() -\u003e anyhow::Result\u003c()\u003e {\n\tlarge_update_stream(\n\t\tQoS::Unreliable,\n\t\tQoS::Unreliable,\n\t\tQoS::Unreliable,\n\t\tQoS::Unreliable,\n\t\tQoS::Unreliable,\n\t)\n\t.await\n}\n\n#[tokio::test]\nasync fn tcp_subscribe_udp_produce_large() -\u003e anyhow::Result\u003c()\u003e {\n\tlarge_update_stream(\n\t\tQoS::Reliable,\n\t\tQoS::Unreliable,\n\t\tQoS::Unreliable,\n\t\tQoS::Unreliable,\n\t\tQoS::Unreliable,\n\t)\n\t.await\n}\n\n#[tokio::test]\nasync fn udp_subscribe_tcp_produce_large() -\u003e anyhow::Result\u003c()\u003e {\n\tlarge_update_stream(\n\t\tQoS::Unreliable,\n\t\tQoS::Reliable,\n\t\tQoS::Reliable,\n\t\tQoS::Reliable,\n\t\tQoS::Reliable,\n\t)\n\t.await\n}\n\n#[tokio::test]\nasync fn udp_subscribe_mix_produce_large() -\u003e anyhow::Result\u003c()\u003e {\n\tlarge_update_stream(\n\t\tQoS::Unreliable,\n\t\tQoS::Reliable,\n\t\tQoS::Unreliable,\n\t\tQoS::Reliable,\n\t\tQoS::Unreliable,\n\t)\n\t.await\n}\n\n#[tokio::test]\nasync fn tcp_subscribe_mix_produce_large() -\u003e anyhow::Result\u003c()\u003e {\n\tlarge_update_stream(\n\t\tQoS::Reliable,\n\t\tQoS::Unreliable,\n\t\tQoS::Reliable,\n\t\tQoS::Unreliable,\n\t\tQoS::Reliable,\n\t)\n\t.await\n}\n\n/// Tests that a UDP query subscription tick that won't fit into into one\n/// MTU packet is split into multiple packets and delivered.\nasync fn large_update_stream(\n\tsubscription: QoS,\n\tproducer1: QoS,\n\tproducer2: QoS,\n\tproducer3: QoS,\n\tproducer4: QoS,\n) -\u003e anyhow::Result\u003c()\u003e {\n\tlet server = MockServer::default().await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\n\tlet started = client1.streams().time().timestamp();\n\n\t// create UDP subscription for client 2\n\tclient2.streams().subscribe(\n\t\tQuery {\n\t\t\tradius: Relevance::default(),\n\t\t\tinterval: Duration::from_millis(100),\n\t\t\tevents: EventsFilter::only(\u0026[2001, 2002, 2003]),\n\t\t\t..Default::default()\n\t\t},\n\t\tsubscription,\n\t)?;\n\n\t// make client 1 \u0026 2 relevant to each other\n\tclient1.streams().send(\n\t\tLocalUpdate::Player(\n\t\t\tWellKnownAttribute::Position as u16,\n\t\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t\t),\n\t\tproducer1,\n\t)?;\n\n\tclient2.streams().send(\n\t\tLocalUpdate::Player(\n\t\t\tWellKnownAttribute::Position as u16,\n\t\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t\t),\n\t\tproducer2,\n\t)?;\n\n\t// wait for the tick to be picked up and for\n\t// spatial reindex to happen\n\ttokio::time::sleep(Duration::from_secs(1)).await;\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet received: Vec\u003c_\u003e = client2.streams().collect();\n\tassert_eq!(received.len(), 1);\n\tassert!(matches!(\n\t\t\t\t\t\u0026received[0],\n\t\t\t\t\tRemoteUpdate::Player(id, class_id, value, timestamp) if id.eq(\u0026client1.id())\n\t\t\t\t\t\u0026\u0026 class_id.eq(\u0026(WellKnownAttribute::Position as AttributeId))\n\t\t\t\t\t\u0026\u0026 value.eq(\u0026Value::Vec3((1.0, 2.0, 3.0)))\n\t\t\t\t\t\u0026\u0026 *timestamp \u003e= started\n\t));\n\n\t// good, now from client 1 transmit 100 attributes\n\n\tfor i in 0..100 {\n\t\tclient1.streams().send(\n\t\t\tLocalUpdate::Player(100 + i, Value::Uint64(i as u64 + 12323234)),\n\t\t\tproducer3,\n\t\t)?;\n\t}\n\n\t// then create 100 objects with 10 attributes each\n\tfor i in 0..100 {\n\t\tlet object_id = client1.derive_global_id(i);\n\t\tfor j in 0..10 {\n\t\t\tclient1.streams().send(\n\t\t\t\tLocalUpdate::Object(\n\t\t\t\t\tobject_id,\n\t\t\t\t\t1000 + j,\n\t\t\t\t\tValue::Uint64(989873 + j as u64),\n\t\t\t\t),\n\t\t\t\tproducer4,\n\t\t\t)?;\n\t\t}\n\t}\n\n\t// wait for the tick to be picked up and for\n\ttokio::time::sleep(Duration::from_secs(1)).await;\n\n\tlet received: Vec\u003c_\u003e = client2.streams().collect();\n\tassert_eq!(received.len(), 100 + (100 * 11)); // 10 attribs + owner id auto attribute\n\n\tfor i in 0..100 {\n\t\tassert!(received.iter().any(|update| matches!(\n\t\t\t\t\t\tupdate,\n\t\t\t\t\t\tRemoteUpdate::Player(id, attr_id, value, timestamp) if id.eq(\u0026client1.id())\n\t\t\t\t\t\t\u0026\u0026 *attr_id == (100 + i)\n\t\t\t\t\t\t\u0026\u0026 value.eq(\u0026Value::Uint64(i as u64 + 12323234))\n\t\t\t\t\t\t\u0026\u0026 *timestamp \u003e= started\n\t\t)));\n\t}\n\n\tfor i in 0..100 {\n\t\tlet object_id = client1.derive_global_id(i);\n\t\tassert!(received.iter().any(|update| matches!(\n\t\t\t\t\t\tupdate,\n\t\t\t\t\t\tRemoteUpdate::Object(id, attr_id, value, timestamp) if *id == object_id\n\t\t\t\t\t\t\u0026\u0026 *attr_id == WellKnownAttribute::OwnerId as AttributeId\n\t\t\t\t\t\t\u0026\u0026 value.eq(\u0026Value::Uint32(client1.id()))\n\t\t\t\t\t\t\u0026\u0026 *timestamp \u003e= started\n\t\t)));\n\n\t\tfor j in 0..10 {\n\t\t\tassert!(received.iter().any(|update| matches!(\n\t\t\t\t\t\t\tupdate,\n\t\t\t\t\t\t\tRemoteUpdate::Object(id, attr_id, value, timestamp) if *id == object_id\n\t\t\t\t\t\t\t\u0026\u0026 *attr_id == 1000 + j\n\t\t\t\t\t\t\t\u0026\u0026 value.eq(\u0026Value::Uint64(989873 + j as u64))\n\t\t\t\t\t\t\t\u0026\u0026 *timestamp \u003e= started\n\t\t\t)));\n\t\t}\n\t}\n\n\tOk(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","tests","tags.rs"],"content":"use {\n\tcrate::{\n\t\topts::ServerOptions,\n\t\tschema::{Object, Ownership, Player, Schema},\n\t\ttests::mock::{MockServer, SessionTestExt, TickUpdate},\n\t},\n\tquark_client_sdk::{AttributeId, Value, WellKnownAttribute},\n};\n\n/// This test will ensure that only objects with the specified tags are returned\n#[tokio::test]\nasync fn receive_only_tagged_objects() -\u003e anyhow::Result\u003c()\u003e {\n\t// create a schema with two classes of objects, each with different tags\n\t// with an overlap of one tag\n\tlet server =\n\t\tMockServer::new(ServerOptions::with_schema(Schema::with_objects(vec![\n\t\t\tObject {\n\t\t\t\tclass_id: 1004,\n\t\t\t\townership: Ownership::Creator,\n\t\t\t\ttags: vec![\"tag1\".into(), \"tag2\".into()],\n\t\t\t\t..Default::default()\n\t\t\t},\n\t\t\tObject {\n\t\t\t\tclass_id: 1005,\n\t\t\t\townership: Ownership::Creator,\n\t\t\t\ttags: vec![\"tag2\".into(), \"tag3\".into()],\n\t\t\t\t..Default::default()\n\t\t\t},\n\t\t])?))\n\t\t.await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.build_session().with_tags(\u0026[\"tag1\"]).build().await?;\n\tlet mut client3 = server.build_session().with_tags(\u0026[\"tag2\"]).build().await?;\n\tlet mut client4 = server.build_session().with_tags(\u0026[\"tag3\"]).build().await?;\n\n\t// create two objects each with a different class\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\n\tlet obj1id = client1.derive_global_id(1);\n\tlet obj2id = client1.derive_global_id(2);\n\n\tupdate.object(obj1id).attributes.insert(\n\t\tWellKnownAttribute::ClassId as AttributeId,\n\t\tValue::Uint64(1004),\n\t);\n\tupdate\n\t\t.object(obj1id)\n\t\t.attributes\n\t\t.insert(1003, Value::String(\"obj1\".try_into()?));\n\n\tupdate.object(obj2id).attributes.insert(\n\t\tWellKnownAttribute::ClassId as AttributeId,\n\t\tValue::Uint64(1005),\n\t);\n\tupdate\n\t\t.object(obj2id)\n\t\t.attributes\n\t\t.insert(1003, Value::String(\"obj2\".try_into()?));\n\n\tclient1.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\n\tlet resp2 = client2.roundtrip(update).await?;\n\tassert!(resp2.players.is_empty());\n\tassert_eq!(resp2.objects.len(), 1);\n\tassert_eq!(resp2.objects[\u0026obj1id].attributes.len(), 3);\n\tassert_eq!(\n\t\tresp2.objects[\u0026obj1id].attributes[\u00261003],\n\t\tValue::String(\"obj1\".try_into()?)\n\t);\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tlet resp3 = client3.roundtrip(update).await?;\n\n\tassert!(resp3.players.is_empty());\n\tassert_eq!(resp3.objects.len(), 2);\n\tassert_eq!(resp3.objects[\u0026obj1id].attributes.len(), 3);\n\tassert_eq!(\n\t\tresp3.objects[\u0026obj1id].attributes[\u00261003],\n\t\tValue::String(\"obj1\".try_into()?)\n\t);\n\n\tassert_eq!(resp3.objects[\u0026obj2id].attributes.len(), 3);\n\tassert_eq!(\n\t\tresp3.objects[\u0026obj2id].attributes[\u00261003],\n\t\tValue::String(\"obj2\".try_into()?)\n\t);\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tlet resp4 = client4.roundtrip(update).await?;\n\n\tassert!(resp4.players.is_empty());\n\tassert_eq!(resp4.objects.len(), 1);\n\tassert_eq!(resp4.objects[\u0026obj2id].attributes.len(), 3);\n\tassert_eq!(\n\t\tresp4.objects[\u0026obj2id].attributes[\u00261003],\n\t\tValue::String(\"obj2\".try_into()?)\n\t);\n\n\tOk(())\n}\n\n/// This test will ensure that only players with the specified tags are returned\n#[tokio::test]\nasync fn receive_only_tagged_players() -\u003e anyhow::Result\u003c()\u003e {\n\t// create a schema with two classes of players, each with different tags\n\t// with an overlap of one tag\n\tlet server =\n\t\tMockServer::new(ServerOptions::with_schema(Schema::with_players(vec![\n\t\t\tPlayer {\n\t\t\t\tclass_id: 1004,\n\t\t\t\ttags: vec![\"tag1\".into(), \"tag2\".into()],\n\t\t\t\t..Default::default()\n\t\t\t},\n\t\t\tPlayer {\n\t\t\t\tclass_id: 1005,\n\t\t\t\ttags: vec![\"tag2\".into(), \"tag3\".into()],\n\t\t\t\t..Default::default()\n\t\t\t},\n\t\t])?))\n\t\t.await?;\n\n\tlet mut client1 = server.new_session().await?;\n\tlet mut client2 = server.new_session().await?;\n\tlet mut client3 = server.new_session().await?;\n\tlet mut client4 = server.build_session().with_tags(\u0026[\"tag1\"]).build().await?;\n\tlet mut client5 = server.build_session().with_tags(\u0026[\"tag2\"]).build().await?;\n\tlet mut client6 = server.build_session().with_tags(\u0026[\"tag3\"]).build().await?;\n\n\t// create two players each with a different class\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::ClassId as AttributeId,\n\t\tValue::Uint64(1004),\n\t);\n\tclient1.roundtrip(update).await?;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::ClassId as AttributeId,\n\t\tValue::Uint64(1005),\n\t);\n\tclient2.roundtrip(update).await?;\n\n\tserver.wait_for_spatial_reindex().await;\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tlet resp3 = client3.roundtrip(update).await?;\n\n\tassert_eq!(resp3.players.len(), 2);\n\tassert_eq!(resp3.objects.len(), 0);\n\n\tassert_eq!(resp3.players[\u0026client1.id()].attributes.len(), 2);\n\tassert_eq!(resp3.players[\u0026client2.id()].attributes.len(), 2);\n\n\tdrop(client3);\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tlet resp4 = client4.roundtrip(update).await?;\n\n\tassert_eq!(resp4.players.len(), 1);\n\tassert_eq!(resp4.objects.len(), 0);\n\tassert_eq!(resp4.players[\u0026client1.id()].attributes.len(), 2);\n\tdrop(client4);\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tlet resp5 = client5.roundtrip(update).await?;\n\n\tassert_eq!(resp5.players.len(), 2);\n\tassert_eq!(resp5.objects.len(), 0);\n\n\tassert_eq!(resp5.players[\u0026client1.id()].attributes.len(), 2);\n\tassert_eq!(resp5.players[\u0026client2.id()].attributes.len(), 2);\n\tdrop(client5);\n\n\tlet mut update = TickUpdate::default();\n\tupdate.player.attributes.insert(\n\t\tWellKnownAttribute::Position as u16,\n\t\tValue::Vec3((1.0, 2.0, 3.0)),\n\t);\n\tlet resp6 = client6.roundtrip(update).await?;\n\n\tassert_eq!(resp6.players.len(), 1);\n\tassert_eq!(resp6.objects.len(), 0);\n\tassert_eq!(resp6.players[\u0026client2.id()].attributes.len(), 2);\n\n\tOk(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","tests","time.rs"],"content":"use {crate::tests::mock::MockServer, std::time::Duration, tokio::time::sleep};\n\n#[tokio::test]\nasync fn time_adjusted_gradually() -\u003e anyhow::Result\u003c()\u003e {\n\t// given\n\tlet server = MockServer::default().await?;\n\tlet mut client1 = server.new_session().await?;\n\tlet streams = client1.streams();\n\n\t// wait for first sync to be done\n\tsleep(Duration::from_millis(200)).await;\n\tlet time = streams.time();\n\ttime.set_delta(100); // client 100ms ahead of server\n\n\t// when\n\tstreams.sync_time();\n\tsleep(Duration::from_millis(100)).await;\n\tassert!(time.delta().abs_diff(50) \u003c 5);\n\n\tstreams.sync_time();\n\tsleep(Duration::from_millis(100)).await;\n\tassert!(time.delta().abs_diff(0) \u003c 5);\n\n\tstreams.sync_time();\n\tsleep(Duration::from_millis(100)).await;\n\tassert!(time.delta().abs_diff(0) \u003c 5);\n\n\ttime.set_delta(-100); // client 100ms behind of server\n\n\tstreams.sync_time();\n\tsleep(Duration::from_millis(100)).await;\n\tassert!(time.delta().abs_diff(-50) \u003c 5);\n\n\tstreams.sync_time();\n\tsleep(Duration::from_millis(100)).await;\n\tassert!(time.delta().abs_diff(0) \u003c 5);\n\n\tstreams.sync_time();\n\tsleep(Duration::from_millis(100)).await;\n\tassert!(time.delta().abs_diff(0) \u003c 5);\n\n\tOk(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","tests","topology.rs"],"content":"use {\n\tcrate::{\n\t\topts,\n\t\ttests::mock::get_next_listen_address,\n\t\ttopology::{Role, Topology},\n\t},\n\tclap::Parser,\n\tstd::{collections::BTreeSet, net::SocketAddr, sync::Arc},\n};\n\nfn make_node(role: Role, bootstrap: \u0026[SocketAddr]) -\u003e Arc\u003cTopology\u003e {\n\tlet mut params = vec![\n\t\t\"quark\".to_string(),\n\t\tformat!(\"--control-addr={}\", get_next_listen_address()),\n\t];\n\n\tfor addr in bootstrap {\n\t\tparams.push(format!(\"--peer={}\", addr));\n\t}\n\n\tmatch role {\n\t\tRole::Server =\u003e params.push(\"server\".to_string()),\n\t\tRole::Proxy =\u003e params.push(\"proxy\".to_string()),\n\t}\n\n\tparams.push(format!(\"--listen-addr={}\", get_next_listen_address()));\n\n\tTopology::new(\u0026opts::Opts::parse_from(params))\n}\n\n#[tokio::test]\nasync fn peer_autodiscovery_one_bootstrap() -\u003e anyhow::Result\u003c()\u003e {\n\tlet bootstrap = make_node(Role::Server, \u0026[]);\n\ttokio::time::sleep(std::time::Duration::from_millis(100)).await;\n\n\tlet node2 = make_node(Role::Server, \u0026[bootstrap.me().control_address]);\n\ttokio::time::sleep(std::time::Duration::from_millis(100)).await;\n\n\tlet node3 = make_node(Role::Server, \u0026[bootstrap.me().control_address]);\n\ttokio::time::sleep(std::time::Duration::from_millis(100)).await;\n\n\tlet node4 = make_node(Role::Server, \u0026[bootstrap.me().control_address]);\n\ttokio::time::sleep(std::time::Duration::from_millis(100)).await;\n\n\t// give them some time to discover each other\n\ttokio::time::sleep(std::time::Duration::from_secs(2)).await;\n\n\tassert_eq!(\n\t\tbootstrap.servers().into_iter().collect::\u003cBTreeSet\u003c_\u003e\u003e(),\n\t\t[\n\t\t\tnode2.me().id.clone(),\n\t\t\tnode3.me().id.clone(),\n\t\t\tnode4.me().id.clone()\n\t\t]\n\t\t.into_iter()\n\t\t.collect()\n\t);\n\n\tassert_eq!(\n\t\tnode2.servers().into_iter().collect::\u003cBTreeSet\u003c_\u003e\u003e(),\n\t\t[\n\t\t\tbootstrap.me().id.clone(),\n\t\t\tnode3.me().id.clone(),\n\t\t\tnode4.me().id.clone()\n\t\t]\n\t\t.into_iter()\n\t\t.collect()\n\t);\n\n\tassert_eq!(\n\t\tnode3.servers().into_iter().collect::\u003cBTreeSet\u003c_\u003e\u003e(),\n\t\t[\n\t\t\tbootstrap.me().id.clone(),\n\t\t\tnode2.me().id.clone(),\n\t\t\tnode4.me().id.clone()\n\t\t]\n\t\t.into_iter()\n\t\t.collect()\n\t);\n\n\tassert_eq!(\n\t\tnode4.servers().into_iter().collect::\u003cBTreeSet\u003c_\u003e\u003e(),\n\t\t[\n\t\t\tbootstrap.me().id.clone(),\n\t\t\tnode2.me().id.clone(),\n\t\t\tnode3.me().id.clone(),\n\t\t]\n\t\t.into_iter()\n\t\t.collect()\n\t);\n\n\tOk(())\n}\n\n#[tokio::test]\nasync fn peer_autodiscovery_two_bootstraps() -\u003e anyhow::Result\u003c()\u003e {\n\tlet bootstrap = make_node(Role::Server, \u0026[]);\n\ttokio::time::sleep(std::time::Duration::from_millis(100)).await;\n\n\tlet node2 = make_node(Role::Server, \u0026[bootstrap.me().control_address]);\n\ttokio::time::sleep(std::time::Duration::from_millis(100)).await;\n\n\tlet node3 = make_node(Role::Server, \u0026[node2.me().control_address]);\n\ttokio::time::sleep(std::time::Duration::from_millis(100)).await;\n\n\tlet node4 = make_node(Role::Server, \u0026[bootstrap.me().control_address]);\n\ttokio::time::sleep(std::time::Duration::from_millis(100)).await;\n\n\t// give them some time to discover each other\n\ttokio::time::sleep(std::time::Duration::from_secs(2)).await;\n\n\tassert_eq!(\n\t\tbootstrap.servers().into_iter().collect::\u003cBTreeSet\u003c_\u003e\u003e(),\n\t\t[\n\t\t\tnode2.me().id.clone(),\n\t\t\tnode3.me().id.clone(),\n\t\t\tnode4.me().id.clone()\n\t\t]\n\t\t.into_iter()\n\t\t.collect()\n\t);\n\n\tassert_eq!(\n\t\tnode2.servers().into_iter().collect::\u003cBTreeSet\u003c_\u003e\u003e(),\n\t\t[\n\t\t\tbootstrap.me().id.clone(),\n\t\t\tnode3.me().id.clone(),\n\t\t\tnode4.me().id.clone()\n\t\t]\n\t\t.into_iter()\n\t\t.collect()\n\t);\n\n\tassert_eq!(\n\t\tnode3.servers().into_iter().collect::\u003cBTreeSet\u003c_\u003e\u003e(),\n\t\t[\n\t\t\tbootstrap.me().id.clone(),\n\t\t\tnode2.me().id.clone(),\n\t\t\tnode4.me().id.clone()\n\t\t]\n\t\t.into_iter()\n\t\t.collect()\n\t);\n\n\tassert_eq!(\n\t\tnode4.servers().into_iter().collect::\u003cBTreeSet\u003c_\u003e\u003e(),\n\t\t[\n\t\t\tbootstrap.me().id.clone(),\n\t\t\tnode2.me().id.clone(),\n\t\t\tnode3.me().id.clone(),\n\t\t]\n\t\t.into_iter()\n\t\t.collect()\n\t);\n\n\tOk(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","topology","discovery.rs"],"content":"use {\n\tsuper::{peer::Peer, NodeInfo, Topology},\n\tfxhash::FxHashSet,\n\tserde::{Deserialize, Serialize},\n\tstd::{net::SocketAddr, sync::Arc, time::Duration},\n\ttokio::{net::TcpListener, time::MissedTickBehavior},\n\ttokio_util::codec::{Framed, LengthDelimitedCodec},\n\ttracing::debug,\n};\n\n/// A snapshot of the topology as viewed by a node.\n///\n/// This is exchanged between nodes in the network to keep the\n/// network view in sync across all machines in the cluster.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct LocalViewSnapshot {\n\t/// Info about the node that is sending the snapshot.\n\tpub me: NodeInfo,\n\n\t/// Discovery addresses of all nodes that are confirmed by the sender.\n\t///\n\t/// When discovering we only publish addresses of other peers instead\n\t/// of the whole node info, because each node needs to confirm its link\n\t/// and connection with those addresses anyway and they will get the full\n\t/// node info then.\n\tpub others: Vec\u003cSocketAddr\u003e,\n}\n\nimpl From\u003c\u0026Topology\u003e for LocalViewSnapshot {\n\tfn from(topology: \u0026Topology) -\u003e Self {\n\t\tSelf {\n\t\t\tme: topology.me.clone(),\n\t\t\tothers: topology\n\t\t\t\t.confirmed\n\t\t\t\t.iter()\n\t\t\t\t.map(|node| node.info().control_address)\n\t\t\t\t.collect(),\n\t\t}\n\t}\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub enum Message {\n\tPing(LocalViewSnapshot),\n\tPong(LocalViewSnapshot),\n}\n\n/// The discovery protocol is a background task that runs on every node in the\n/// cluster. It is responsible for discovering new nodes in the network and\n/// confirming their presence.\n///\n/// The protocol works as following:\n/// - All nodes listen for new connections on their discovery port.\n/// - Any node can connect to any other node on the discovery port.\n/// - When a connection is established, the initiating node sends a ping message\n///   with it's own node information and addresses of other nodes it is\n///   connected to.\n///\n/// - In response to the ping message, the receiving node sends a pong message\n///   with it's own node information and addresses of other nodes it is\n///   connected to.\n///\n/// - When an address of a node is received in a ping or pong message, that\n///   address is added to the unconfirmed list of nodes.\n///\n/// - every some short interval all unconfirmed addresses are tried to be\n///   connected to. and the initial ping-pong handshake is performed.\n///\n/// - Every some longer interval each node will send do a ping-pong handshake\n///   with all confirmed nodes to check if they are still alive and to tell them\n///   about our local view of the network. When a node is discovered in this\n///   way, it is added to the unconfirmed list and then picked up during next\n///   confirmation round.\npub async fn discovery_protocol(topology: Arc\u003cTopology\u003e) -\u003e anyhow::Result\u003c()\u003e {\n\t#[cfg(not(test))]\n\tconst SHUFFLE_INTERVAL: Duration = Duration::from_secs(30);\n\t#[cfg(not(test))]\n\tconst CONFIRM_INTERVAL: Duration = Duration::from_secs(5);\n\n\t#[cfg(test)]\n\tconst SHUFFLE_INTERVAL: Duration = Duration::from_secs(2);\n\t#[cfg(test)]\n\tconst CONFIRM_INTERVAL: Duration = Duration::from_secs(1);\n\n\tlet mut confirm_timer = tokio::time::interval(CONFIRM_INTERVAL);\n\tconfirm_timer.set_missed_tick_behavior(MissedTickBehavior::Delay);\n\n\tlet mut shuffle_timer = tokio::time::interval(SHUFFLE_INTERVAL);\n\tshuffle_timer.set_missed_tick_behavior(MissedTickBehavior::Delay);\n\tdebug!(\"Discovery protocol started as {:?}\", topology.me());\n\n\ttokio::spawn(discovery_accept_loop(Arc::clone(\u0026topology)));\n\n\tloop {\n\t\ttokio::select! {\n\t\t\t_ = confirm_timer.tick() =\u003e confirm(Arc::clone(\u0026topology)).await,\n\t\t\t_ = shuffle_timer.tick() =\u003e shuffle(Arc::clone(\u0026topology)).await,\n\t\t}\n\t}\n}\n\n/// Listens for incoming connections on the discovery port and accepts them.\n///\n/// Once accepted it will expect a Ping message with the connecting node info\n/// and will respond with a Pong message with it's own node info and the nodes\n/// it is currently connected to.\nasync fn discovery_accept_loop(topology: Arc\u003cTopology\u003e) {\n\tlet acceptor = TcpListener::bind(topology.me().control_address)\n\t\t.await\n\t\t.expect(\"Failed to bind to discovery port\");\n\n\tloop {\n\t\twhile let Ok((stream, from)) = acceptor.accept().await {\n\t\t\tlet stream = Framed::new(stream, LengthDelimitedCodec::new());\n\t\t\tlet Ok((peer, others)) =\n\t\t\t\tPeer::accept(stream, Arc::clone(\u0026topology)).await\n\t\t\telse {\n\t\t\t\tdebug!(\"Failed to accept peer from {from}\");\n\t\t\t\tcontinue;\n\t\t\t};\n\n\t\t\tdebug!(\"Peer link established with {peer:?} from {from}\");\n\n\t\t\ttopology.confirm(peer);\n\n\t\t\tfor other in others {\n\t\t\t\ttopology.enqueue(other);\n\t\t\t}\n\n\t\t\tdebug!(\"New topology: {topology:#?}\")\n\t\t}\n\t}\n}\n\n/// Any nodes that we heard about but have not established a connection with\n/// (confirmed) are in the unconfirmed list. This function tries to connect to\n/// all of them and confirm them.\nasync fn confirm(topology: Arc\u003cTopology\u003e) {\n\tlet mut changed = false;\n\tlet unconfirmed = std::mem::take(\u0026mut *topology.unconfirmed.write());\n\n\tfor addr in unconfirmed.iter() {\n\t\tdebug!(\"trying to connect to peer {addr}\");\n\t\tlet Ok((peer, others)) = Peer::connect(*addr, Arc::clone(\u0026topology)).await\n\t\telse {\n\t\t\tdebug!(\"Failed to connect to peer {addr}\");\n\t\t\tcontinue;\n\t\t};\n\n\t\tchanged |= topology.confirm(peer);\n\n\t\tfor other in others {\n\t\t\tif !unconfirmed.contains(\u0026other) {\n\t\t\t\tchanged |= topology.enqueue(other);\n\t\t\t}\n\t\t}\n\t}\n\n\tif changed {\n\t\tdebug!(\"New topology: {topology:#?}\")\n\t}\n}\n\n/// This performs the priodic discovery shuffle.\n///\n/// It pings all confirmed nodes and adds all other nodes that are it learns\n/// about and are not confirmed locally to the unconfirmed list.\n///\n/// This step ensures that the network is always in sync and that all nodes are\n/// aware of each other. This is also a self-healing mechanism that ensures that\n/// if the local views of the network diverge, they will eventually converge.\nasync fn shuffle(topology: Arc\u003cTopology\u003e) {\n\tlet mut failed = FxHashSet::default();\n\tlet mut enqueue = FxHashSet::default();\n\n\tfor peer in topology.confirmed.iter() {\n\t\tlet Ok(snapshot) = peer.ping().await else {\n\t\t\tdebug!(\"Failed to ping peer {:?}, removing from topology\", *peer);\n\t\t\tfailed.insert(peer.id().to_string());\n\t\t\tcontinue;\n\t\t};\n\n\t\tfor other in snapshot.others {\n\t\t\tenqueue.insert(other);\n\t\t}\n\t}\n\n\tfor id in failed {\n\t\ttopology.confirmed.remove(\u0026id);\n\t}\n\n\tfor addr in enqueue {\n\t\ttopology.enqueue(addr);\n\t}\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":80},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":80},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":80},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":68},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":238},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":130},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":38},"fn_name":null}],"covered":45,"coverable":54},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","topology","mod.rs"],"content":"use {\n\tself::{discovery::discovery_protocol, peer::Peer},\n\tcrate::{\n\t\topts::{Mode, Opts},\n\t\tstate::player::PlayerId,\n\t},\n\tdashmap::{\n\t\tmapref::{multiple::RefMulti, one::Ref},\n\t\tDashMap,\n\t},\n\tfxhash::FxHashSet,\n\tnanoid::nanoid,\n\tparking_lot::RwLock,\n\trand::seq::IteratorRandom,\n\tserde::{Deserialize, Serialize},\n\tstd::{\n\t\tnet::{IpAddr, SocketAddr},\n\t\tsync::Arc,\n\t},\n\ttracing::debug,\n};\n\nmod discovery;\nmod peer;\n\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub enum Role {\n\t/// A stateful Quark server node that holds world state.\n\tServer,\n\n\t/// A stateless client-facing Quark proxy node that forwards\n\t/// requests to servers.\n\tProxy,\n}\n\n/// Describes a node in the cluster.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct NodeInfo {\n\t/// Unique identifier of the peer.\n\t///\n\t/// This is generated by the peer itself\n\t/// and is regenerated every time the peer restarts.\n\tpub id: String,\n\n\t/// Address of the public facing interface that serves clients.\n\t///\n\t/// Note that this is the address that is observed by other peers in the\n\t/// cluster not the address that a node thinks it has. This is important\n\t/// because very often nodes do not know their own public address and need to\n\t/// be told what is the IP that they are reachable through.\n\tpub listen_address: SocketAddr,\n\n\t/// Address of the discovery protocol server on that node.\n\tpub control_address: SocketAddr,\n\n\t/// Role of the node in the cluster.\n\t/// This could be a server or a proxy.\n\tpub role: Role,\n}\n\nimpl PartialEq for NodeInfo {\n\tfn eq(\u0026self, other: \u0026Self) -\u003e bool {\n\t\tself.id == other.id\n\t}\n}\n\nimpl NodeInfo {\n\t/// Replace the IP address of the node with the given IP address.\n\t/// This is used when the node is discovered with a different IP address\n\t/// than the one it thinks it has.\n\tpub fn replace_ip(\u0026mut self, ip: IpAddr) {\n\t\tself.listen_address.set_ip(ip);\n\t\tself.control_address.set_ip(ip);\n\t}\n}\n\nimpl NodeInfo {\n\tpub fn fromopts(opts: \u0026Opts) -\u003e Self {\n\t\tmatch \u0026opts.mode {\n\t\t\tNone =\u003e NodeInfo {\n\t\t\t\tid: nanoid!(16),\n\t\t\t\trole: Role::Server,\n\t\t\t\tlisten_address: SocketAddr::new(\n\t\t\t\t\tIpAddr::V4(std::net::Ipv4Addr::new(0, 0, 0, 0)),\n\t\t\t\t\t0,\n\t\t\t\t),\n\t\t\t\tcontrol_address: opts.control_addr,\n\t\t\t},\n\t\t\tSome(Mode::Server(serveropts)) =\u003e NodeInfo {\n\t\t\t\tid: nanoid!(16),\n\t\t\t\trole: Role::Server,\n\t\t\t\tlisten_address: serveropts.listen_addr,\n\t\t\t\tcontrol_address: opts.control_addr,\n\t\t\t},\n\t\t\tSome(Mode::Proxy(proxyopts)) =\u003e NodeInfo {\n\t\t\t\tid: nanoid!(16),\n\t\t\t\trole: Role::Proxy,\n\t\t\t\tlisten_address: proxyopts.listen_addr,\n\t\t\t\tcontrol_address: opts.control_addr,\n\t\t\t},\n\t\t}\n\t}\n}\n\n/// Represents the topology of a quark cluster.\n///\n/// This topology is the local view of the current node of the rest of the\n/// network. It gets populated as the network changes over time.\n///\n/// A serialized copy of this data structure is propagated by this node to all\n/// peers periodically to keep the network view in sync on all nodes.\n#[derive(Debug)]\npub struct Topology {\n\t/// Specifications of the current local node.\n\tme: NodeInfo,\n\n\t/// List of all nodes that were discovered and confirmed to be part of the\n\t/// network.\n\t///\n\t/// Confirmation happens only when a discovery handshake is successfull\n\t/// between this node and the other node.\n\tconfirmed: DashMap\u003cString, Peer\u003e,\n\n\t/// List of all nodes that could potentially be part of the network but have\n\t/// not been confirmed yet.\n\t///\n\t/// Addresses supplied by the command line are added to this list.\n\tunconfirmed: RwLock\u003cFxHashSet\u003cSocketAddr\u003e\u003e,\n}\n\nimpl Topology {\n\tpub fn new(opts: \u0026Opts) -\u003e Arc\u003cSelf\u003e {\n\t\tlet confirmed = DashMap::new();\n\t\tlet unconfirmed = Default::default();\n\t\tlet me = NodeInfo::fromopts(opts);\n\n\t\tlet instance = Arc::new(Self {\n\t\t\tme,\n\t\t\tconfirmed,\n\t\t\tunconfirmed,\n\t\t});\n\n\t\t// Start the discovery protocol in the background\n\t\ttokio::spawn(discovery_protocol(Arc::clone(\u0026instance)));\n\n\t\tfor peer in opts.peers.iter() {\n\t\t\tinstance.enqueue(*peer);\n\t\t}\n\n\t\t// return the public interface to the discovery protocol\n\t\tinstance\n\t}\n\n\t/// Returns a list of all confirmed server nodes in the topology.\n\t#[allow(dead_code)]\n\tpub fn servers(\u0026self) -\u003e Vec\u003cString\u003e {\n\t\tself\n\t\t\t.confirmed\n\t\t\t.iter()\n\t\t\t.filter(|node| node.info().role == Role::Server)\n\t\t\t.map(|node| node.info().id.clone())\n\t\t\t.collect()\n\t}\n\n\t/// Returns a list of all confirmed proxy nodes in the topology.\n\t#[allow(dead_code)]\n\tpub fn proxies(\u0026self) -\u003e Vec\u003cString\u003e {\n\t\tself\n\t\t\t.confirmed\n\t\t\t.iter()\n\t\t\t.filter(|node| node.info().role == Role::Proxy)\n\t\t\t.map(|node| node.info().id.clone())\n\t\t\t.collect()\n\t}\n\n\t/// Given a Node ID checks if we are aware of a proxy with that ID.\n\tpub fn is_proxy(\u0026self, id: \u0026str) -\u003e bool {\n\t\tself\n\t\t\t.confirmed\n\t\t\t.get(id)\n\t\t\t.map(|node| node.info().role == Role::Proxy)\n\t\t\t.unwrap_or(false)\n\t}\n\n\t/// Given a Node ID checks if we are aware of a server with that ID.\n\t#[allow(dead_code)]\n\tpub fn is_server(\u0026self, id: \u0026str) -\u003e bool {\n\t\tself\n\t\t\t.confirmed\n\t\t\t.get(id)\n\t\t\t.map(|node| node.info().role == Role::Server)\n\t\t\t.unwrap_or(false)\n\t}\n\n\t/// Access a specific connected peer by its ID.\n\t#[allow(dead_code)]\n\tpub fn get(\u0026self, id: \u0026str) -\u003e Option\u003cRef\u003c'_, String, Peer\u003e\u003e {\n\t\tself.confirmed.get(id)\n\t}\n\n\t/// Returns the current node.\n\tpub fn me(\u0026self) -\u003e \u0026NodeInfo {\n\t\t\u0026self.me\n\t}\n}\n\nimpl Topology {\n\t/// Given a player id this method will select a server that is most\n\t/// suitable for hosting the player session.\n\tpub fn server_for(\n\t\t\u0026self,\n\t\t_player_id: \u0026PlayerId,\n\t) -\u003e Option\u003cRefMulti\u003c'_, String, Peer\u003e\u003e {\n\t\tself\n\t\t\t.confirmed\n\t\t\t.iter()\n\t\t\t.filter(|node| node.info().role == Role::Server)\n\t\t\t.choose(\u0026mut rand::thread_rng())\n\t}\n}\n\nimpl Topology {\n\tfn confirm(\u0026self, peer: Peer) -\u003e bool {\n\t\tself\n\t\t\t.unconfirmed\n\t\t\t.write()\n\t\t\t.remove(\u0026peer.info().control_address);\n\n\t\tif peer.id() == self.me().id {\n\t\t\treturn false;\n\t\t}\n\n\t\tlet peer_info = peer.info().clone();\n\t\tself.confirmed.insert(peer.id().into(), peer);\n\t\tdebug!(\"Confirmed p2p peer {peer_info:?}\");\n\t\ttrue\n\t}\n\n\tfn enqueue(\u0026self, addr: SocketAddr) -\u003e bool {\n\t\tif addr == self.me.control_address {\n\t\t\treturn false;\n\t\t}\n\n\t\tif self\n\t\t\t.confirmed\n\t\t\t.iter()\n\t\t\t.any(|node| node.info().control_address == addr)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tif self.unconfirmed.write().insert(addr) {\n\t\t\tdebug!(\"Enqueued p2p peer {addr}\");\n\t\t\ttrue\n\t\t} else {\n\t\t\tfalse\n\t\t}\n\t}\n}\n\n/// This implementation is only used in tests that do not care about\n/// the actual network topology.\n#[cfg(test)]\nimpl Default for Topology {\n\tfn default() -\u003e Self {\n\t\tSelf {\n\t\t\tme: NodeInfo {\n\t\t\t\tid: nanoid!(16),\n\t\t\t\trole: Role::Server,\n\t\t\t\tlisten_address: SocketAddr::new(\n\t\t\t\t\tIpAddr::V4(std::net::Ipv4Addr::new(0, 0, 0, 0)),\n\t\t\t\t\t0,\n\t\t\t\t),\n\t\t\t\tcontrol_address: SocketAddr::new(\n\t\t\t\t\tIpAddr::V4(std::net::Ipv4Addr::new(0, 0, 0, 0)),\n\t\t\t\t\t0,\n\t\t\t\t),\n\t\t\t},\n\t\t\tconfirmed: DashMap::new(),\n\t\t\tunconfirmed: Default::default(),\n\t\t}\n\t}\n}\n","traces":[{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":80},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":80},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":80},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":62},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":62},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":135},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":4},"fn_name":null}],"covered":47,"coverable":78},{"path":["/","home","ubuntu","actions-runner","_work","Quark","Quark","server","src","topology","peer.rs"],"content":"use {\n\tsuper::{\n\t\tdiscovery::{LocalViewSnapshot, Message},\n\t\tNodeInfo,\n\t\tTopology,\n\t},\n\tfutures::{SinkExt, StreamExt},\n\tstd::{\n\t\tfmt::{self, Debug, Formatter},\n\t\tnet::SocketAddr,\n\t\tsync::Arc,\n\t},\n\ttokio::{\n\t\tnet::TcpStream,\n\t\tsync::{\n\t\t\tmpsc::{unbounded_channel, UnboundedReceiver, UnboundedSender},\n\t\t\tRwLock,\n\t\t},\n\t},\n\ttokio_util::codec::{Framed, LengthDelimitedCodec},\n\ttracing::{debug, error},\n};\n\ntype Stream = Framed\u003cTcpStream, LengthDelimitedCodec\u003e;\n\npub enum PeerUpdate {\n\tViewUpdate(LocalViewSnapshot),\n\tDisconnected,\n}\n\n/// Represents one connected peer with an active TCP connection.\npub struct Peer {\n\tinfo: NodeInfo,\n\ttopology: Arc\u003cTopology\u003e,\n\tout_tx: RwLock\u003cUnboundedSender\u003cLocalViewSnapshot\u003e\u003e,\n\tin_rx: RwLock\u003cUnboundedReceiver\u003cPeerUpdate\u003e\u003e,\n}\n\nimpl Debug for Peer {\n\tfn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e fmt::Result {\n\t\tf.debug_struct(\"Peer\").field(\"info\", \u0026self.info).finish()\n\t}\n}\n\nimpl Peer {\n\t/// Self-advertised node information.\n\tpub fn info(\u0026self) -\u003e \u0026NodeInfo {\n\t\t\u0026self.info\n\t}\n\n\t/// Node unique identifier across the cluster.\n\tpub fn id(\u0026self) -\u003e \u0026str {\n\t\t\u0026self.info().id\n\t}\n}\n\nimpl Peer {\n\tpub async fn connect(\n\t\taddress: SocketAddr,\n\t\ttopology: Arc\u003cTopology\u003e,\n\t) -\u003e anyhow::Result\u003c(Self, Vec\u003cSocketAddr\u003e)\u003e {\n\t\tlet snapshot = LocalViewSnapshot::from(\u0026*topology);\n\t\tlet stream = TcpStream::connect(address).await?;\n\t\tlet mut stream = Framed::new(stream, LengthDelimitedCodec::new());\n\t\tlet ping = bincode::serialize(\u0026Message::Ping(snapshot))?.into();\n\t\tstream.send(ping).await?;\n\n\t\tlet pong = stream\n\t\t\t.next()\n\t\t\t.await\n\t\t\t.ok_or_else(|| anyhow::anyhow!(\"failed to receive peer info\"))??;\n\n\t\tlet Message::Pong(pong) = bincode::deserialize::\u003cMessage\u003e(\u0026pong)? else {\n\t\t\treturn Err(anyhow::anyhow!(\"expected pong message\"));\n\t\t};\n\n\t\tlet mut info = pong.me;\n\t\tlet others = pong.others;\n\n\t\tlet remote_addr = stream.get_ref().peer_addr()?;\n\t\tinfo.replace_ip(remote_addr.ip());\n\n\t\tOk((Self::new(stream, topology, info)?, others))\n\t}\n\n\tpub async fn accept(\n\t\tstream: Stream,\n\t\ttopology: Arc\u003cTopology\u003e,\n\t) -\u003e anyhow::Result\u003c(Self, Vec\u003cSocketAddr\u003e)\u003e {\n\t\tlet mut stream = stream;\n\n\t\tlet ping = stream\n\t\t\t.next()\n\t\t\t.await\n\t\t\t.ok_or_else(|| anyhow::anyhow!(\"failed to receive peer info\"))??;\n\n\t\tlet Message::Ping(ping) = bincode::deserialize::\u003cMessage\u003e(\u0026ping)? else {\n\t\t\treturn Err(anyhow::anyhow!(\"expected ping message\"));\n\t\t};\n\n\t\tlet mut info = ping.me;\n\n\t\t// The publicly visible IP of the peer might be\n\t\t// different from the one that it thinks it has.\n\t\tinfo.replace_ip(stream.get_ref().peer_addr()?.ip());\n\n\t\t// send back our local view of the cluster\n\t\tlet snapshot = LocalViewSnapshot::from(\u0026*topology);\n\t\tlet pong = bincode::serialize(\u0026Message::Pong(snapshot))?.into();\n\t\tstream.send(pong).await?;\n\n\t\tOk((Self::new(stream, topology, info)?, ping.others))\n\t}\n\n\tfn new(\n\t\tlink: Stream,\n\t\ttopology: Arc\u003cTopology\u003e,\n\t\tinfo: NodeInfo,\n\t) -\u003e anyhow::Result\u003cSelf\u003e {\n\t\tlet (in_tx, in_rx) = unbounded_channel();\n\t\tlet (out_tx, out_rx) = unbounded_channel();\n\t\tlet remote_addr = link.get_ref().peer_addr()?;\n\n\t\ttokio::spawn(peer_loop(\n\t\t\tArc::clone(\u0026topology),\n\t\t\tlink,\n\t\t\tout_rx,\n\t\t\tin_tx,\n\t\t\tremote_addr,\n\t\t));\n\n\t\tOk(Self {\n\t\t\tinfo,\n\t\t\ttopology,\n\t\t\tout_tx: RwLock::new(out_tx),\n\t\t\tin_rx: RwLock::new(in_rx),\n\t\t})\n\t}\n\n\tpub async fn ping(\u0026self) -\u003e anyhow::Result\u003cLocalViewSnapshot\u003e {\n\t\tself\n\t\t\t.out_tx\n\t\t\t.write()\n\t\t\t.await\n\t\t\t.send(LocalViewSnapshot::from(\u0026*self.topology))?;\n\n\t\tmatch self.in_rx.write().await.recv().await {\n\t\t\tSome(PeerUpdate::ViewUpdate(snapshot)) =\u003e Ok(snapshot),\n\t\t\tSome(PeerUpdate::Disconnected) =\u003e {\n\t\t\t\tErr(anyhow::anyhow!(\"peer disconnected\"))\n\t\t\t}\n\t\t\tNone =\u003e Err(anyhow::anyhow!(\"peer disconnected\")),\n\t\t}\n\t}\n}\n\nimpl PartialEq for Peer {\n\tfn eq(\u0026self, other: \u0026Self) -\u003e bool {\n\t\tself.info().id == other.info().id\n\t}\n}\n\nimpl Eq for Peer {}\n\nimpl std::hash::Hash for Peer {\n\tfn hash\u003cH: std::hash::Hasher\u003e(\u0026self, state: \u0026mut H) {\n\t\tself.id().hash(state);\n\t}\n}\n\nasync fn peer_loop(\n\ttopology: Arc\u003cTopology\u003e,\n\tlink: Stream,\n\tout_rx: UnboundedReceiver\u003cLocalViewSnapshot\u003e,\n\tin_tx: UnboundedSender\u003cPeerUpdate\u003e,\n\tremote_addr: SocketAddr,\n) {\n\tlet mut link = link;\n\tlet mut out_rx = out_rx;\n\n\tloop {\n\t\ttokio::select! {\n\t\tSome(snapshot) = out_rx.recv() =\u003e {\n\t\t\tlet message = bincode::serialize(\u0026Message::Ping(snapshot)).unwrap().into();\n\t\t\tif link.send(message).await.is_err() {\n\t\t\t\tlet _ =  in_tx.send(PeerUpdate::Disconnected);\n\t\t\t}\n\t\t}\n\t\tupdate = link.next() =\u003e {\n\t\t\tmatch update {\n\t\t\t\t\tSome(Ok(message)) =\u003e handle_message(\n\t\t\t\t\t\tbincode::deserialize(\u0026message).unwrap(),\n\t\t\t\t\t\tArc::clone(\u0026topology),\n\t\t\t\t\t\tremote_addr,\n\t\t\t\t\t\t\u0026mut link,\n\t\t\t\t\t\tin_tx.clone(),\n\t\t\t\t\t).await,\n\t\t\t\t\tSome(Err(e)) =\u003e {\n\t\t\t\t\t\terror!(\"Failed to read message from peer: {e}\");\n\t\t\t\t\t\tlet _ = in_tx.send(PeerUpdate::Disconnected);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tNone =\u003e {\n\t\t\t\t\t\tdebug!(\"Peer disconnected: {remote_addr}\");\n\t\t\t\t\t\tlet _ = in_tx.send(PeerUpdate::Disconnected);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nasync fn handle_message(\n\tmessage: Message,\n\ttopology: Arc\u003cTopology\u003e,\n\tremote_addr: SocketAddr,\n\tlink: \u0026mut Stream,\n\tin_tx: UnboundedSender\u003cPeerUpdate\u003e,\n) {\n\tmatch message {\n\t\t// On Ping messages we always respond with a Pong message\n\t\tMessage::Ping(mut snapshot) =\u003e {\n\t\t\tsnapshot.me.replace_ip(remote_addr.ip());\n\t\t\tif in_tx.send(PeerUpdate::ViewUpdate(snapshot)).is_err() {\n\t\t\t\tlet _ = in_tx.send(PeerUpdate::Disconnected);\n\t\t\t}\n\t\t\tlet our_snapshot = LocalViewSnapshot::from(\u0026*topology);\n\t\t\tlet our_snapshot = bincode::serialize(\u0026Message::Pong(our_snapshot))\n\t\t\t\t.unwrap()\n\t\t\t\t.into();\n\n\t\t\tif link.send(our_snapshot).await.is_err() {\n\t\t\t\tlet _ = in_tx.send(PeerUpdate::Disconnected);\n\t\t\t}\n\t\t}\n\n\t\t// On Pong message we don't respond with anything.\n\t\tMessage::Pong(mut snapshot) =\u003e {\n\t\t\tsnapshot.me.replace_ip(remote_addr.ip());\n\t\t\tlet _ = in_tx.send(PeerUpdate::ViewUpdate(snapshot));\n\t\t}\n\t}\n}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":401},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":401},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":68},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":28},"fn_name":null}],"covered":54,"coverable":69}]};
        var previousData = null;
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>
